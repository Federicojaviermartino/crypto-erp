
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * User account for authentication
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * Company (tenant) - main multi-tenancy entity
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyUser
 * User-Company relationship with role
 */
export type CompanyUser = $Result.DefaultSelection<Prisma.$CompanyUserPayload>
/**
 * Model Contact
 * Customer/Supplier contact
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model FiscalYear
 * Fiscal year period
 */
export type FiscalYear = $Result.DefaultSelection<Prisma.$FiscalYearPayload>
/**
 * Model Account
 * Chart of accounts
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model JournalEntry
 * Journal entry header
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model JournalLine
 * Journal entry line (debit or credit)
 */
export type JournalLine = $Result.DefaultSelection<Prisma.$JournalLinePayload>
/**
 * Model InvoiceSeries
 * Invoice series configuration
 */
export type InvoiceSeries = $Result.DefaultSelection<Prisma.$InvoiceSeriesPayload>
/**
 * Model Invoice
 * Invoice header
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLine
 * Invoice line item
 */
export type InvoiceLine = $Result.DefaultSelection<Prisma.$InvoiceLinePayload>
/**
 * Model InvoiceTax
 * Invoice tax breakdown (for multi-rate invoices)
 */
export type InvoiceTax = $Result.DefaultSelection<Prisma.$InvoiceTaxPayload>
/**
 * Model CryptoAsset
 * Crypto asset definition
 */
export type CryptoAsset = $Result.DefaultSelection<Prisma.$CryptoAssetPayload>
/**
 * Model Wallet
 * Blockchain wallet
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model ExchangeAccount
 * Exchange account (Binance, Coinbase, etc.)
 */
export type ExchangeAccount = $Result.DefaultSelection<Prisma.$ExchangeAccountPayload>
/**
 * Model CryptoTransaction
 * Blockchain transaction
 */
export type CryptoTransaction = $Result.DefaultSelection<Prisma.$CryptoTransactionPayload>
/**
 * Model CryptoLot
 * FIFO cost basis lot
 */
export type CryptoLot = $Result.DefaultSelection<Prisma.$CryptoLotPayload>
/**
 * Model PriceHistory
 * Price history for cost basis calculations
 */
export type PriceHistory = $Result.DefaultSelection<Prisma.$PriceHistoryPayload>
/**
 * Model VerifactuRecord
 * Verifactu record for tracking AEAT submissions
 */
export type VerifactuRecord = $Result.DefaultSelection<Prisma.$VerifactuRecordPayload>
/**
 * Model AiConversation
 * AI conversation session
 */
export type AiConversation = $Result.DefaultSelection<Prisma.$AiConversationPayload>
/**
 * Model AiMessage
 * AI chat message
 */
export type AiMessage = $Result.DefaultSelection<Prisma.$AiMessagePayload>
/**
 * Model Document
 * Document for RAG knowledge base
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model CompanyInvitation
 * Company invitation for team members
 */
export type CompanyInvitation = $Result.DefaultSelection<Prisma.$CompanyInvitationPayload>
/**
 * Model AuditLog
 * Audit log for tracking operations
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AnalyticsEvent
 * Analytics event for time-series metrics
 * Stored in TimescaleDB hypertable for efficient time-series queries
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model OAuthApp
 * Third-party OAuth applications registered to access the API
 */
export type OAuthApp = $Result.DefaultSelection<Prisma.$OAuthAppPayload>
/**
 * Model OAuthToken
 * OAuth access and refresh tokens
 */
export type OAuthToken = $Result.DefaultSelection<Prisma.$OAuthTokenPayload>
/**
 * Model ApiUsage
 * API usage tracking for rate limiting and analytics
 */
export type ApiUsage = $Result.DefaultSelection<Prisma.$ApiUsagePayload>
/**
 * Model SubscriptionPlan
 * Subscription plan tiers
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model Subscription
 * Company subscription
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Payment
 * Payment record
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model UserOnboarding
 * User onboarding progress tracking
 */
export type UserOnboarding = $Result.DefaultSelection<Prisma.$UserOnboardingPayload>
/**
 * Model WebhookSubscription
 * Webhook subscription configuration
 */
export type WebhookSubscription = $Result.DefaultSelection<Prisma.$WebhookSubscriptionPayload>
/**
 * Model WebhookDelivery
 * Webhook delivery attempt log
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model WebhookEvent
 * Webhook event log for analytics
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TaxIdType: {
  CIF: 'CIF',
  NIF: 'NIF',
  NIE: 'NIE',
  VAT: 'VAT',
  PASSPORT: 'PASSPORT',
  OTHER: 'OTHER'
};

export type TaxIdType = (typeof TaxIdType)[keyof typeof TaxIdType]


export const CryptoClassification: {
  INVENTORY: 'INVENTORY',
  INTANGIBLE_ASSET: 'INTANGIBLE_ASSET'
};

export type CryptoClassification = (typeof CryptoClassification)[keyof typeof CryptoClassification]


export const UserRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  ACCOUNTANT: 'ACCOUNTANT',
  USER: 'USER',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ContactType: {
  CUSTOMER: 'CUSTOMER',
  SUPPLIER: 'SUPPLIER',
  BOTH: 'BOTH'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]


export const AccountType: {
  ASSET: 'ASSET',
  LIABILITY: 'LIABILITY',
  EQUITY: 'EQUITY',
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const ReferenceType: {
  INVOICE: 'INVOICE',
  CRYPTO_TX: 'CRYPTO_TX',
  BANK_TX: 'BANK_TX',
  MANUAL: 'MANUAL'
};

export type ReferenceType = (typeof ReferenceType)[keyof typeof ReferenceType]


export const SourceType: {
  MANUAL: 'MANUAL',
  INVOICE: 'INVOICE',
  CRYPTO_TX: 'CRYPTO_TX',
  BANK_IMPORT: 'BANK_IMPORT',
  AI: 'AI'
};

export type SourceType = (typeof SourceType)[keyof typeof SourceType]


export const JournalStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  POSTED: 'POSTED',
  REVERSED: 'REVERSED'
};

export type JournalStatus = (typeof JournalStatus)[keyof typeof JournalStatus]


export const InvoiceType: {
  STANDARD: 'STANDARD',
  SIMPLIFIED: 'SIMPLIFIED',
  CREDIT_NOTE: 'CREDIT_NOTE',
  DEBIT_NOTE: 'DEBIT_NOTE'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  ISSUED: 'ISSUED',
  SENT: 'SENT',
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const InvoiceDirection: {
  ISSUED: 'ISSUED',
  RECEIVED: 'RECEIVED'
};

export type InvoiceDirection = (typeof InvoiceDirection)[keyof typeof InvoiceDirection]


export const VerifactuStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  ERROR: 'ERROR'
};

export type VerifactuStatus = (typeof VerifactuStatus)[keyof typeof VerifactuStatus]


export const TaxType: {
  IVA: 'IVA',
  IRPF: 'IRPF',
  IGIC: 'IGIC',
  IPSI: 'IPSI'
};

export type TaxType = (typeof TaxType)[keyof typeof TaxType]


export const WalletType: {
  EXTERNAL: 'EXTERNAL',
  EXCHANGE: 'EXCHANGE',
  DEFI: 'DEFI',
  COLD: 'COLD'
};

export type WalletType = (typeof WalletType)[keyof typeof WalletType]


export const SyncStatus: {
  PENDING: 'PENDING',
  SYNCING: 'SYNCING',
  SYNCED: 'SYNCED',
  ERROR: 'ERROR'
};

export type SyncStatus = (typeof SyncStatus)[keyof typeof SyncStatus]


export const CryptoTxType: {
  TRANSFER_IN: 'TRANSFER_IN',
  TRANSFER_OUT: 'TRANSFER_OUT',
  SWAP: 'SWAP',
  STAKE: 'STAKE',
  UNSTAKE: 'UNSTAKE',
  CLAIM_REWARD: 'CLAIM_REWARD',
  AIRDROP: 'AIRDROP',
  LIQUIDITY_ADD: 'LIQUIDITY_ADD',
  LIQUIDITY_REMOVE: 'LIQUIDITY_REMOVE',
  NFT_MINT: 'NFT_MINT',
  NFT_TRANSFER: 'NFT_TRANSFER',
  NFT_SALE: 'NFT_SALE',
  APPROVE: 'APPROVE',
  CONTRACT_INTERACTION: 'CONTRACT_INTERACTION',
  BRIDGE_OUT: 'BRIDGE_OUT',
  BRIDGE_IN: 'BRIDGE_IN',
  UNKNOWN: 'UNKNOWN'
};

export type CryptoTxType = (typeof CryptoTxType)[keyof typeof CryptoTxType]


export const TxStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  NEEDS_REVIEW: 'NEEDS_REVIEW',
  ERROR: 'ERROR'
};

export type TxStatus = (typeof TxStatus)[keyof typeof TxStatus]


export const VerifactuRecordState: {
  PENDING: 'PENDING',
  ENVIANDO: 'ENVIANDO',
  ACEPTADO: 'ACEPTADO',
  RECHAZADO: 'RECHAZADO',
  ERROR: 'ERROR'
};

export type VerifactuRecordState = (typeof VerifactuRecordState)[keyof typeof VerifactuRecordState]


export const AiRole: {
  USER: 'USER',
  ASSISTANT: 'ASSISTANT',
  SYSTEM: 'SYSTEM'
};

export type AiRole = (typeof AiRole)[keyof typeof AiRole]


export const DocumentType: {
  REGULATION: 'REGULATION',
  KNOWLEDGE_BASE: 'KNOWLEDGE_BASE',
  USER_UPLOAD: 'USER_UPLOAD'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  VIEW: 'VIEW',
  EXPORT: 'EXPORT',
  SEND: 'SEND',
  APPROVE: 'APPROVE',
  REJECT: 'REJECT'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const SubscriptionStatus: {
  TRIALING: 'TRIALING',
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  INCOMPLETE: 'INCOMPLETE',
  INCOMPLETE_EXPIRED: 'INCOMPLETE_EXPIRED',
  UNPAID: 'UNPAID'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const UserOnboardingStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  DISMISSED: 'DISMISSED'
};

export type UserOnboardingStatus = (typeof UserOnboardingStatus)[keyof typeof UserOnboardingStatus]


export const WebhookDeliveryStatus: {
  PENDING: 'PENDING',
  SENDING: 'SENDING',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type WebhookDeliveryStatus = (typeof WebhookDeliveryStatus)[keyof typeof WebhookDeliveryStatus]

}

export type TaxIdType = $Enums.TaxIdType

export const TaxIdType: typeof $Enums.TaxIdType

export type CryptoClassification = $Enums.CryptoClassification

export const CryptoClassification: typeof $Enums.CryptoClassification

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type ReferenceType = $Enums.ReferenceType

export const ReferenceType: typeof $Enums.ReferenceType

export type SourceType = $Enums.SourceType

export const SourceType: typeof $Enums.SourceType

export type JournalStatus = $Enums.JournalStatus

export const JournalStatus: typeof $Enums.JournalStatus

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type InvoiceDirection = $Enums.InvoiceDirection

export const InvoiceDirection: typeof $Enums.InvoiceDirection

export type VerifactuStatus = $Enums.VerifactuStatus

export const VerifactuStatus: typeof $Enums.VerifactuStatus

export type TaxType = $Enums.TaxType

export const TaxType: typeof $Enums.TaxType

export type WalletType = $Enums.WalletType

export const WalletType: typeof $Enums.WalletType

export type SyncStatus = $Enums.SyncStatus

export const SyncStatus: typeof $Enums.SyncStatus

export type CryptoTxType = $Enums.CryptoTxType

export const CryptoTxType: typeof $Enums.CryptoTxType

export type TxStatus = $Enums.TxStatus

export const TxStatus: typeof $Enums.TxStatus

export type VerifactuRecordState = $Enums.VerifactuRecordState

export const VerifactuRecordState: typeof $Enums.VerifactuRecordState

export type AiRole = $Enums.AiRole

export const AiRole: typeof $Enums.AiRole

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type UserOnboardingStatus = $Enums.UserOnboardingStatus

export const UserOnboardingStatus: typeof $Enums.UserOnboardingStatus

export type WebhookDeliveryStatus = $Enums.WebhookDeliveryStatus

export const WebhookDeliveryStatus: typeof $Enums.WebhookDeliveryStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.companyUser`: Exposes CRUD operations for the **CompanyUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyUsers
    * const companyUsers = await prisma.companyUser.findMany()
    * ```
    */
  get companyUser(): Prisma.CompanyUserDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.fiscalYear`: Exposes CRUD operations for the **FiscalYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiscalYears
    * const fiscalYears = await prisma.fiscalYear.findMany()
    * ```
    */
  get fiscalYear(): Prisma.FiscalYearDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs>;

  /**
   * `prisma.journalLine`: Exposes CRUD operations for the **JournalLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalLines
    * const journalLines = await prisma.journalLine.findMany()
    * ```
    */
  get journalLine(): Prisma.JournalLineDelegate<ExtArgs>;

  /**
   * `prisma.invoiceSeries`: Exposes CRUD operations for the **InvoiceSeries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceSeries
    * const invoiceSeries = await prisma.invoiceSeries.findMany()
    * ```
    */
  get invoiceSeries(): Prisma.InvoiceSeriesDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceLine`: Exposes CRUD operations for the **InvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLines
    * const invoiceLines = await prisma.invoiceLine.findMany()
    * ```
    */
  get invoiceLine(): Prisma.InvoiceLineDelegate<ExtArgs>;

  /**
   * `prisma.invoiceTax`: Exposes CRUD operations for the **InvoiceTax** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceTaxes
    * const invoiceTaxes = await prisma.invoiceTax.findMany()
    * ```
    */
  get invoiceTax(): Prisma.InvoiceTaxDelegate<ExtArgs>;

  /**
   * `prisma.cryptoAsset`: Exposes CRUD operations for the **CryptoAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoAssets
    * const cryptoAssets = await prisma.cryptoAsset.findMany()
    * ```
    */
  get cryptoAsset(): Prisma.CryptoAssetDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs>;

  /**
   * `prisma.exchangeAccount`: Exposes CRUD operations for the **ExchangeAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangeAccounts
    * const exchangeAccounts = await prisma.exchangeAccount.findMany()
    * ```
    */
  get exchangeAccount(): Prisma.ExchangeAccountDelegate<ExtArgs>;

  /**
   * `prisma.cryptoTransaction`: Exposes CRUD operations for the **CryptoTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoTransactions
    * const cryptoTransactions = await prisma.cryptoTransaction.findMany()
    * ```
    */
  get cryptoTransaction(): Prisma.CryptoTransactionDelegate<ExtArgs>;

  /**
   * `prisma.cryptoLot`: Exposes CRUD operations for the **CryptoLot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoLots
    * const cryptoLots = await prisma.cryptoLot.findMany()
    * ```
    */
  get cryptoLot(): Prisma.CryptoLotDelegate<ExtArgs>;

  /**
   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceHistories
    * const priceHistories = await prisma.priceHistory.findMany()
    * ```
    */
  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs>;

  /**
   * `prisma.verifactuRecord`: Exposes CRUD operations for the **VerifactuRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerifactuRecords
    * const verifactuRecords = await prisma.verifactuRecord.findMany()
    * ```
    */
  get verifactuRecord(): Prisma.VerifactuRecordDelegate<ExtArgs>;

  /**
   * `prisma.aiConversation`: Exposes CRUD operations for the **AiConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiConversations
    * const aiConversations = await prisma.aiConversation.findMany()
    * ```
    */
  get aiConversation(): Prisma.AiConversationDelegate<ExtArgs>;

  /**
   * `prisma.aiMessage`: Exposes CRUD operations for the **AiMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiMessages
    * const aiMessages = await prisma.aiMessage.findMany()
    * ```
    */
  get aiMessage(): Prisma.AiMessageDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.companyInvitation`: Exposes CRUD operations for the **CompanyInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyInvitations
    * const companyInvitations = await prisma.companyInvitation.findMany()
    * ```
    */
  get companyInvitation(): Prisma.CompanyInvitationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs>;

  /**
   * `prisma.oAuthApp`: Exposes CRUD operations for the **OAuthApp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthApps
    * const oAuthApps = await prisma.oAuthApp.findMany()
    * ```
    */
  get oAuthApp(): Prisma.OAuthAppDelegate<ExtArgs>;

  /**
   * `prisma.oAuthToken`: Exposes CRUD operations for the **OAuthToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthTokens
    * const oAuthTokens = await prisma.oAuthToken.findMany()
    * ```
    */
  get oAuthToken(): Prisma.OAuthTokenDelegate<ExtArgs>;

  /**
   * `prisma.apiUsage`: Exposes CRUD operations for the **ApiUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiUsages
    * const apiUsages = await prisma.apiUsage.findMany()
    * ```
    */
  get apiUsage(): Prisma.ApiUsageDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.userOnboarding`: Exposes CRUD operations for the **UserOnboarding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOnboardings
    * const userOnboardings = await prisma.userOnboarding.findMany()
    * ```
    */
  get userOnboarding(): Prisma.UserOnboardingDelegate<ExtArgs>;

  /**
   * `prisma.webhookSubscription`: Exposes CRUD operations for the **WebhookSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookSubscriptions
    * const webhookSubscriptions = await prisma.webhookSubscription.findMany()
    * ```
    */
  get webhookSubscription(): Prisma.WebhookSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    CompanyUser: 'CompanyUser',
    Contact: 'Contact',
    FiscalYear: 'FiscalYear',
    Account: 'Account',
    JournalEntry: 'JournalEntry',
    JournalLine: 'JournalLine',
    InvoiceSeries: 'InvoiceSeries',
    Invoice: 'Invoice',
    InvoiceLine: 'InvoiceLine',
    InvoiceTax: 'InvoiceTax',
    CryptoAsset: 'CryptoAsset',
    Wallet: 'Wallet',
    ExchangeAccount: 'ExchangeAccount',
    CryptoTransaction: 'CryptoTransaction',
    CryptoLot: 'CryptoLot',
    PriceHistory: 'PriceHistory',
    VerifactuRecord: 'VerifactuRecord',
    AiConversation: 'AiConversation',
    AiMessage: 'AiMessage',
    Document: 'Document',
    CompanyInvitation: 'CompanyInvitation',
    AuditLog: 'AuditLog',
    AnalyticsEvent: 'AnalyticsEvent',
    OAuthApp: 'OAuthApp',
    OAuthToken: 'OAuthToken',
    ApiUsage: 'ApiUsage',
    SubscriptionPlan: 'SubscriptionPlan',
    Subscription: 'Subscription',
    Payment: 'Payment',
    UserOnboarding: 'UserOnboarding',
    WebhookSubscription: 'WebhookSubscription',
    WebhookDelivery: 'WebhookDelivery',
    WebhookEvent: 'WebhookEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "company" | "companyUser" | "contact" | "fiscalYear" | "account" | "journalEntry" | "journalLine" | "invoiceSeries" | "invoice" | "invoiceLine" | "invoiceTax" | "cryptoAsset" | "wallet" | "exchangeAccount" | "cryptoTransaction" | "cryptoLot" | "priceHistory" | "verifactuRecord" | "aiConversation" | "aiMessage" | "document" | "companyInvitation" | "auditLog" | "analyticsEvent" | "oAuthApp" | "oAuthToken" | "apiUsage" | "subscriptionPlan" | "subscription" | "payment" | "userOnboarding" | "webhookSubscription" | "webhookDelivery" | "webhookEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyUser: {
        payload: Prisma.$CompanyUserPayload<ExtArgs>
        fields: Prisma.CompanyUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findFirst: {
            args: Prisma.CompanyUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findMany: {
            args: Prisma.CompanyUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          create: {
            args: Prisma.CompanyUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          createMany: {
            args: Prisma.CompanyUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          delete: {
            args: Prisma.CompanyUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          update: {
            args: Prisma.CompanyUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          deleteMany: {
            args: Prisma.CompanyUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          aggregate: {
            args: Prisma.CompanyUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyUser>
          }
          groupBy: {
            args: Prisma.CompanyUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyUserCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyUserCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      FiscalYear: {
        payload: Prisma.$FiscalYearPayload<ExtArgs>
        fields: Prisma.FiscalYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FiscalYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiscalYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          findFirst: {
            args: Prisma.FiscalYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiscalYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          findMany: {
            args: Prisma.FiscalYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>[]
          }
          create: {
            args: Prisma.FiscalYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          createMany: {
            args: Prisma.FiscalYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FiscalYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>[]
          }
          delete: {
            args: Prisma.FiscalYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          update: {
            args: Prisma.FiscalYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          deleteMany: {
            args: Prisma.FiscalYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FiscalYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FiscalYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          aggregate: {
            args: Prisma.FiscalYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiscalYear>
          }
          groupBy: {
            args: Prisma.FiscalYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<FiscalYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiscalYearCountArgs<ExtArgs>
            result: $Utils.Optional<FiscalYearCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      JournalLine: {
        payload: Prisma.$JournalLinePayload<ExtArgs>
        fields: Prisma.JournalLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findFirst: {
            args: Prisma.JournalLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findMany: {
            args: Prisma.JournalLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          create: {
            args: Prisma.JournalLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          createMany: {
            args: Prisma.JournalLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          delete: {
            args: Prisma.JournalLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          update: {
            args: Prisma.JournalLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          deleteMany: {
            args: Prisma.JournalLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          aggregate: {
            args: Prisma.JournalLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalLine>
          }
          groupBy: {
            args: Prisma.JournalLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalLineCountArgs<ExtArgs>
            result: $Utils.Optional<JournalLineCountAggregateOutputType> | number
          }
        }
      }
      InvoiceSeries: {
        payload: Prisma.$InvoiceSeriesPayload<ExtArgs>
        fields: Prisma.InvoiceSeriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceSeriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceSeriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>
          }
          findFirst: {
            args: Prisma.InvoiceSeriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceSeriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>
          }
          findMany: {
            args: Prisma.InvoiceSeriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>[]
          }
          create: {
            args: Prisma.InvoiceSeriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>
          }
          createMany: {
            args: Prisma.InvoiceSeriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceSeriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>[]
          }
          delete: {
            args: Prisma.InvoiceSeriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>
          }
          update: {
            args: Prisma.InvoiceSeriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceSeriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceSeriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceSeriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSeriesPayload>
          }
          aggregate: {
            args: Prisma.InvoiceSeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceSeries>
          }
          groupBy: {
            args: Prisma.InvoiceSeriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceSeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceSeriesCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceSeriesCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLine: {
        payload: Prisma.$InvoiceLinePayload<ExtArgs>
        fields: Prisma.InvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          update: {
            args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLine>
          }
          groupBy: {
            args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      InvoiceTax: {
        payload: Prisma.$InvoiceTaxPayload<ExtArgs>
        fields: Prisma.InvoiceTaxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceTaxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceTaxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>
          }
          findFirst: {
            args: Prisma.InvoiceTaxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceTaxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>
          }
          findMany: {
            args: Prisma.InvoiceTaxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>[]
          }
          create: {
            args: Prisma.InvoiceTaxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>
          }
          createMany: {
            args: Prisma.InvoiceTaxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceTaxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>[]
          }
          delete: {
            args: Prisma.InvoiceTaxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>
          }
          update: {
            args: Prisma.InvoiceTaxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceTaxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceTaxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceTaxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceTaxPayload>
          }
          aggregate: {
            args: Prisma.InvoiceTaxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceTax>
          }
          groupBy: {
            args: Prisma.InvoiceTaxGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceTaxGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceTaxCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceTaxCountAggregateOutputType> | number
          }
        }
      }
      CryptoAsset: {
        payload: Prisma.$CryptoAssetPayload<ExtArgs>
        fields: Prisma.CryptoAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>
          }
          findFirst: {
            args: Prisma.CryptoAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>
          }
          findMany: {
            args: Prisma.CryptoAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>[]
          }
          create: {
            args: Prisma.CryptoAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>
          }
          createMany: {
            args: Prisma.CryptoAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>[]
          }
          delete: {
            args: Prisma.CryptoAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>
          }
          update: {
            args: Prisma.CryptoAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>
          }
          deleteMany: {
            args: Prisma.CryptoAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CryptoAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoAssetPayload>
          }
          aggregate: {
            args: Prisma.CryptoAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoAsset>
          }
          groupBy: {
            args: Prisma.CryptoAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoAssetCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoAssetCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      ExchangeAccount: {
        payload: Prisma.$ExchangeAccountPayload<ExtArgs>
        fields: Prisma.ExchangeAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangeAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangeAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>
          }
          findFirst: {
            args: Prisma.ExchangeAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangeAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>
          }
          findMany: {
            args: Prisma.ExchangeAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>[]
          }
          create: {
            args: Prisma.ExchangeAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>
          }
          createMany: {
            args: Prisma.ExchangeAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangeAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>[]
          }
          delete: {
            args: Prisma.ExchangeAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>
          }
          update: {
            args: Prisma.ExchangeAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>
          }
          deleteMany: {
            args: Prisma.ExchangeAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangeAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExchangeAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeAccountPayload>
          }
          aggregate: {
            args: Prisma.ExchangeAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangeAccount>
          }
          groupBy: {
            args: Prisma.ExchangeAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangeAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangeAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangeAccountCountAggregateOutputType> | number
          }
        }
      }
      CryptoTransaction: {
        payload: Prisma.$CryptoTransactionPayload<ExtArgs>
        fields: Prisma.CryptoTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>
          }
          findFirst: {
            args: Prisma.CryptoTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>
          }
          findMany: {
            args: Prisma.CryptoTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>[]
          }
          create: {
            args: Prisma.CryptoTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>
          }
          createMany: {
            args: Prisma.CryptoTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>[]
          }
          delete: {
            args: Prisma.CryptoTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>
          }
          update: {
            args: Prisma.CryptoTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CryptoTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CryptoTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTransactionPayload>
          }
          aggregate: {
            args: Prisma.CryptoTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoTransaction>
          }
          groupBy: {
            args: Prisma.CryptoTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoTransactionCountAggregateOutputType> | number
          }
        }
      }
      CryptoLot: {
        payload: Prisma.$CryptoLotPayload<ExtArgs>
        fields: Prisma.CryptoLotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoLotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoLotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>
          }
          findFirst: {
            args: Prisma.CryptoLotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoLotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>
          }
          findMany: {
            args: Prisma.CryptoLotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>[]
          }
          create: {
            args: Prisma.CryptoLotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>
          }
          createMany: {
            args: Prisma.CryptoLotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoLotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>[]
          }
          delete: {
            args: Prisma.CryptoLotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>
          }
          update: {
            args: Prisma.CryptoLotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>
          }
          deleteMany: {
            args: Prisma.CryptoLotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoLotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CryptoLotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoLotPayload>
          }
          aggregate: {
            args: Prisma.CryptoLotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoLot>
          }
          groupBy: {
            args: Prisma.CryptoLotGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoLotGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoLotCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoLotCountAggregateOutputType> | number
          }
        }
      }
      PriceHistory: {
        payload: Prisma.$PriceHistoryPayload<ExtArgs>
        fields: Prisma.PriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          createMany: {
            args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.PriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          update: {
            args: Prisma.PriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceHistory>
          }
          groupBy: {
            args: Prisma.PriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      VerifactuRecord: {
        payload: Prisma.$VerifactuRecordPayload<ExtArgs>
        fields: Prisma.VerifactuRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerifactuRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerifactuRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>
          }
          findFirst: {
            args: Prisma.VerifactuRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerifactuRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>
          }
          findMany: {
            args: Prisma.VerifactuRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>[]
          }
          create: {
            args: Prisma.VerifactuRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>
          }
          createMany: {
            args: Prisma.VerifactuRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerifactuRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>[]
          }
          delete: {
            args: Prisma.VerifactuRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>
          }
          update: {
            args: Prisma.VerifactuRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>
          }
          deleteMany: {
            args: Prisma.VerifactuRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerifactuRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerifactuRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerifactuRecordPayload>
          }
          aggregate: {
            args: Prisma.VerifactuRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerifactuRecord>
          }
          groupBy: {
            args: Prisma.VerifactuRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerifactuRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerifactuRecordCountArgs<ExtArgs>
            result: $Utils.Optional<VerifactuRecordCountAggregateOutputType> | number
          }
        }
      }
      AiConversation: {
        payload: Prisma.$AiConversationPayload<ExtArgs>
        fields: Prisma.AiConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          findFirst: {
            args: Prisma.AiConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          findMany: {
            args: Prisma.AiConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
          }
          create: {
            args: Prisma.AiConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          createMany: {
            args: Prisma.AiConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
          }
          delete: {
            args: Prisma.AiConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          update: {
            args: Prisma.AiConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          deleteMany: {
            args: Prisma.AiConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiConversationPayload>
          }
          aggregate: {
            args: Prisma.AiConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiConversation>
          }
          groupBy: {
            args: Prisma.AiConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiConversationCountArgs<ExtArgs>
            result: $Utils.Optional<AiConversationCountAggregateOutputType> | number
          }
        }
      }
      AiMessage: {
        payload: Prisma.$AiMessagePayload<ExtArgs>
        fields: Prisma.AiMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          findFirst: {
            args: Prisma.AiMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          findMany: {
            args: Prisma.AiMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>[]
          }
          create: {
            args: Prisma.AiMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          createMany: {
            args: Prisma.AiMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>[]
          }
          delete: {
            args: Prisma.AiMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          update: {
            args: Prisma.AiMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          deleteMany: {
            args: Prisma.AiMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiMessagePayload>
          }
          aggregate: {
            args: Prisma.AiMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiMessage>
          }
          groupBy: {
            args: Prisma.AiMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AiMessageCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      CompanyInvitation: {
        payload: Prisma.$CompanyInvitationPayload<ExtArgs>
        fields: Prisma.CompanyInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          findFirst: {
            args: Prisma.CompanyInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          findMany: {
            args: Prisma.CompanyInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>[]
          }
          create: {
            args: Prisma.CompanyInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          createMany: {
            args: Prisma.CompanyInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>[]
          }
          delete: {
            args: Prisma.CompanyInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          update: {
            args: Prisma.CompanyInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          deleteMany: {
            args: Prisma.CompanyInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvitationPayload>
          }
          aggregate: {
            args: Prisma.CompanyInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyInvitation>
          }
          groupBy: {
            args: Prisma.CompanyInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyInvitationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      OAuthApp: {
        payload: Prisma.$OAuthAppPayload<ExtArgs>
        fields: Prisma.OAuthAppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthAppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthAppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>
          }
          findFirst: {
            args: Prisma.OAuthAppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthAppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>
          }
          findMany: {
            args: Prisma.OAuthAppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>[]
          }
          create: {
            args: Prisma.OAuthAppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>
          }
          createMany: {
            args: Prisma.OAuthAppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthAppCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>[]
          }
          delete: {
            args: Prisma.OAuthAppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>
          }
          update: {
            args: Prisma.OAuthAppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>
          }
          deleteMany: {
            args: Prisma.OAuthAppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthAppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthAppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAppPayload>
          }
          aggregate: {
            args: Prisma.OAuthAppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthApp>
          }
          groupBy: {
            args: Prisma.OAuthAppGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthAppGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthAppCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthAppCountAggregateOutputType> | number
          }
        }
      }
      OAuthToken: {
        payload: Prisma.$OAuthTokenPayload<ExtArgs>
        fields: Prisma.OAuthTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          findFirst: {
            args: Prisma.OAuthTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          findMany: {
            args: Prisma.OAuthTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>[]
          }
          create: {
            args: Prisma.OAuthTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          createMany: {
            args: Prisma.OAuthTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>[]
          }
          delete: {
            args: Prisma.OAuthTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          update: {
            args: Prisma.OAuthTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          deleteMany: {
            args: Prisma.OAuthTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthTokenPayload>
          }
          aggregate: {
            args: Prisma.OAuthTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthToken>
          }
          groupBy: {
            args: Prisma.OAuthTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthTokenCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthTokenCountAggregateOutputType> | number
          }
        }
      }
      ApiUsage: {
        payload: Prisma.$ApiUsagePayload<ExtArgs>
        fields: Prisma.ApiUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>
          }
          findFirst: {
            args: Prisma.ApiUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>
          }
          findMany: {
            args: Prisma.ApiUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>[]
          }
          create: {
            args: Prisma.ApiUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>
          }
          createMany: {
            args: Prisma.ApiUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>[]
          }
          delete: {
            args: Prisma.ApiUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>
          }
          update: {
            args: Prisma.ApiUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>
          }
          deleteMany: {
            args: Prisma.ApiUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>
          }
          aggregate: {
            args: Prisma.ApiUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiUsage>
          }
          groupBy: {
            args: Prisma.ApiUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiUsageCountArgs<ExtArgs>
            result: $Utils.Optional<ApiUsageCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      UserOnboarding: {
        payload: Prisma.$UserOnboardingPayload<ExtArgs>
        fields: Prisma.UserOnboardingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOnboardingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOnboardingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          findFirst: {
            args: Prisma.UserOnboardingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOnboardingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          findMany: {
            args: Prisma.UserOnboardingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>[]
          }
          create: {
            args: Prisma.UserOnboardingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          createMany: {
            args: Prisma.UserOnboardingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserOnboardingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>[]
          }
          delete: {
            args: Prisma.UserOnboardingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          update: {
            args: Prisma.UserOnboardingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          deleteMany: {
            args: Prisma.UserOnboardingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserOnboardingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserOnboardingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          aggregate: {
            args: Prisma.UserOnboardingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserOnboarding>
          }
          groupBy: {
            args: Prisma.UserOnboardingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserOnboardingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOnboardingCountArgs<ExtArgs>
            result: $Utils.Optional<UserOnboardingCountAggregateOutputType> | number
          }
        }
      }
      WebhookSubscription: {
        payload: Prisma.$WebhookSubscriptionPayload<ExtArgs>
        fields: Prisma.WebhookSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.WebhookSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          findMany: {
            args: Prisma.WebhookSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>[]
          }
          create: {
            args: Prisma.WebhookSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          createMany: {
            args: Prisma.WebhookSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.WebhookSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          update: {
            args: Prisma.WebhookSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.WebhookSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.WebhookSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookSubscription>
          }
          groupBy: {
            args: Prisma.WebhookSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    companyUsers: number
    aiConversations: number
    invitationsSent: number
    invitationsAccepted: number
    auditLogs: number
    analyticsEvents: number
    oauthAppsCreated: number
    oauthTokens: number
    apiUsage: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyUsers?: boolean | UserCountOutputTypeCountCompanyUsersArgs
    aiConversations?: boolean | UserCountOutputTypeCountAiConversationsArgs
    invitationsSent?: boolean | UserCountOutputTypeCountInvitationsSentArgs
    invitationsAccepted?: boolean | UserCountOutputTypeCountInvitationsAcceptedArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    analyticsEvents?: boolean | UserCountOutputTypeCountAnalyticsEventsArgs
    oauthAppsCreated?: boolean | UserCountOutputTypeCountOauthAppsCreatedArgs
    oauthTokens?: boolean | UserCountOutputTypeCountOauthTokensArgs
    apiUsage?: boolean | UserCountOutputTypeCountApiUsageArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompanyUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsAcceptedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthAppsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAppWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    companyUsers: number
    fiscalYears: number
    accounts: number
    journalEntries: number
    invoices: number
    invoiceSeries: number
    contacts: number
    wallets: number
    cryptoAssets: number
    cryptoLots: number
    exchangeAccounts: number
    aiConversations: number
    documents: number
    invitations: number
    auditLogs: number
    webhookSubscriptions: number
    analyticsEvents: number
    oauthApps: number
    oauthTokens: number
    apiUsage: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyUsers?: boolean | CompanyCountOutputTypeCountCompanyUsersArgs
    fiscalYears?: boolean | CompanyCountOutputTypeCountFiscalYearsArgs
    accounts?: boolean | CompanyCountOutputTypeCountAccountsArgs
    journalEntries?: boolean | CompanyCountOutputTypeCountJournalEntriesArgs
    invoices?: boolean | CompanyCountOutputTypeCountInvoicesArgs
    invoiceSeries?: boolean | CompanyCountOutputTypeCountInvoiceSeriesArgs
    contacts?: boolean | CompanyCountOutputTypeCountContactsArgs
    wallets?: boolean | CompanyCountOutputTypeCountWalletsArgs
    cryptoAssets?: boolean | CompanyCountOutputTypeCountCryptoAssetsArgs
    cryptoLots?: boolean | CompanyCountOutputTypeCountCryptoLotsArgs
    exchangeAccounts?: boolean | CompanyCountOutputTypeCountExchangeAccountsArgs
    aiConversations?: boolean | CompanyCountOutputTypeCountAiConversationsArgs
    documents?: boolean | CompanyCountOutputTypeCountDocumentsArgs
    invitations?: boolean | CompanyCountOutputTypeCountInvitationsArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
    webhookSubscriptions?: boolean | CompanyCountOutputTypeCountWebhookSubscriptionsArgs
    analyticsEvents?: boolean | CompanyCountOutputTypeCountAnalyticsEventsArgs
    oauthApps?: boolean | CompanyCountOutputTypeCountOauthAppsArgs
    oauthTokens?: boolean | CompanyCountOutputTypeCountOauthTokensArgs
    apiUsage?: boolean | CompanyCountOutputTypeCountApiUsageArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanyUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFiscalYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalYearWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvoiceSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceSeriesWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCryptoAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoAssetWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCryptoLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoLotWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountExchangeAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeAccountWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAiConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiConversationWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvitationWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWebhookSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookSubscriptionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAnalyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountOauthAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAppWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountOauthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthTokenWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountApiUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    invoices: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | ContactCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type FiscalYearCountOutputType
   */

  export type FiscalYearCountOutputType = {
    journalEntries: number
  }

  export type FiscalYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalEntries?: boolean | FiscalYearCountOutputTypeCountJournalEntriesArgs
  }

  // Custom InputTypes
  /**
   * FiscalYearCountOutputType without action
   */
  export type FiscalYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYearCountOutputType
     */
    select?: FiscalYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FiscalYearCountOutputType without action
   */
  export type FiscalYearCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    journalLines: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalLines?: boolean | AccountCountOutputTypeCountJournalLinesArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }


  /**
   * Count Type JournalEntryCountOutputType
   */

  export type JournalEntryCountOutputType = {
    lines: number
  }

  export type JournalEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | JournalEntryCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntryCountOutputType
     */
    select?: JournalEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }


  /**
   * Count Type InvoiceSeriesCountOutputType
   */

  export type InvoiceSeriesCountOutputType = {
    invoices: number
  }

  export type InvoiceSeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | InvoiceSeriesCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceSeriesCountOutputType without action
   */
  export type InvoiceSeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeriesCountOutputType
     */
    select?: InvoiceSeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceSeriesCountOutputType without action
   */
  export type InvoiceSeriesCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lines: number
    taxes: number
    verifactuRecords: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | InvoiceCountOutputTypeCountLinesArgs
    taxes?: boolean | InvoiceCountOutputTypeCountTaxesArgs
    verifactuRecords?: boolean | InvoiceCountOutputTypeCountVerifactuRecordsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTaxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceTaxWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountVerifactuRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerifactuRecordWhereInput
  }


  /**
   * Count Type CryptoAssetCountOutputType
   */

  export type CryptoAssetCountOutputType = {
    accounts: number
    lots: number
  }

  export type CryptoAssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | CryptoAssetCountOutputTypeCountAccountsArgs
    lots?: boolean | CryptoAssetCountOutputTypeCountLotsArgs
  }

  // Custom InputTypes
  /**
   * CryptoAssetCountOutputType without action
   */
  export type CryptoAssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAssetCountOutputType
     */
    select?: CryptoAssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CryptoAssetCountOutputType without action
   */
  export type CryptoAssetCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * CryptoAssetCountOutputType without action
   */
  export type CryptoAssetCountOutputTypeCountLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoLotWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    transactions: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoTransactionWhereInput
  }


  /**
   * Count Type AiConversationCountOutputType
   */

  export type AiConversationCountOutputType = {
    messages: number
  }

  export type AiConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AiConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * AiConversationCountOutputType without action
   */
  export type AiConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversationCountOutputType
     */
    select?: AiConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiConversationCountOutputType without action
   */
  export type AiConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMessageWhereInput
  }


  /**
   * Count Type OAuthAppCountOutputType
   */

  export type OAuthAppCountOutputType = {
    tokens: number
    apiUsage: number
  }

  export type OAuthAppCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | OAuthAppCountOutputTypeCountTokensArgs
    apiUsage?: boolean | OAuthAppCountOutputTypeCountApiUsageArgs
  }

  // Custom InputTypes
  /**
   * OAuthAppCountOutputType without action
   */
  export type OAuthAppCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAppCountOutputType
     */
    select?: OAuthAppCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OAuthAppCountOutputType without action
   */
  export type OAuthAppCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthTokenWhereInput
  }

  /**
   * OAuthAppCountOutputType without action
   */
  export type OAuthAppCountOutputTypeCountApiUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type WebhookSubscriptionCountOutputType
   */

  export type WebhookSubscriptionCountOutputType = {
    deliveries: number
  }

  export type WebhookSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookSubscriptionCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookSubscriptionCountOutputType without action
   */
  export type WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscriptionCountOutputType
     */
    select?: WebhookSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookSubscriptionCountOutputType without action
   */
  export type WebhookSubscriptionCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    twoFactorBackupCodes: string | null
    ssoProvider: string | null
    ssoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    twoFactorBackupCodes: string | null
    ssoProvider: string | null
    ssoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    avatarUrl: number
    isActive: number
    lastLoginAt: number
    twoFactorEnabled: number
    twoFactorSecret: number
    twoFactorBackupCodes: number
    ssoProvider: number
    ssoId: number
    ssoMetadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    isActive?: true
    lastLoginAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    ssoProvider?: true
    ssoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    isActive?: true
    lastLoginAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    ssoProvider?: true
    ssoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    isActive?: true
    lastLoginAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    ssoProvider?: true
    ssoId?: true
    ssoMetadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl: string | null
    isActive: boolean
    lastLoginAt: Date | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    twoFactorBackupCodes: string | null
    ssoProvider: string | null
    ssoId: string | null
    ssoMetadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyUsers?: boolean | User$companyUsersArgs<ExtArgs>
    aiConversations?: boolean | User$aiConversationsArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    invitationsAccepted?: boolean | User$invitationsAcceptedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    onboarding?: boolean | User$onboardingArgs<ExtArgs>
    analyticsEvents?: boolean | User$analyticsEventsArgs<ExtArgs>
    oauthAppsCreated?: boolean | User$oauthAppsCreatedArgs<ExtArgs>
    oauthTokens?: boolean | User$oauthTokensArgs<ExtArgs>
    apiUsage?: boolean | User$apiUsageArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    ssoProvider?: boolean
    ssoId?: boolean
    ssoMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyUsers?: boolean | User$companyUsersArgs<ExtArgs>
    aiConversations?: boolean | User$aiConversationsArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    invitationsAccepted?: boolean | User$invitationsAcceptedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    onboarding?: boolean | User$onboardingArgs<ExtArgs>
    analyticsEvents?: boolean | User$analyticsEventsArgs<ExtArgs>
    oauthAppsCreated?: boolean | User$oauthAppsCreatedArgs<ExtArgs>
    oauthTokens?: boolean | User$oauthTokensArgs<ExtArgs>
    apiUsage?: boolean | User$apiUsageArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      companyUsers: Prisma.$CompanyUserPayload<ExtArgs>[]
      aiConversations: Prisma.$AiConversationPayload<ExtArgs>[]
      invitationsSent: Prisma.$CompanyInvitationPayload<ExtArgs>[]
      invitationsAccepted: Prisma.$CompanyInvitationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      onboarding: Prisma.$UserOnboardingPayload<ExtArgs> | null
      analyticsEvents: Prisma.$AnalyticsEventPayload<ExtArgs>[]
      oauthAppsCreated: Prisma.$OAuthAppPayload<ExtArgs>[]
      oauthTokens: Prisma.$OAuthTokenPayload<ExtArgs>[]
      apiUsage: Prisma.$ApiUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      avatarUrl: string | null
      isActive: boolean
      lastLoginAt: Date | null
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      twoFactorBackupCodes: string | null
      ssoProvider: string | null
      ssoId: string | null
      ssoMetadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companyUsers<T extends User$companyUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$companyUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany"> | Null>
    aiConversations<T extends User$aiConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findMany"> | Null>
    invitationsSent<T extends User$invitationsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    invitationsAccepted<T extends User$invitationsAcceptedArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsAcceptedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    onboarding<T extends User$onboardingArgs<ExtArgs> = {}>(args?: Subset<T, User$onboardingArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    analyticsEvents<T extends User$analyticsEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany"> | Null>
    oauthAppsCreated<T extends User$oauthAppsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthAppsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findMany"> | Null>
    oauthTokens<T extends User$oauthTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findMany"> | Null>
    apiUsage<T extends User$apiUsageArgs<ExtArgs> = {}>(args?: Subset<T, User$apiUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorBackupCodes: FieldRef<"User", 'String'>
    readonly ssoProvider: FieldRef<"User", 'String'>
    readonly ssoId: FieldRef<"User", 'String'>
    readonly ssoMetadata: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.companyUsers
   */
  export type User$companyUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * User.aiConversations
   */
  export type User$aiConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    where?: AiConversationWhereInput
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    cursor?: AiConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * User.invitationsSent
   */
  export type User$invitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    where?: CompanyInvitationWhereInput
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    cursor?: CompanyInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * User.invitationsAccepted
   */
  export type User$invitationsAcceptedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    where?: CompanyInvitationWhereInput
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    cursor?: CompanyInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.onboarding
   */
  export type User$onboardingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    where?: UserOnboardingWhereInput
  }

  /**
   * User.analyticsEvents
   */
  export type User$analyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    cursor?: AnalyticsEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * User.oauthAppsCreated
   */
  export type User$oauthAppsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    where?: OAuthAppWhereInput
    orderBy?: OAuthAppOrderByWithRelationInput | OAuthAppOrderByWithRelationInput[]
    cursor?: OAuthAppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAppScalarFieldEnum | OAuthAppScalarFieldEnum[]
  }

  /**
   * User.oauthTokens
   */
  export type User$oauthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    where?: OAuthTokenWhereInput
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    cursor?: OAuthTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * User.apiUsage
   */
  export type User$apiUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    where?: ApiUsageWhereInput
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[]
    cursor?: ApiUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    fiscalYearStart: number | null
  }

  export type CompanySumAggregateOutputType = {
    fiscalYearStart: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    taxId: string | null
    taxIdType: $Enums.TaxIdType | null
    address: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    country: string | null
    region: string | null
    phone: string | null
    email: string | null
    website: string | null
    currency: string | null
    fiscalYearStart: number | null
    logo: string | null
    verifactuEnabled: boolean | null
    verifactuId: string | null
    verifactuLastHash: string | null
    defaultCryptoClassification: $Enums.CryptoClassification | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    taxId: string | null
    taxIdType: $Enums.TaxIdType | null
    address: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    country: string | null
    region: string | null
    phone: string | null
    email: string | null
    website: string | null
    currency: string | null
    fiscalYearStart: number | null
    logo: string | null
    verifactuEnabled: boolean | null
    verifactuId: string | null
    verifactuLastHash: string | null
    defaultCryptoClassification: $Enums.CryptoClassification | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    legalName: number
    taxId: number
    taxIdType: number
    address: number
    city: number
    province: number
    postalCode: number
    country: number
    region: number
    phone: number
    email: number
    website: number
    currency: number
    fiscalYearStart: number
    logo: number
    verifactuEnabled: number
    verifactuId: number
    verifactuLastHash: number
    defaultCryptoClassification: number
    settings: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    fiscalYearStart?: true
  }

  export type CompanySumAggregateInputType = {
    fiscalYearStart?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    taxId?: true
    taxIdType?: true
    address?: true
    city?: true
    province?: true
    postalCode?: true
    country?: true
    region?: true
    phone?: true
    email?: true
    website?: true
    currency?: true
    fiscalYearStart?: true
    logo?: true
    verifactuEnabled?: true
    verifactuId?: true
    verifactuLastHash?: true
    defaultCryptoClassification?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    taxId?: true
    taxIdType?: true
    address?: true
    city?: true
    province?: true
    postalCode?: true
    country?: true
    region?: true
    phone?: true
    email?: true
    website?: true
    currency?: true
    fiscalYearStart?: true
    logo?: true
    verifactuEnabled?: true
    verifactuId?: true
    verifactuLastHash?: true
    defaultCryptoClassification?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    taxId?: true
    taxIdType?: true
    address?: true
    city?: true
    province?: true
    postalCode?: true
    country?: true
    region?: true
    phone?: true
    email?: true
    website?: true
    currency?: true
    fiscalYearStart?: true
    logo?: true
    verifactuEnabled?: true
    verifactuId?: true
    verifactuLastHash?: true
    defaultCryptoClassification?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    legalName: string | null
    taxId: string
    taxIdType: $Enums.TaxIdType
    address: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    country: string
    region: string
    phone: string | null
    email: string | null
    website: string | null
    currency: string
    fiscalYearStart: number
    logo: string | null
    verifactuEnabled: boolean
    verifactuId: string | null
    verifactuLastHash: string | null
    defaultCryptoClassification: $Enums.CryptoClassification
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    taxId?: boolean
    taxIdType?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    country?: boolean
    region?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    currency?: boolean
    fiscalYearStart?: boolean
    logo?: boolean
    verifactuEnabled?: boolean
    verifactuId?: boolean
    verifactuLastHash?: boolean
    defaultCryptoClassification?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    companyUsers?: boolean | Company$companyUsersArgs<ExtArgs>
    fiscalYears?: boolean | Company$fiscalYearsArgs<ExtArgs>
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    journalEntries?: boolean | Company$journalEntriesArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    invoiceSeries?: boolean | Company$invoiceSeriesArgs<ExtArgs>
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    wallets?: boolean | Company$walletsArgs<ExtArgs>
    cryptoAssets?: boolean | Company$cryptoAssetsArgs<ExtArgs>
    cryptoLots?: boolean | Company$cryptoLotsArgs<ExtArgs>
    exchangeAccounts?: boolean | Company$exchangeAccountsArgs<ExtArgs>
    aiConversations?: boolean | Company$aiConversationsArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    invitations?: boolean | Company$invitationsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    webhookSubscriptions?: boolean | Company$webhookSubscriptionsArgs<ExtArgs>
    analyticsEvents?: boolean | Company$analyticsEventsArgs<ExtArgs>
    oauthApps?: boolean | Company$oauthAppsArgs<ExtArgs>
    oauthTokens?: boolean | Company$oauthTokensArgs<ExtArgs>
    apiUsage?: boolean | Company$apiUsageArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    taxId?: boolean
    taxIdType?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    country?: boolean
    region?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    currency?: boolean
    fiscalYearStart?: boolean
    logo?: boolean
    verifactuEnabled?: boolean
    verifactuId?: boolean
    verifactuLastHash?: boolean
    defaultCryptoClassification?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    legalName?: boolean
    taxId?: boolean
    taxIdType?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    country?: boolean
    region?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    currency?: boolean
    fiscalYearStart?: boolean
    logo?: boolean
    verifactuEnabled?: boolean
    verifactuId?: boolean
    verifactuLastHash?: boolean
    defaultCryptoClassification?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyUsers?: boolean | Company$companyUsersArgs<ExtArgs>
    fiscalYears?: boolean | Company$fiscalYearsArgs<ExtArgs>
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    journalEntries?: boolean | Company$journalEntriesArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    invoiceSeries?: boolean | Company$invoiceSeriesArgs<ExtArgs>
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    wallets?: boolean | Company$walletsArgs<ExtArgs>
    cryptoAssets?: boolean | Company$cryptoAssetsArgs<ExtArgs>
    cryptoLots?: boolean | Company$cryptoLotsArgs<ExtArgs>
    exchangeAccounts?: boolean | Company$exchangeAccountsArgs<ExtArgs>
    aiConversations?: boolean | Company$aiConversationsArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    invitations?: boolean | Company$invitationsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    webhookSubscriptions?: boolean | Company$webhookSubscriptionsArgs<ExtArgs>
    analyticsEvents?: boolean | Company$analyticsEventsArgs<ExtArgs>
    oauthApps?: boolean | Company$oauthAppsArgs<ExtArgs>
    oauthTokens?: boolean | Company$oauthTokensArgs<ExtArgs>
    apiUsage?: boolean | Company$apiUsageArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      companyUsers: Prisma.$CompanyUserPayload<ExtArgs>[]
      fiscalYears: Prisma.$FiscalYearPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      invoiceSeries: Prisma.$InvoiceSeriesPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      wallets: Prisma.$WalletPayload<ExtArgs>[]
      cryptoAssets: Prisma.$CryptoAssetPayload<ExtArgs>[]
      cryptoLots: Prisma.$CryptoLotPayload<ExtArgs>[]
      exchangeAccounts: Prisma.$ExchangeAccountPayload<ExtArgs>[]
      aiConversations: Prisma.$AiConversationPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      invitations: Prisma.$CompanyInvitationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      webhookSubscriptions: Prisma.$WebhookSubscriptionPayload<ExtArgs>[]
      analyticsEvents: Prisma.$AnalyticsEventPayload<ExtArgs>[]
      oauthApps: Prisma.$OAuthAppPayload<ExtArgs>[]
      oauthTokens: Prisma.$OAuthTokenPayload<ExtArgs>[]
      apiUsage: Prisma.$ApiUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      legalName: string | null
      taxId: string
      taxIdType: $Enums.TaxIdType
      address: string | null
      city: string | null
      province: string | null
      postalCode: string | null
      country: string
      region: string
      phone: string | null
      email: string | null
      website: string | null
      currency: string
      fiscalYearStart: number
      logo: string | null
      verifactuEnabled: boolean
      verifactuId: string | null
      verifactuLastHash: string | null
      defaultCryptoClassification: $Enums.CryptoClassification
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companyUsers<T extends Company$companyUsersArgs<ExtArgs> = {}>(args?: Subset<T, Company$companyUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany"> | Null>
    fiscalYears<T extends Company$fiscalYearsArgs<ExtArgs> = {}>(args?: Subset<T, Company$fiscalYearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends Company$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Company$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    journalEntries<T extends Company$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Company$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    invoiceSeries<T extends Company$invoiceSeriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$invoiceSeriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends Company$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Company$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    wallets<T extends Company$walletsArgs<ExtArgs> = {}>(args?: Subset<T, Company$walletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany"> | Null>
    cryptoAssets<T extends Company$cryptoAssetsArgs<ExtArgs> = {}>(args?: Subset<T, Company$cryptoAssetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findMany"> | Null>
    cryptoLots<T extends Company$cryptoLotsArgs<ExtArgs> = {}>(args?: Subset<T, Company$cryptoLotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "findMany"> | Null>
    exchangeAccounts<T extends Company$exchangeAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Company$exchangeAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "findMany"> | Null>
    aiConversations<T extends Company$aiConversationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$aiConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Company$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends Company$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    webhookSubscriptions<T extends Company$webhookSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$webhookSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    analyticsEvents<T extends Company$analyticsEventsArgs<ExtArgs> = {}>(args?: Subset<T, Company$analyticsEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany"> | Null>
    oauthApps<T extends Company$oauthAppsArgs<ExtArgs> = {}>(args?: Subset<T, Company$oauthAppsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findMany"> | Null>
    oauthTokens<T extends Company$oauthTokensArgs<ExtArgs> = {}>(args?: Subset<T, Company$oauthTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findMany"> | Null>
    apiUsage<T extends Company$apiUsageArgs<ExtArgs> = {}>(args?: Subset<T, Company$apiUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly legalName: FieldRef<"Company", 'String'>
    readonly taxId: FieldRef<"Company", 'String'>
    readonly taxIdType: FieldRef<"Company", 'TaxIdType'>
    readonly address: FieldRef<"Company", 'String'>
    readonly city: FieldRef<"Company", 'String'>
    readonly province: FieldRef<"Company", 'String'>
    readonly postalCode: FieldRef<"Company", 'String'>
    readonly country: FieldRef<"Company", 'String'>
    readonly region: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly currency: FieldRef<"Company", 'String'>
    readonly fiscalYearStart: FieldRef<"Company", 'Int'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly verifactuEnabled: FieldRef<"Company", 'Boolean'>
    readonly verifactuId: FieldRef<"Company", 'String'>
    readonly verifactuLastHash: FieldRef<"Company", 'String'>
    readonly defaultCryptoClassification: FieldRef<"Company", 'CryptoClassification'>
    readonly settings: FieldRef<"Company", 'Json'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly deletedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.companyUsers
   */
  export type Company$companyUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * Company.fiscalYears
   */
  export type Company$fiscalYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    where?: FiscalYearWhereInput
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    cursor?: FiscalYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * Company.accounts
   */
  export type Company$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Company.journalEntries
   */
  export type Company$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * Company.invoices
   */
  export type Company$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Company.invoiceSeries
   */
  export type Company$invoiceSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    where?: InvoiceSeriesWhereInput
    orderBy?: InvoiceSeriesOrderByWithRelationInput | InvoiceSeriesOrderByWithRelationInput[]
    cursor?: InvoiceSeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceSeriesScalarFieldEnum | InvoiceSeriesScalarFieldEnum[]
  }

  /**
   * Company.contacts
   */
  export type Company$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Company.wallets
   */
  export type Company$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    cursor?: WalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Company.cryptoAssets
   */
  export type Company$cryptoAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    where?: CryptoAssetWhereInput
    orderBy?: CryptoAssetOrderByWithRelationInput | CryptoAssetOrderByWithRelationInput[]
    cursor?: CryptoAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoAssetScalarFieldEnum | CryptoAssetScalarFieldEnum[]
  }

  /**
   * Company.cryptoLots
   */
  export type Company$cryptoLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    where?: CryptoLotWhereInput
    orderBy?: CryptoLotOrderByWithRelationInput | CryptoLotOrderByWithRelationInput[]
    cursor?: CryptoLotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoLotScalarFieldEnum | CryptoLotScalarFieldEnum[]
  }

  /**
   * Company.exchangeAccounts
   */
  export type Company$exchangeAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    where?: ExchangeAccountWhereInput
    orderBy?: ExchangeAccountOrderByWithRelationInput | ExchangeAccountOrderByWithRelationInput[]
    cursor?: ExchangeAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeAccountScalarFieldEnum | ExchangeAccountScalarFieldEnum[]
  }

  /**
   * Company.aiConversations
   */
  export type Company$aiConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    where?: AiConversationWhereInput
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    cursor?: AiConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * Company.documents
   */
  export type Company$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Company.invitations
   */
  export type Company$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    where?: CompanyInvitationWhereInput
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    cursor?: CompanyInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company.webhookSubscriptions
   */
  export type Company$webhookSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    where?: WebhookSubscriptionWhereInput
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    cursor?: WebhookSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * Company.analyticsEvents
   */
  export type Company$analyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    cursor?: AnalyticsEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * Company.oauthApps
   */
  export type Company$oauthAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    where?: OAuthAppWhereInput
    orderBy?: OAuthAppOrderByWithRelationInput | OAuthAppOrderByWithRelationInput[]
    cursor?: OAuthAppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAppScalarFieldEnum | OAuthAppScalarFieldEnum[]
  }

  /**
   * Company.oauthTokens
   */
  export type Company$oauthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    where?: OAuthTokenWhereInput
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    cursor?: OAuthTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * Company.apiUsage
   */
  export type Company$apiUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    where?: ApiUsageWhereInput
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[]
    cursor?: ApiUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyUser
   */

  export type AggregateCompanyUser = {
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  export type CompanyUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    role: $Enums.UserRole | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type CompanyUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    role: $Enums.UserRole | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type CompanyUserCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    role: number
    isDefault: number
    createdAt: number
    _all: number
  }


  export type CompanyUserMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    isDefault?: true
    createdAt?: true
  }

  export type CompanyUserMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    isDefault?: true
    createdAt?: true
  }

  export type CompanyUserCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    isDefault?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUser to aggregate.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyUsers
    **/
    _count?: true | CompanyUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyUserMaxAggregateInputType
  }

  export type GetCompanyUserAggregateType<T extends CompanyUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyUser[P]>
      : GetScalarType<T[P], AggregateCompanyUser[P]>
  }




  export type CompanyUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithAggregationInput | CompanyUserOrderByWithAggregationInput[]
    by: CompanyUserScalarFieldEnum[] | CompanyUserScalarFieldEnum
    having?: CompanyUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyUserCountAggregateInputType | true
    _min?: CompanyUserMinAggregateInputType
    _max?: CompanyUserMaxAggregateInputType
  }

  export type CompanyUserGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    role: $Enums.UserRole
    isDefault: boolean
    createdAt: Date
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  type GetCompanyUserGroupByPayload<T extends CompanyUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
        }
      >
    >


  export type CompanyUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    isDefault?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    isDefault?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    isDefault?: boolean
    createdAt?: boolean
  }

  export type CompanyUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      role: $Enums.UserRole
      isDefault: boolean
      createdAt: Date
    }, ExtArgs["result"]["companyUser"]>
    composites: {}
  }

  type CompanyUserGetPayload<S extends boolean | null | undefined | CompanyUserDefaultArgs> = $Result.GetResult<Prisma.$CompanyUserPayload, S>

  type CompanyUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyUserCountAggregateInputType | true
    }

  export interface CompanyUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyUser'], meta: { name: 'CompanyUser' } }
    /**
     * Find zero or one CompanyUser that matches the filter.
     * @param {CompanyUserFindUniqueArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyUserFindUniqueArgs>(args: SelectSubset<T, CompanyUserFindUniqueArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyUserFindUniqueOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyUserFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyUserFindFirstArgs>(args?: SelectSubset<T, CompanyUserFindFirstArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyUserFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany()
     * 
     * // Get first 10 CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyUserWithIdOnly = await prisma.companyUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyUserFindManyArgs>(args?: SelectSubset<T, CompanyUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyUser.
     * @param {CompanyUserCreateArgs} args - Arguments to create a CompanyUser.
     * @example
     * // Create one CompanyUser
     * const CompanyUser = await prisma.companyUser.create({
     *   data: {
     *     // ... data to create a CompanyUser
     *   }
     * })
     * 
     */
    create<T extends CompanyUserCreateArgs>(args: SelectSubset<T, CompanyUserCreateArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyUsers.
     * @param {CompanyUserCreateManyArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyUserCreateManyArgs>(args?: SelectSubset<T, CompanyUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyUsers and returns the data saved in the database.
     * @param {CompanyUserCreateManyAndReturnArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyUsers and only return the `id`
     * const companyUserWithIdOnly = await prisma.companyUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyUserCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyUser.
     * @param {CompanyUserDeleteArgs} args - Arguments to delete one CompanyUser.
     * @example
     * // Delete one CompanyUser
     * const CompanyUser = await prisma.companyUser.delete({
     *   where: {
     *     // ... filter to delete one CompanyUser
     *   }
     * })
     * 
     */
    delete<T extends CompanyUserDeleteArgs>(args: SelectSubset<T, CompanyUserDeleteArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyUser.
     * @param {CompanyUserUpdateArgs} args - Arguments to update one CompanyUser.
     * @example
     * // Update one CompanyUser
     * const companyUser = await prisma.companyUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUserUpdateArgs>(args: SelectSubset<T, CompanyUserUpdateArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyUsers.
     * @param {CompanyUserDeleteManyArgs} args - Arguments to filter CompanyUsers to delete.
     * @example
     * // Delete a few CompanyUsers
     * const { count } = await prisma.companyUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyUserDeleteManyArgs>(args?: SelectSubset<T, CompanyUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyUsers
     * const companyUser = await prisma.companyUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUserUpdateManyArgs>(args: SelectSubset<T, CompanyUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyUser.
     * @param {CompanyUserUpsertArgs} args - Arguments to update or create a CompanyUser.
     * @example
     * // Update or create a CompanyUser
     * const companyUser = await prisma.companyUser.upsert({
     *   create: {
     *     // ... data to create a CompanyUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyUser we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUserUpsertArgs>(args: SelectSubset<T, CompanyUserUpsertArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserCountArgs} args - Arguments to filter CompanyUsers to count.
     * @example
     * // Count the number of CompanyUsers
     * const count = await prisma.companyUser.count({
     *   where: {
     *     // ... the filter for the CompanyUsers we want to count
     *   }
     * })
    **/
    count<T extends CompanyUserCountArgs>(
      args?: Subset<T, CompanyUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyUserAggregateArgs>(args: Subset<T, CompanyUserAggregateArgs>): Prisma.PrismaPromise<GetCompanyUserAggregateType<T>>

    /**
     * Group by CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyUserGroupByArgs['orderBy'] }
        : { orderBy?: CompanyUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyUser model
   */
  readonly fields: CompanyUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyUser model
   */ 
  interface CompanyUserFieldRefs {
    readonly id: FieldRef<"CompanyUser", 'String'>
    readonly userId: FieldRef<"CompanyUser", 'String'>
    readonly companyId: FieldRef<"CompanyUser", 'String'>
    readonly role: FieldRef<"CompanyUser", 'UserRole'>
    readonly isDefault: FieldRef<"CompanyUser", 'Boolean'>
    readonly createdAt: FieldRef<"CompanyUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyUser findUnique
   */
  export type CompanyUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findUniqueOrThrow
   */
  export type CompanyUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findFirst
   */
  export type CompanyUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findFirstOrThrow
   */
  export type CompanyUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findMany
   */
  export type CompanyUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUsers to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser create
   */
  export type CompanyUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyUser.
     */
    data: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
  }

  /**
   * CompanyUser createMany
   */
  export type CompanyUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyUser createManyAndReturn
   */
  export type CompanyUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyUser update
   */
  export type CompanyUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyUser.
     */
    data: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
    /**
     * Choose, which CompanyUser to update.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser updateMany
   */
  export type CompanyUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyUsers.
     */
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyInput>
    /**
     * Filter which CompanyUsers to update
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser upsert
   */
  export type CompanyUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyUser to update in case it exists.
     */
    where: CompanyUserWhereUniqueInput
    /**
     * In case the CompanyUser found by the `where` argument doesn't exist, create a new CompanyUser with this data.
     */
    create: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
    /**
     * In case the CompanyUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
  }

  /**
   * CompanyUser delete
   */
  export type CompanyUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter which CompanyUser to delete.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser deleteMany
   */
  export type CompanyUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUsers to delete
     */
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyUser without action
   */
  export type CompanyUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    type: $Enums.ContactType | null
    name: string | null
    legalName: string | null
    taxId: string | null
    taxIdType: $Enums.TaxIdType | null
    address: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    type: $Enums.ContactType | null
    name: string | null
    legalName: string | null
    taxId: string | null
    taxIdType: $Enums.TaxIdType | null
    address: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    companyId: number
    type: number
    name: number
    legalName: number
    taxId: number
    taxIdType: number
    address: number
    city: number
    postalCode: number
    country: number
    phone: number
    email: number
    website: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    name?: true
    legalName?: true
    taxId?: true
    taxIdType?: true
    address?: true
    city?: true
    postalCode?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    name?: true
    legalName?: true
    taxId?: true
    taxIdType?: true
    address?: true
    city?: true
    postalCode?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    name?: true
    legalName?: true
    taxId?: true
    taxIdType?: true
    address?: true
    city?: true
    postalCode?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    companyId: string
    type: $Enums.ContactType
    name: string
    legalName: string | null
    taxId: string | null
    taxIdType: $Enums.TaxIdType | null
    address: string | null
    city: string | null
    postalCode: string | null
    country: string
    phone: string | null
    email: string | null
    website: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    name?: boolean
    legalName?: boolean
    taxId?: boolean
    taxIdType?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    invoices?: boolean | Contact$invoicesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    name?: boolean
    legalName?: boolean
    taxId?: boolean
    taxIdType?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    companyId?: boolean
    type?: boolean
    name?: boolean
    legalName?: boolean
    taxId?: boolean
    taxIdType?: boolean
    address?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    invoices?: boolean | Contact$invoicesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      type: $Enums.ContactType
      name: string
      legalName: string | null
      taxId: string | null
      taxIdType: $Enums.TaxIdType | null
      address: string | null
      city: string | null
      postalCode: string | null
      country: string
      phone: string | null
      email: string | null
      website: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends Contact$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly companyId: FieldRef<"Contact", 'String'>
    readonly type: FieldRef<"Contact", 'ContactType'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly legalName: FieldRef<"Contact", 'String'>
    readonly taxId: FieldRef<"Contact", 'String'>
    readonly taxIdType: FieldRef<"Contact", 'TaxIdType'>
    readonly address: FieldRef<"Contact", 'String'>
    readonly city: FieldRef<"Contact", 'String'>
    readonly postalCode: FieldRef<"Contact", 'String'>
    readonly country: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly website: FieldRef<"Contact", 'String'>
    readonly notes: FieldRef<"Contact", 'String'>
    readonly isActive: FieldRef<"Contact", 'Boolean'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.invoices
   */
  export type Contact$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model FiscalYear
   */

  export type AggregateFiscalYear = {
    _count: FiscalYearCountAggregateOutputType | null
    _min: FiscalYearMinAggregateOutputType | null
    _max: FiscalYearMaxAggregateOutputType | null
  }

  export type FiscalYearMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isClosed: boolean | null
    closedAt: Date | null
    closedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalYearMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isClosed: boolean | null
    closedAt: Date | null
    closedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalYearCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    startDate: number
    endDate: number
    isClosed: number
    closedAt: number
    closedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FiscalYearMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    startDate?: true
    endDate?: true
    isClosed?: true
    closedAt?: true
    closedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalYearMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    startDate?: true
    endDate?: true
    isClosed?: true
    closedAt?: true
    closedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalYearCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    startDate?: true
    endDate?: true
    isClosed?: true
    closedAt?: true
    closedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FiscalYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalYear to aggregate.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FiscalYears
    **/
    _count?: true | FiscalYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiscalYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiscalYearMaxAggregateInputType
  }

  export type GetFiscalYearAggregateType<T extends FiscalYearAggregateArgs> = {
        [P in keyof T & keyof AggregateFiscalYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiscalYear[P]>
      : GetScalarType<T[P], AggregateFiscalYear[P]>
  }




  export type FiscalYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalYearWhereInput
    orderBy?: FiscalYearOrderByWithAggregationInput | FiscalYearOrderByWithAggregationInput[]
    by: FiscalYearScalarFieldEnum[] | FiscalYearScalarFieldEnum
    having?: FiscalYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiscalYearCountAggregateInputType | true
    _min?: FiscalYearMinAggregateInputType
    _max?: FiscalYearMaxAggregateInputType
  }

  export type FiscalYearGroupByOutputType = {
    id: string
    companyId: string
    name: string
    startDate: Date
    endDate: Date
    isClosed: boolean
    closedAt: Date | null
    closedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: FiscalYearCountAggregateOutputType | null
    _min: FiscalYearMinAggregateOutputType | null
    _max: FiscalYearMaxAggregateOutputType | null
  }

  type GetFiscalYearGroupByPayload<T extends FiscalYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiscalYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiscalYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiscalYearGroupByOutputType[P]>
            : GetScalarType<T[P], FiscalYearGroupByOutputType[P]>
        }
      >
    >


  export type FiscalYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    journalEntries?: boolean | FiscalYear$journalEntriesArgs<ExtArgs>
    _count?: boolean | FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalYear"]>

  export type FiscalYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalYear"]>

  export type FiscalYearSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FiscalYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    journalEntries?: boolean | FiscalYear$journalEntriesArgs<ExtArgs>
    _count?: boolean | FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FiscalYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $FiscalYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FiscalYear"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      startDate: Date
      endDate: Date
      isClosed: boolean
      closedAt: Date | null
      closedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fiscalYear"]>
    composites: {}
  }

  type FiscalYearGetPayload<S extends boolean | null | undefined | FiscalYearDefaultArgs> = $Result.GetResult<Prisma.$FiscalYearPayload, S>

  type FiscalYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FiscalYearFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FiscalYearCountAggregateInputType | true
    }

  export interface FiscalYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FiscalYear'], meta: { name: 'FiscalYear' } }
    /**
     * Find zero or one FiscalYear that matches the filter.
     * @param {FiscalYearFindUniqueArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FiscalYearFindUniqueArgs>(args: SelectSubset<T, FiscalYearFindUniqueArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FiscalYear that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FiscalYearFindUniqueOrThrowArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FiscalYearFindUniqueOrThrowArgs>(args: SelectSubset<T, FiscalYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FiscalYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindFirstArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FiscalYearFindFirstArgs>(args?: SelectSubset<T, FiscalYearFindFirstArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FiscalYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindFirstOrThrowArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FiscalYearFindFirstOrThrowArgs>(args?: SelectSubset<T, FiscalYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FiscalYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiscalYears
     * const fiscalYears = await prisma.fiscalYear.findMany()
     * 
     * // Get first 10 FiscalYears
     * const fiscalYears = await prisma.fiscalYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiscalYearWithIdOnly = await prisma.fiscalYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FiscalYearFindManyArgs>(args?: SelectSubset<T, FiscalYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FiscalYear.
     * @param {FiscalYearCreateArgs} args - Arguments to create a FiscalYear.
     * @example
     * // Create one FiscalYear
     * const FiscalYear = await prisma.fiscalYear.create({
     *   data: {
     *     // ... data to create a FiscalYear
     *   }
     * })
     * 
     */
    create<T extends FiscalYearCreateArgs>(args: SelectSubset<T, FiscalYearCreateArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FiscalYears.
     * @param {FiscalYearCreateManyArgs} args - Arguments to create many FiscalYears.
     * @example
     * // Create many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FiscalYearCreateManyArgs>(args?: SelectSubset<T, FiscalYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FiscalYears and returns the data saved in the database.
     * @param {FiscalYearCreateManyAndReturnArgs} args - Arguments to create many FiscalYears.
     * @example
     * // Create many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FiscalYears and only return the `id`
     * const fiscalYearWithIdOnly = await prisma.fiscalYear.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FiscalYearCreateManyAndReturnArgs>(args?: SelectSubset<T, FiscalYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FiscalYear.
     * @param {FiscalYearDeleteArgs} args - Arguments to delete one FiscalYear.
     * @example
     * // Delete one FiscalYear
     * const FiscalYear = await prisma.fiscalYear.delete({
     *   where: {
     *     // ... filter to delete one FiscalYear
     *   }
     * })
     * 
     */
    delete<T extends FiscalYearDeleteArgs>(args: SelectSubset<T, FiscalYearDeleteArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FiscalYear.
     * @param {FiscalYearUpdateArgs} args - Arguments to update one FiscalYear.
     * @example
     * // Update one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FiscalYearUpdateArgs>(args: SelectSubset<T, FiscalYearUpdateArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FiscalYears.
     * @param {FiscalYearDeleteManyArgs} args - Arguments to filter FiscalYears to delete.
     * @example
     * // Delete a few FiscalYears
     * const { count } = await prisma.fiscalYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FiscalYearDeleteManyArgs>(args?: SelectSubset<T, FiscalYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FiscalYearUpdateManyArgs>(args: SelectSubset<T, FiscalYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FiscalYear.
     * @param {FiscalYearUpsertArgs} args - Arguments to update or create a FiscalYear.
     * @example
     * // Update or create a FiscalYear
     * const fiscalYear = await prisma.fiscalYear.upsert({
     *   create: {
     *     // ... data to create a FiscalYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiscalYear we want to update
     *   }
     * })
     */
    upsert<T extends FiscalYearUpsertArgs>(args: SelectSubset<T, FiscalYearUpsertArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FiscalYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearCountArgs} args - Arguments to filter FiscalYears to count.
     * @example
     * // Count the number of FiscalYears
     * const count = await prisma.fiscalYear.count({
     *   where: {
     *     // ... the filter for the FiscalYears we want to count
     *   }
     * })
    **/
    count<T extends FiscalYearCountArgs>(
      args?: Subset<T, FiscalYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiscalYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiscalYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiscalYearAggregateArgs>(args: Subset<T, FiscalYearAggregateArgs>): Prisma.PrismaPromise<GetFiscalYearAggregateType<T>>

    /**
     * Group by FiscalYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiscalYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiscalYearGroupByArgs['orderBy'] }
        : { orderBy?: FiscalYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiscalYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiscalYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FiscalYear model
   */
  readonly fields: FiscalYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FiscalYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FiscalYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    journalEntries<T extends FiscalYear$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, FiscalYear$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FiscalYear model
   */ 
  interface FiscalYearFieldRefs {
    readonly id: FieldRef<"FiscalYear", 'String'>
    readonly companyId: FieldRef<"FiscalYear", 'String'>
    readonly name: FieldRef<"FiscalYear", 'String'>
    readonly startDate: FieldRef<"FiscalYear", 'DateTime'>
    readonly endDate: FieldRef<"FiscalYear", 'DateTime'>
    readonly isClosed: FieldRef<"FiscalYear", 'Boolean'>
    readonly closedAt: FieldRef<"FiscalYear", 'DateTime'>
    readonly closedBy: FieldRef<"FiscalYear", 'String'>
    readonly notes: FieldRef<"FiscalYear", 'String'>
    readonly createdAt: FieldRef<"FiscalYear", 'DateTime'>
    readonly updatedAt: FieldRef<"FiscalYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FiscalYear findUnique
   */
  export type FiscalYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear findUniqueOrThrow
   */
  export type FiscalYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear findFirst
   */
  export type FiscalYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalYears.
     */
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear findFirstOrThrow
   */
  export type FiscalYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalYears.
     */
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear findMany
   */
  export type FiscalYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYears to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear create
   */
  export type FiscalYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The data needed to create a FiscalYear.
     */
    data: XOR<FiscalYearCreateInput, FiscalYearUncheckedCreateInput>
  }

  /**
   * FiscalYear createMany
   */
  export type FiscalYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FiscalYears.
     */
    data: FiscalYearCreateManyInput | FiscalYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FiscalYear createManyAndReturn
   */
  export type FiscalYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FiscalYears.
     */
    data: FiscalYearCreateManyInput | FiscalYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FiscalYear update
   */
  export type FiscalYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The data needed to update a FiscalYear.
     */
    data: XOR<FiscalYearUpdateInput, FiscalYearUncheckedUpdateInput>
    /**
     * Choose, which FiscalYear to update.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear updateMany
   */
  export type FiscalYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FiscalYears.
     */
    data: XOR<FiscalYearUpdateManyMutationInput, FiscalYearUncheckedUpdateManyInput>
    /**
     * Filter which FiscalYears to update
     */
    where?: FiscalYearWhereInput
  }

  /**
   * FiscalYear upsert
   */
  export type FiscalYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The filter to search for the FiscalYear to update in case it exists.
     */
    where: FiscalYearWhereUniqueInput
    /**
     * In case the FiscalYear found by the `where` argument doesn't exist, create a new FiscalYear with this data.
     */
    create: XOR<FiscalYearCreateInput, FiscalYearUncheckedCreateInput>
    /**
     * In case the FiscalYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiscalYearUpdateInput, FiscalYearUncheckedUpdateInput>
  }

  /**
   * FiscalYear delete
   */
  export type FiscalYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter which FiscalYear to delete.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear deleteMany
   */
  export type FiscalYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalYears to delete
     */
    where?: FiscalYearWhereInput
  }

  /**
   * FiscalYear.journalEntries
   */
  export type FiscalYear$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * FiscalYear without action
   */
  export type FiscalYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    type: $Enums.AccountType | null
    parentCode: string | null
    description: string | null
    isCrypto: boolean | null
    cryptoAssetId: string | null
    isActive: boolean | null
    isSystem: boolean | null
    allowDirectPosting: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    type: $Enums.AccountType | null
    parentCode: string | null
    description: string | null
    isCrypto: boolean | null
    cryptoAssetId: string | null
    isActive: boolean | null
    isSystem: boolean | null
    allowDirectPosting: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    companyId: number
    code: number
    name: number
    type: number
    parentCode: number
    description: number
    isCrypto: number
    cryptoAssetId: number
    isActive: number
    isSystem: number
    allowDirectPosting: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    type?: true
    parentCode?: true
    description?: true
    isCrypto?: true
    cryptoAssetId?: true
    isActive?: true
    isSystem?: true
    allowDirectPosting?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    type?: true
    parentCode?: true
    description?: true
    isCrypto?: true
    cryptoAssetId?: true
    isActive?: true
    isSystem?: true
    allowDirectPosting?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    type?: true
    parentCode?: true
    description?: true
    isCrypto?: true
    cryptoAssetId?: true
    isActive?: true
    isSystem?: true
    allowDirectPosting?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    companyId: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode: string | null
    description: string | null
    isCrypto: boolean
    cryptoAssetId: string | null
    isActive: boolean
    isSystem: boolean
    allowDirectPosting: boolean
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    parentCode?: boolean
    description?: boolean
    isCrypto?: boolean
    cryptoAssetId?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | Account$cryptoAssetArgs<ExtArgs>
    journalLines?: boolean | Account$journalLinesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    parentCode?: boolean
    description?: boolean
    isCrypto?: boolean
    cryptoAssetId?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | Account$cryptoAssetArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    parentCode?: boolean
    description?: boolean
    isCrypto?: boolean
    cryptoAssetId?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | Account$cryptoAssetArgs<ExtArgs>
    journalLines?: boolean | Account$journalLinesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | Account$cryptoAssetArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      cryptoAsset: Prisma.$CryptoAssetPayload<ExtArgs> | null
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      code: string
      name: string
      type: $Enums.AccountType
      parentCode: string | null
      description: string | null
      isCrypto: boolean
      cryptoAssetId: string | null
      isActive: boolean
      isSystem: boolean
      allowDirectPosting: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cryptoAsset<T extends Account$cryptoAssetArgs<ExtArgs> = {}>(args?: Subset<T, Account$cryptoAssetArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    journalLines<T extends Account$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, Account$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly companyId: FieldRef<"Account", 'String'>
    readonly code: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'AccountType'>
    readonly parentCode: FieldRef<"Account", 'String'>
    readonly description: FieldRef<"Account", 'String'>
    readonly isCrypto: FieldRef<"Account", 'Boolean'>
    readonly cryptoAssetId: FieldRef<"Account", 'String'>
    readonly isActive: FieldRef<"Account", 'Boolean'>
    readonly isSystem: FieldRef<"Account", 'Boolean'>
    readonly allowDirectPosting: FieldRef<"Account", 'Boolean'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.cryptoAsset
   */
  export type Account$cryptoAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    where?: CryptoAssetWhereInput
  }

  /**
   * Account.journalLines
   */
  export type Account$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryAvgAggregateOutputType = {
    number: number | null
  }

  export type JournalEntrySumAggregateOutputType = {
    number: number | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    fiscalYearId: string | null
    number: number | null
    date: Date | null
    description: string | null
    reference: string | null
    referenceType: $Enums.ReferenceType | null
    sourceType: $Enums.SourceType | null
    sourceId: string | null
    status: $Enums.JournalStatus | null
    isPosted: boolean | null
    postedAt: Date | null
    postedBy: string | null
    isReversal: boolean | null
    reversalOf: string | null
    reversedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    fiscalYearId: string | null
    number: number | null
    date: Date | null
    description: string | null
    reference: string | null
    referenceType: $Enums.ReferenceType | null
    sourceType: $Enums.SourceType | null
    sourceId: string | null
    status: $Enums.JournalStatus | null
    isPosted: boolean | null
    postedAt: Date | null
    postedBy: string | null
    isReversal: boolean | null
    reversalOf: string | null
    reversedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    companyId: number
    fiscalYearId: number
    number: number
    date: number
    description: number
    reference: number
    referenceType: number
    sourceType: number
    sourceId: number
    status: number
    isPosted: number
    postedAt: number
    postedBy: number
    isReversal: number
    reversalOf: number
    reversedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalEntryAvgAggregateInputType = {
    number?: true
  }

  export type JournalEntrySumAggregateInputType = {
    number?: true
  }

  export type JournalEntryMinAggregateInputType = {
    id?: true
    companyId?: true
    fiscalYearId?: true
    number?: true
    date?: true
    description?: true
    reference?: true
    referenceType?: true
    sourceType?: true
    sourceId?: true
    status?: true
    isPosted?: true
    postedAt?: true
    postedBy?: true
    isReversal?: true
    reversalOf?: true
    reversedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    companyId?: true
    fiscalYearId?: true
    number?: true
    date?: true
    description?: true
    reference?: true
    referenceType?: true
    sourceType?: true
    sourceId?: true
    status?: true
    isPosted?: true
    postedAt?: true
    postedBy?: true
    isReversal?: true
    reversalOf?: true
    reversedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    companyId?: true
    fiscalYearId?: true
    number?: true
    date?: true
    description?: true
    reference?: true
    referenceType?: true
    sourceType?: true
    sourceId?: true
    status?: true
    isPosted?: true
    postedAt?: true
    postedBy?: true
    isReversal?: true
    reversalOf?: true
    reversedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _avg?: JournalEntryAvgAggregateInputType
    _sum?: JournalEntrySumAggregateInputType
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: string
    companyId: string
    fiscalYearId: string
    number: number
    date: Date
    description: string
    reference: string | null
    referenceType: $Enums.ReferenceType | null
    sourceType: $Enums.SourceType | null
    sourceId: string | null
    status: $Enums.JournalStatus
    isPosted: boolean
    postedAt: Date | null
    postedBy: string | null
    isReversal: boolean
    reversalOf: string | null
    reversedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    fiscalYearId?: boolean
    number?: boolean
    date?: boolean
    description?: boolean
    reference?: boolean
    referenceType?: boolean
    sourceType?: boolean
    sourceId?: boolean
    status?: boolean
    isPosted?: boolean
    postedAt?: boolean
    postedBy?: boolean
    isReversal?: boolean
    reversalOf?: boolean
    reversedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    fiscalYearId?: boolean
    number?: boolean
    date?: boolean
    description?: boolean
    reference?: boolean
    referenceType?: boolean
    sourceType?: boolean
    sourceId?: boolean
    status?: boolean
    isPosted?: boolean
    postedAt?: boolean
    postedBy?: boolean
    isReversal?: boolean
    reversalOf?: boolean
    reversedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    companyId?: boolean
    fiscalYearId?: boolean
    number?: boolean
    date?: boolean
    description?: boolean
    reference?: boolean
    referenceType?: boolean
    sourceType?: boolean
    sourceId?: boolean
    status?: boolean
    isPosted?: boolean
    postedAt?: boolean
    postedBy?: boolean
    isReversal?: boolean
    reversalOf?: boolean
    reversedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
  }

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      fiscalYear: Prisma.$FiscalYearPayload<ExtArgs>
      lines: Prisma.$JournalLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      fiscalYearId: string
      number: number
      date: Date
      description: string
      reference: string | null
      referenceType: $Enums.ReferenceType | null
      sourceType: $Enums.SourceType | null
      sourceId: string | null
      status: $Enums.JournalStatus
      isPosted: boolean
      postedAt: Date | null
      postedBy: string | null
      isReversal: boolean
      reversalOf: string | null
      reversedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fiscalYear<T extends FiscalYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FiscalYearDefaultArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lines<T extends JournalEntry$linesArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */ 
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'String'>
    readonly companyId: FieldRef<"JournalEntry", 'String'>
    readonly fiscalYearId: FieldRef<"JournalEntry", 'String'>
    readonly number: FieldRef<"JournalEntry", 'Int'>
    readonly date: FieldRef<"JournalEntry", 'DateTime'>
    readonly description: FieldRef<"JournalEntry", 'String'>
    readonly reference: FieldRef<"JournalEntry", 'String'>
    readonly referenceType: FieldRef<"JournalEntry", 'ReferenceType'>
    readonly sourceType: FieldRef<"JournalEntry", 'SourceType'>
    readonly sourceId: FieldRef<"JournalEntry", 'String'>
    readonly status: FieldRef<"JournalEntry", 'JournalStatus'>
    readonly isPosted: FieldRef<"JournalEntry", 'Boolean'>
    readonly postedAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly postedBy: FieldRef<"JournalEntry", 'String'>
    readonly isReversal: FieldRef<"JournalEntry", 'Boolean'>
    readonly reversalOf: FieldRef<"JournalEntry", 'String'>
    readonly reversedBy: FieldRef<"JournalEntry", 'String'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
  }

  /**
   * JournalEntry.lines
   */
  export type JournalEntry$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model JournalLine
   */

  export type AggregateJournalLine = {
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  export type JournalLineAvgAggregateOutputType = {
    lineNumber: number | null
    debit: Decimal | null
    credit: Decimal | null
    cryptoAmount: Decimal | null
    cryptoPrice: Decimal | null
  }

  export type JournalLineSumAggregateOutputType = {
    lineNumber: number | null
    debit: Decimal | null
    credit: Decimal | null
    cryptoAmount: Decimal | null
    cryptoPrice: Decimal | null
  }

  export type JournalLineMinAggregateOutputType = {
    id: string | null
    journalEntryId: string | null
    accountId: string | null
    lineNumber: number | null
    description: string | null
    debit: Decimal | null
    credit: Decimal | null
    cryptoAmount: Decimal | null
    cryptoAsset: string | null
    cryptoPrice: Decimal | null
    costCenter: string | null
    project: string | null
    createdAt: Date | null
  }

  export type JournalLineMaxAggregateOutputType = {
    id: string | null
    journalEntryId: string | null
    accountId: string | null
    lineNumber: number | null
    description: string | null
    debit: Decimal | null
    credit: Decimal | null
    cryptoAmount: Decimal | null
    cryptoAsset: string | null
    cryptoPrice: Decimal | null
    costCenter: string | null
    project: string | null
    createdAt: Date | null
  }

  export type JournalLineCountAggregateOutputType = {
    id: number
    journalEntryId: number
    accountId: number
    lineNumber: number
    description: number
    debit: number
    credit: number
    cryptoAmount: number
    cryptoAsset: number
    cryptoPrice: number
    costCenter: number
    project: number
    createdAt: number
    _all: number
  }


  export type JournalLineAvgAggregateInputType = {
    lineNumber?: true
    debit?: true
    credit?: true
    cryptoAmount?: true
    cryptoPrice?: true
  }

  export type JournalLineSumAggregateInputType = {
    lineNumber?: true
    debit?: true
    credit?: true
    cryptoAmount?: true
    cryptoPrice?: true
  }

  export type JournalLineMinAggregateInputType = {
    id?: true
    journalEntryId?: true
    accountId?: true
    lineNumber?: true
    description?: true
    debit?: true
    credit?: true
    cryptoAmount?: true
    cryptoAsset?: true
    cryptoPrice?: true
    costCenter?: true
    project?: true
    createdAt?: true
  }

  export type JournalLineMaxAggregateInputType = {
    id?: true
    journalEntryId?: true
    accountId?: true
    lineNumber?: true
    description?: true
    debit?: true
    credit?: true
    cryptoAmount?: true
    cryptoAsset?: true
    cryptoPrice?: true
    costCenter?: true
    project?: true
    createdAt?: true
  }

  export type JournalLineCountAggregateInputType = {
    id?: true
    journalEntryId?: true
    accountId?: true
    lineNumber?: true
    description?: true
    debit?: true
    credit?: true
    cryptoAmount?: true
    cryptoAsset?: true
    cryptoPrice?: true
    costCenter?: true
    project?: true
    createdAt?: true
    _all?: true
  }

  export type JournalLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLine to aggregate.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalLines
    **/
    _count?: true | JournalLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalLineMaxAggregateInputType
  }

  export type GetJournalLineAggregateType<T extends JournalLineAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalLine[P]>
      : GetScalarType<T[P], AggregateJournalLine[P]>
  }




  export type JournalLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithAggregationInput | JournalLineOrderByWithAggregationInput[]
    by: JournalLineScalarFieldEnum[] | JournalLineScalarFieldEnum
    having?: JournalLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalLineCountAggregateInputType | true
    _avg?: JournalLineAvgAggregateInputType
    _sum?: JournalLineSumAggregateInputType
    _min?: JournalLineMinAggregateInputType
    _max?: JournalLineMaxAggregateInputType
  }

  export type JournalLineGroupByOutputType = {
    id: string
    journalEntryId: string
    accountId: string
    lineNumber: number
    description: string | null
    debit: Decimal
    credit: Decimal
    cryptoAmount: Decimal | null
    cryptoAsset: string | null
    cryptoPrice: Decimal | null
    costCenter: string | null
    project: string | null
    createdAt: Date
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  type GetJournalLineGroupByPayload<T extends JournalLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
            : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
        }
      >
    >


  export type JournalLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalEntryId?: boolean
    accountId?: boolean
    lineNumber?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    cryptoAmount?: boolean
    cryptoAsset?: boolean
    cryptoPrice?: boolean
    costCenter?: boolean
    project?: boolean
    createdAt?: boolean
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalEntryId?: boolean
    accountId?: boolean
    lineNumber?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    cryptoAmount?: boolean
    cryptoAsset?: boolean
    cryptoPrice?: boolean
    costCenter?: boolean
    project?: boolean
    createdAt?: boolean
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectScalar = {
    id?: boolean
    journalEntryId?: boolean
    accountId?: boolean
    lineNumber?: boolean
    description?: boolean
    debit?: boolean
    credit?: boolean
    cryptoAmount?: boolean
    cryptoAsset?: boolean
    cryptoPrice?: boolean
    costCenter?: boolean
    project?: boolean
    createdAt?: boolean
  }

  export type JournalLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type JournalLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $JournalLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalLine"
    objects: {
      journalEntry: Prisma.$JournalEntryPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalEntryId: string
      accountId: string
      lineNumber: number
      description: string | null
      debit: Prisma.Decimal
      credit: Prisma.Decimal
      cryptoAmount: Prisma.Decimal | null
      cryptoAsset: string | null
      cryptoPrice: Prisma.Decimal | null
      costCenter: string | null
      project: string | null
      createdAt: Date
    }, ExtArgs["result"]["journalLine"]>
    composites: {}
  }

  type JournalLineGetPayload<S extends boolean | null | undefined | JournalLineDefaultArgs> = $Result.GetResult<Prisma.$JournalLinePayload, S>

  type JournalLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalLineCountAggregateInputType | true
    }

  export interface JournalLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalLine'], meta: { name: 'JournalLine' } }
    /**
     * Find zero or one JournalLine that matches the filter.
     * @param {JournalLineFindUniqueArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalLineFindUniqueArgs>(args: SelectSubset<T, JournalLineFindUniqueArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JournalLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalLineFindUniqueOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalLineFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JournalLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalLineFindFirstArgs>(args?: SelectSubset<T, JournalLineFindFirstArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JournalLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalLineFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JournalLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalLines
     * const journalLines = await prisma.journalLine.findMany()
     * 
     * // Get first 10 JournalLines
     * const journalLines = await prisma.journalLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalLineFindManyArgs>(args?: SelectSubset<T, JournalLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JournalLine.
     * @param {JournalLineCreateArgs} args - Arguments to create a JournalLine.
     * @example
     * // Create one JournalLine
     * const JournalLine = await prisma.journalLine.create({
     *   data: {
     *     // ... data to create a JournalLine
     *   }
     * })
     * 
     */
    create<T extends JournalLineCreateArgs>(args: SelectSubset<T, JournalLineCreateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JournalLines.
     * @param {JournalLineCreateManyArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalLineCreateManyArgs>(args?: SelectSubset<T, JournalLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalLines and returns the data saved in the database.
     * @param {JournalLineCreateManyAndReturnArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalLines and only return the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalLineCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JournalLine.
     * @param {JournalLineDeleteArgs} args - Arguments to delete one JournalLine.
     * @example
     * // Delete one JournalLine
     * const JournalLine = await prisma.journalLine.delete({
     *   where: {
     *     // ... filter to delete one JournalLine
     *   }
     * })
     * 
     */
    delete<T extends JournalLineDeleteArgs>(args: SelectSubset<T, JournalLineDeleteArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JournalLine.
     * @param {JournalLineUpdateArgs} args - Arguments to update one JournalLine.
     * @example
     * // Update one JournalLine
     * const journalLine = await prisma.journalLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalLineUpdateArgs>(args: SelectSubset<T, JournalLineUpdateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JournalLines.
     * @param {JournalLineDeleteManyArgs} args - Arguments to filter JournalLines to delete.
     * @example
     * // Delete a few JournalLines
     * const { count } = await prisma.journalLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalLineDeleteManyArgs>(args?: SelectSubset<T, JournalLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalLines
     * const journalLine = await prisma.journalLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalLineUpdateManyArgs>(args: SelectSubset<T, JournalLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalLine.
     * @param {JournalLineUpsertArgs} args - Arguments to update or create a JournalLine.
     * @example
     * // Update or create a JournalLine
     * const journalLine = await prisma.journalLine.upsert({
     *   create: {
     *     // ... data to create a JournalLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalLine we want to update
     *   }
     * })
     */
    upsert<T extends JournalLineUpsertArgs>(args: SelectSubset<T, JournalLineUpsertArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineCountArgs} args - Arguments to filter JournalLines to count.
     * @example
     * // Count the number of JournalLines
     * const count = await prisma.journalLine.count({
     *   where: {
     *     // ... the filter for the JournalLines we want to count
     *   }
     * })
    **/
    count<T extends JournalLineCountArgs>(
      args?: Subset<T, JournalLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalLineAggregateArgs>(args: Subset<T, JournalLineAggregateArgs>): Prisma.PrismaPromise<GetJournalLineAggregateType<T>>

    /**
     * Group by JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalLineGroupByArgs['orderBy'] }
        : { orderBy?: JournalLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalLine model
   */
  readonly fields: JournalLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journalEntry<T extends JournalEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntryDefaultArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalLine model
   */ 
  interface JournalLineFieldRefs {
    readonly id: FieldRef<"JournalLine", 'String'>
    readonly journalEntryId: FieldRef<"JournalLine", 'String'>
    readonly accountId: FieldRef<"JournalLine", 'String'>
    readonly lineNumber: FieldRef<"JournalLine", 'Int'>
    readonly description: FieldRef<"JournalLine", 'String'>
    readonly debit: FieldRef<"JournalLine", 'Decimal'>
    readonly credit: FieldRef<"JournalLine", 'Decimal'>
    readonly cryptoAmount: FieldRef<"JournalLine", 'Decimal'>
    readonly cryptoAsset: FieldRef<"JournalLine", 'String'>
    readonly cryptoPrice: FieldRef<"JournalLine", 'Decimal'>
    readonly costCenter: FieldRef<"JournalLine", 'String'>
    readonly project: FieldRef<"JournalLine", 'String'>
    readonly createdAt: FieldRef<"JournalLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalLine findUnique
   */
  export type JournalLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findUniqueOrThrow
   */
  export type JournalLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findFirst
   */
  export type JournalLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findFirstOrThrow
   */
  export type JournalLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findMany
   */
  export type JournalLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLines to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine create
   */
  export type JournalLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalLine.
     */
    data: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
  }

  /**
   * JournalLine createMany
   */
  export type JournalLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalLine createManyAndReturn
   */
  export type JournalLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLine update
   */
  export type JournalLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalLine.
     */
    data: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
    /**
     * Choose, which JournalLine to update.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine updateMany
   */
  export type JournalLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalLines.
     */
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyInput>
    /**
     * Filter which JournalLines to update
     */
    where?: JournalLineWhereInput
  }

  /**
   * JournalLine upsert
   */
  export type JournalLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalLine to update in case it exists.
     */
    where: JournalLineWhereUniqueInput
    /**
     * In case the JournalLine found by the `where` argument doesn't exist, create a new JournalLine with this data.
     */
    create: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
    /**
     * In case the JournalLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
  }

  /**
   * JournalLine delete
   */
  export type JournalLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter which JournalLine to delete.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine deleteMany
   */
  export type JournalLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLines to delete
     */
    where?: JournalLineWhereInput
  }

  /**
   * JournalLine without action
   */
  export type JournalLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceSeries
   */

  export type AggregateInvoiceSeries = {
    _count: InvoiceSeriesCountAggregateOutputType | null
    _avg: InvoiceSeriesAvgAggregateOutputType | null
    _sum: InvoiceSeriesSumAggregateOutputType | null
    _min: InvoiceSeriesMinAggregateOutputType | null
    _max: InvoiceSeriesMaxAggregateOutputType | null
  }

  export type InvoiceSeriesAvgAggregateOutputType = {
    nextNumber: number | null
    digitCount: number | null
  }

  export type InvoiceSeriesSumAggregateOutputType = {
    nextNumber: number | null
    digitCount: number | null
  }

  export type InvoiceSeriesMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    type: $Enums.InvoiceType | null
    prefix: string | null
    suffix: string | null
    nextNumber: number | null
    digitCount: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceSeriesMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    code: string | null
    name: string | null
    type: $Enums.InvoiceType | null
    prefix: string | null
    suffix: string | null
    nextNumber: number | null
    digitCount: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceSeriesCountAggregateOutputType = {
    id: number
    companyId: number
    code: number
    name: number
    type: number
    prefix: number
    suffix: number
    nextNumber: number
    digitCount: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceSeriesAvgAggregateInputType = {
    nextNumber?: true
    digitCount?: true
  }

  export type InvoiceSeriesSumAggregateInputType = {
    nextNumber?: true
    digitCount?: true
  }

  export type InvoiceSeriesMinAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    type?: true
    prefix?: true
    suffix?: true
    nextNumber?: true
    digitCount?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceSeriesMaxAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    type?: true
    prefix?: true
    suffix?: true
    nextNumber?: true
    digitCount?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceSeriesCountAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    name?: true
    type?: true
    prefix?: true
    suffix?: true
    nextNumber?: true
    digitCount?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceSeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceSeries to aggregate.
     */
    where?: InvoiceSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSeries to fetch.
     */
    orderBy?: InvoiceSeriesOrderByWithRelationInput | InvoiceSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceSeries
    **/
    _count?: true | InvoiceSeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceSeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceSeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceSeriesMaxAggregateInputType
  }

  export type GetInvoiceSeriesAggregateType<T extends InvoiceSeriesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceSeries[P]>
      : GetScalarType<T[P], AggregateInvoiceSeries[P]>
  }




  export type InvoiceSeriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceSeriesWhereInput
    orderBy?: InvoiceSeriesOrderByWithAggregationInput | InvoiceSeriesOrderByWithAggregationInput[]
    by: InvoiceSeriesScalarFieldEnum[] | InvoiceSeriesScalarFieldEnum
    having?: InvoiceSeriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceSeriesCountAggregateInputType | true
    _avg?: InvoiceSeriesAvgAggregateInputType
    _sum?: InvoiceSeriesSumAggregateInputType
    _min?: InvoiceSeriesMinAggregateInputType
    _max?: InvoiceSeriesMaxAggregateInputType
  }

  export type InvoiceSeriesGroupByOutputType = {
    id: string
    companyId: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix: string | null
    suffix: string | null
    nextNumber: number
    digitCount: number
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InvoiceSeriesCountAggregateOutputType | null
    _avg: InvoiceSeriesAvgAggregateOutputType | null
    _sum: InvoiceSeriesSumAggregateOutputType | null
    _min: InvoiceSeriesMinAggregateOutputType | null
    _max: InvoiceSeriesMaxAggregateOutputType | null
  }

  type GetInvoiceSeriesGroupByPayload<T extends InvoiceSeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceSeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceSeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceSeriesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceSeriesGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    prefix?: boolean
    suffix?: boolean
    nextNumber?: boolean
    digitCount?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    invoices?: boolean | InvoiceSeries$invoicesArgs<ExtArgs>
    _count?: boolean | InvoiceSeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSeries"]>

  export type InvoiceSeriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    prefix?: boolean
    suffix?: boolean
    nextNumber?: boolean
    digitCount?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSeries"]>

  export type InvoiceSeriesSelectScalar = {
    id?: boolean
    companyId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    prefix?: boolean
    suffix?: boolean
    nextNumber?: boolean
    digitCount?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceSeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    invoices?: boolean | InvoiceSeries$invoicesArgs<ExtArgs>
    _count?: boolean | InvoiceSeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceSeriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $InvoiceSeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceSeries"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      code: string
      name: string
      type: $Enums.InvoiceType
      prefix: string | null
      suffix: string | null
      nextNumber: number
      digitCount: number
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceSeries"]>
    composites: {}
  }

  type InvoiceSeriesGetPayload<S extends boolean | null | undefined | InvoiceSeriesDefaultArgs> = $Result.GetResult<Prisma.$InvoiceSeriesPayload, S>

  type InvoiceSeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceSeriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceSeriesCountAggregateInputType | true
    }

  export interface InvoiceSeriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceSeries'], meta: { name: 'InvoiceSeries' } }
    /**
     * Find zero or one InvoiceSeries that matches the filter.
     * @param {InvoiceSeriesFindUniqueArgs} args - Arguments to find a InvoiceSeries
     * @example
     * // Get one InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceSeriesFindUniqueArgs>(args: SelectSubset<T, InvoiceSeriesFindUniqueArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceSeries that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceSeriesFindUniqueOrThrowArgs} args - Arguments to find a InvoiceSeries
     * @example
     * // Get one InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceSeriesFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceSeriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceSeries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSeriesFindFirstArgs} args - Arguments to find a InvoiceSeries
     * @example
     * // Get one InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceSeriesFindFirstArgs>(args?: SelectSubset<T, InvoiceSeriesFindFirstArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceSeries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSeriesFindFirstOrThrowArgs} args - Arguments to find a InvoiceSeries
     * @example
     * // Get one InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceSeriesFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceSeriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceSeries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.findMany()
     * 
     * // Get first 10 InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceSeriesWithIdOnly = await prisma.invoiceSeries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceSeriesFindManyArgs>(args?: SelectSubset<T, InvoiceSeriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceSeries.
     * @param {InvoiceSeriesCreateArgs} args - Arguments to create a InvoiceSeries.
     * @example
     * // Create one InvoiceSeries
     * const InvoiceSeries = await prisma.invoiceSeries.create({
     *   data: {
     *     // ... data to create a InvoiceSeries
     *   }
     * })
     * 
     */
    create<T extends InvoiceSeriesCreateArgs>(args: SelectSubset<T, InvoiceSeriesCreateArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceSeries.
     * @param {InvoiceSeriesCreateManyArgs} args - Arguments to create many InvoiceSeries.
     * @example
     * // Create many InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceSeriesCreateManyArgs>(args?: SelectSubset<T, InvoiceSeriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceSeries and returns the data saved in the database.
     * @param {InvoiceSeriesCreateManyAndReturnArgs} args - Arguments to create many InvoiceSeries.
     * @example
     * // Create many InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceSeries and only return the `id`
     * const invoiceSeriesWithIdOnly = await prisma.invoiceSeries.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceSeriesCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceSeriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceSeries.
     * @param {InvoiceSeriesDeleteArgs} args - Arguments to delete one InvoiceSeries.
     * @example
     * // Delete one InvoiceSeries
     * const InvoiceSeries = await prisma.invoiceSeries.delete({
     *   where: {
     *     // ... filter to delete one InvoiceSeries
     *   }
     * })
     * 
     */
    delete<T extends InvoiceSeriesDeleteArgs>(args: SelectSubset<T, InvoiceSeriesDeleteArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceSeries.
     * @param {InvoiceSeriesUpdateArgs} args - Arguments to update one InvoiceSeries.
     * @example
     * // Update one InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceSeriesUpdateArgs>(args: SelectSubset<T, InvoiceSeriesUpdateArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceSeries.
     * @param {InvoiceSeriesDeleteManyArgs} args - Arguments to filter InvoiceSeries to delete.
     * @example
     * // Delete a few InvoiceSeries
     * const { count } = await prisma.invoiceSeries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceSeriesDeleteManyArgs>(args?: SelectSubset<T, InvoiceSeriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceSeriesUpdateManyArgs>(args: SelectSubset<T, InvoiceSeriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceSeries.
     * @param {InvoiceSeriesUpsertArgs} args - Arguments to update or create a InvoiceSeries.
     * @example
     * // Update or create a InvoiceSeries
     * const invoiceSeries = await prisma.invoiceSeries.upsert({
     *   create: {
     *     // ... data to create a InvoiceSeries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceSeries we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceSeriesUpsertArgs>(args: SelectSubset<T, InvoiceSeriesUpsertArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSeriesCountArgs} args - Arguments to filter InvoiceSeries to count.
     * @example
     * // Count the number of InvoiceSeries
     * const count = await prisma.invoiceSeries.count({
     *   where: {
     *     // ... the filter for the InvoiceSeries we want to count
     *   }
     * })
    **/
    count<T extends InvoiceSeriesCountArgs>(
      args?: Subset<T, InvoiceSeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceSeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceSeriesAggregateArgs>(args: Subset<T, InvoiceSeriesAggregateArgs>): Prisma.PrismaPromise<GetInvoiceSeriesAggregateType<T>>

    /**
     * Group by InvoiceSeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceSeriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceSeriesGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceSeriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceSeriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceSeries model
   */
  readonly fields: InvoiceSeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceSeries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceSeriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends InvoiceSeries$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceSeries$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceSeries model
   */ 
  interface InvoiceSeriesFieldRefs {
    readonly id: FieldRef<"InvoiceSeries", 'String'>
    readonly companyId: FieldRef<"InvoiceSeries", 'String'>
    readonly code: FieldRef<"InvoiceSeries", 'String'>
    readonly name: FieldRef<"InvoiceSeries", 'String'>
    readonly type: FieldRef<"InvoiceSeries", 'InvoiceType'>
    readonly prefix: FieldRef<"InvoiceSeries", 'String'>
    readonly suffix: FieldRef<"InvoiceSeries", 'String'>
    readonly nextNumber: FieldRef<"InvoiceSeries", 'Int'>
    readonly digitCount: FieldRef<"InvoiceSeries", 'Int'>
    readonly isDefault: FieldRef<"InvoiceSeries", 'Boolean'>
    readonly isActive: FieldRef<"InvoiceSeries", 'Boolean'>
    readonly createdAt: FieldRef<"InvoiceSeries", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceSeries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceSeries findUnique
   */
  export type InvoiceSeriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSeries to fetch.
     */
    where: InvoiceSeriesWhereUniqueInput
  }

  /**
   * InvoiceSeries findUniqueOrThrow
   */
  export type InvoiceSeriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSeries to fetch.
     */
    where: InvoiceSeriesWhereUniqueInput
  }

  /**
   * InvoiceSeries findFirst
   */
  export type InvoiceSeriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSeries to fetch.
     */
    where?: InvoiceSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSeries to fetch.
     */
    orderBy?: InvoiceSeriesOrderByWithRelationInput | InvoiceSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceSeries.
     */
    cursor?: InvoiceSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceSeries.
     */
    distinct?: InvoiceSeriesScalarFieldEnum | InvoiceSeriesScalarFieldEnum[]
  }

  /**
   * InvoiceSeries findFirstOrThrow
   */
  export type InvoiceSeriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSeries to fetch.
     */
    where?: InvoiceSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSeries to fetch.
     */
    orderBy?: InvoiceSeriesOrderByWithRelationInput | InvoiceSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceSeries.
     */
    cursor?: InvoiceSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceSeries.
     */
    distinct?: InvoiceSeriesScalarFieldEnum | InvoiceSeriesScalarFieldEnum[]
  }

  /**
   * InvoiceSeries findMany
   */
  export type InvoiceSeriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSeries to fetch.
     */
    where?: InvoiceSeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSeries to fetch.
     */
    orderBy?: InvoiceSeriesOrderByWithRelationInput | InvoiceSeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceSeries.
     */
    cursor?: InvoiceSeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSeries.
     */
    skip?: number
    distinct?: InvoiceSeriesScalarFieldEnum | InvoiceSeriesScalarFieldEnum[]
  }

  /**
   * InvoiceSeries create
   */
  export type InvoiceSeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceSeries.
     */
    data: XOR<InvoiceSeriesCreateInput, InvoiceSeriesUncheckedCreateInput>
  }

  /**
   * InvoiceSeries createMany
   */
  export type InvoiceSeriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceSeries.
     */
    data: InvoiceSeriesCreateManyInput | InvoiceSeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceSeries createManyAndReturn
   */
  export type InvoiceSeriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceSeries.
     */
    data: InvoiceSeriesCreateManyInput | InvoiceSeriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceSeries update
   */
  export type InvoiceSeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceSeries.
     */
    data: XOR<InvoiceSeriesUpdateInput, InvoiceSeriesUncheckedUpdateInput>
    /**
     * Choose, which InvoiceSeries to update.
     */
    where: InvoiceSeriesWhereUniqueInput
  }

  /**
   * InvoiceSeries updateMany
   */
  export type InvoiceSeriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceSeries.
     */
    data: XOR<InvoiceSeriesUpdateManyMutationInput, InvoiceSeriesUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceSeries to update
     */
    where?: InvoiceSeriesWhereInput
  }

  /**
   * InvoiceSeries upsert
   */
  export type InvoiceSeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceSeries to update in case it exists.
     */
    where: InvoiceSeriesWhereUniqueInput
    /**
     * In case the InvoiceSeries found by the `where` argument doesn't exist, create a new InvoiceSeries with this data.
     */
    create: XOR<InvoiceSeriesCreateInput, InvoiceSeriesUncheckedCreateInput>
    /**
     * In case the InvoiceSeries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceSeriesUpdateInput, InvoiceSeriesUncheckedUpdateInput>
  }

  /**
   * InvoiceSeries delete
   */
  export type InvoiceSeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
    /**
     * Filter which InvoiceSeries to delete.
     */
    where: InvoiceSeriesWhereUniqueInput
  }

  /**
   * InvoiceSeries deleteMany
   */
  export type InvoiceSeriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceSeries to delete
     */
    where?: InvoiceSeriesWhereInput
  }

  /**
   * InvoiceSeries.invoices
   */
  export type InvoiceSeries$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * InvoiceSeries without action
   */
  export type InvoiceSeriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSeries
     */
    select?: InvoiceSeriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSeriesInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    number: number | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    taxableBase: Decimal | null
    totalTax: Decimal | null
    total: Decimal | null
    exchangeRate: Decimal | null
    cryptoAmount: Decimal | null
    cryptoRate: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    number: number | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    taxableBase: Decimal | null
    totalTax: Decimal | null
    total: Decimal | null
    exchangeRate: Decimal | null
    cryptoAmount: Decimal | null
    cryptoRate: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    seriesId: string | null
    contactId: string | null
    number: number | null
    fullNumber: string | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    direction: $Enums.InvoiceDirection | null
    issueDate: Date | null
    dueDate: Date | null
    operationDate: Date | null
    paidAt: Date | null
    counterpartyName: string | null
    counterpartyTaxId: string | null
    counterpartyAddress: string | null
    counterpartyCity: string | null
    counterpartyCountry: string | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    taxableBase: Decimal | null
    totalTax: Decimal | null
    total: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    cryptoPayment: boolean | null
    cryptoAsset: string | null
    cryptoAmount: Decimal | null
    cryptoRate: Decimal | null
    cryptoTxHash: string | null
    verifactuHash: string | null
    verifactuPrevHash: string | null
    verifactuQrData: string | null
    verifactuSentAt: Date | null
    verifactuStatus: $Enums.VerifactuStatus | null
    notes: string | null
    internalNotes: string | null
    paymentTerms: string | null
    paymentMethod: string | null
    journalEntryId: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    seriesId: string | null
    contactId: string | null
    number: number | null
    fullNumber: string | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    direction: $Enums.InvoiceDirection | null
    issueDate: Date | null
    dueDate: Date | null
    operationDate: Date | null
    paidAt: Date | null
    counterpartyName: string | null
    counterpartyTaxId: string | null
    counterpartyAddress: string | null
    counterpartyCity: string | null
    counterpartyCountry: string | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    taxableBase: Decimal | null
    totalTax: Decimal | null
    total: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    cryptoPayment: boolean | null
    cryptoAsset: string | null
    cryptoAmount: Decimal | null
    cryptoRate: Decimal | null
    cryptoTxHash: string | null
    verifactuHash: string | null
    verifactuPrevHash: string | null
    verifactuQrData: string | null
    verifactuSentAt: Date | null
    verifactuStatus: $Enums.VerifactuStatus | null
    notes: string | null
    internalNotes: string | null
    paymentTerms: string | null
    paymentMethod: string | null
    journalEntryId: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    companyId: number
    seriesId: number
    contactId: number
    number: number
    fullNumber: number
    type: number
    status: number
    direction: number
    issueDate: number
    dueDate: number
    operationDate: number
    paidAt: number
    counterpartyName: number
    counterpartyTaxId: number
    counterpartyAddress: number
    counterpartyCity: number
    counterpartyCountry: number
    subtotal: number
    discountAmount: number
    taxableBase: number
    totalTax: number
    total: number
    currency: number
    exchangeRate: number
    cryptoPayment: number
    cryptoAsset: number
    cryptoAmount: number
    cryptoRate: number
    cryptoTxHash: number
    verifactuHash: number
    verifactuPrevHash: number
    verifactuQrData: number
    verifactuSentAt: number
    verifactuResponse: number
    verifactuStatus: number
    notes: number
    internalNotes: number
    paymentTerms: number
    paymentMethod: number
    journalEntryId: number
    pdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    number?: true
    subtotal?: true
    discountAmount?: true
    taxableBase?: true
    totalTax?: true
    total?: true
    exchangeRate?: true
    cryptoAmount?: true
    cryptoRate?: true
  }

  export type InvoiceSumAggregateInputType = {
    number?: true
    subtotal?: true
    discountAmount?: true
    taxableBase?: true
    totalTax?: true
    total?: true
    exchangeRate?: true
    cryptoAmount?: true
    cryptoRate?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    companyId?: true
    seriesId?: true
    contactId?: true
    number?: true
    fullNumber?: true
    type?: true
    status?: true
    direction?: true
    issueDate?: true
    dueDate?: true
    operationDate?: true
    paidAt?: true
    counterpartyName?: true
    counterpartyTaxId?: true
    counterpartyAddress?: true
    counterpartyCity?: true
    counterpartyCountry?: true
    subtotal?: true
    discountAmount?: true
    taxableBase?: true
    totalTax?: true
    total?: true
    currency?: true
    exchangeRate?: true
    cryptoPayment?: true
    cryptoAsset?: true
    cryptoAmount?: true
    cryptoRate?: true
    cryptoTxHash?: true
    verifactuHash?: true
    verifactuPrevHash?: true
    verifactuQrData?: true
    verifactuSentAt?: true
    verifactuStatus?: true
    notes?: true
    internalNotes?: true
    paymentTerms?: true
    paymentMethod?: true
    journalEntryId?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    companyId?: true
    seriesId?: true
    contactId?: true
    number?: true
    fullNumber?: true
    type?: true
    status?: true
    direction?: true
    issueDate?: true
    dueDate?: true
    operationDate?: true
    paidAt?: true
    counterpartyName?: true
    counterpartyTaxId?: true
    counterpartyAddress?: true
    counterpartyCity?: true
    counterpartyCountry?: true
    subtotal?: true
    discountAmount?: true
    taxableBase?: true
    totalTax?: true
    total?: true
    currency?: true
    exchangeRate?: true
    cryptoPayment?: true
    cryptoAsset?: true
    cryptoAmount?: true
    cryptoRate?: true
    cryptoTxHash?: true
    verifactuHash?: true
    verifactuPrevHash?: true
    verifactuQrData?: true
    verifactuSentAt?: true
    verifactuStatus?: true
    notes?: true
    internalNotes?: true
    paymentTerms?: true
    paymentMethod?: true
    journalEntryId?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    companyId?: true
    seriesId?: true
    contactId?: true
    number?: true
    fullNumber?: true
    type?: true
    status?: true
    direction?: true
    issueDate?: true
    dueDate?: true
    operationDate?: true
    paidAt?: true
    counterpartyName?: true
    counterpartyTaxId?: true
    counterpartyAddress?: true
    counterpartyCity?: true
    counterpartyCountry?: true
    subtotal?: true
    discountAmount?: true
    taxableBase?: true
    totalTax?: true
    total?: true
    currency?: true
    exchangeRate?: true
    cryptoPayment?: true
    cryptoAsset?: true
    cryptoAmount?: true
    cryptoRate?: true
    cryptoTxHash?: true
    verifactuHash?: true
    verifactuPrevHash?: true
    verifactuQrData?: true
    verifactuSentAt?: true
    verifactuResponse?: true
    verifactuStatus?: true
    notes?: true
    internalNotes?: true
    paymentTerms?: true
    paymentMethod?: true
    journalEntryId?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    companyId: string
    seriesId: string
    contactId: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date
    dueDate: Date | null
    operationDate: Date | null
    paidAt: Date | null
    counterpartyName: string
    counterpartyTaxId: string | null
    counterpartyAddress: string | null
    counterpartyCity: string | null
    counterpartyCountry: string
    subtotal: Decimal
    discountAmount: Decimal
    taxableBase: Decimal
    totalTax: Decimal
    total: Decimal
    currency: string
    exchangeRate: Decimal
    cryptoPayment: boolean
    cryptoAsset: string | null
    cryptoAmount: Decimal | null
    cryptoRate: Decimal | null
    cryptoTxHash: string | null
    verifactuHash: string | null
    verifactuPrevHash: string | null
    verifactuQrData: string | null
    verifactuSentAt: Date | null
    verifactuResponse: JsonValue | null
    verifactuStatus: $Enums.VerifactuStatus | null
    notes: string | null
    internalNotes: string | null
    paymentTerms: string | null
    paymentMethod: string | null
    journalEntryId: string | null
    pdfUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    seriesId?: boolean
    contactId?: boolean
    number?: boolean
    fullNumber?: boolean
    type?: boolean
    status?: boolean
    direction?: boolean
    issueDate?: boolean
    dueDate?: boolean
    operationDate?: boolean
    paidAt?: boolean
    counterpartyName?: boolean
    counterpartyTaxId?: boolean
    counterpartyAddress?: boolean
    counterpartyCity?: boolean
    counterpartyCountry?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    taxableBase?: boolean
    totalTax?: boolean
    total?: boolean
    currency?: boolean
    exchangeRate?: boolean
    cryptoPayment?: boolean
    cryptoAsset?: boolean
    cryptoAmount?: boolean
    cryptoRate?: boolean
    cryptoTxHash?: boolean
    verifactuHash?: boolean
    verifactuPrevHash?: boolean
    verifactuQrData?: boolean
    verifactuSentAt?: boolean
    verifactuResponse?: boolean
    verifactuStatus?: boolean
    notes?: boolean
    internalNotes?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    journalEntryId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    series?: boolean | InvoiceSeriesDefaultArgs<ExtArgs>
    contact?: boolean | Invoice$contactArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    taxes?: boolean | Invoice$taxesArgs<ExtArgs>
    verifactuRecords?: boolean | Invoice$verifactuRecordsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    seriesId?: boolean
    contactId?: boolean
    number?: boolean
    fullNumber?: boolean
    type?: boolean
    status?: boolean
    direction?: boolean
    issueDate?: boolean
    dueDate?: boolean
    operationDate?: boolean
    paidAt?: boolean
    counterpartyName?: boolean
    counterpartyTaxId?: boolean
    counterpartyAddress?: boolean
    counterpartyCity?: boolean
    counterpartyCountry?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    taxableBase?: boolean
    totalTax?: boolean
    total?: boolean
    currency?: boolean
    exchangeRate?: boolean
    cryptoPayment?: boolean
    cryptoAsset?: boolean
    cryptoAmount?: boolean
    cryptoRate?: boolean
    cryptoTxHash?: boolean
    verifactuHash?: boolean
    verifactuPrevHash?: boolean
    verifactuQrData?: boolean
    verifactuSentAt?: boolean
    verifactuResponse?: boolean
    verifactuStatus?: boolean
    notes?: boolean
    internalNotes?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    journalEntryId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    series?: boolean | InvoiceSeriesDefaultArgs<ExtArgs>
    contact?: boolean | Invoice$contactArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    companyId?: boolean
    seriesId?: boolean
    contactId?: boolean
    number?: boolean
    fullNumber?: boolean
    type?: boolean
    status?: boolean
    direction?: boolean
    issueDate?: boolean
    dueDate?: boolean
    operationDate?: boolean
    paidAt?: boolean
    counterpartyName?: boolean
    counterpartyTaxId?: boolean
    counterpartyAddress?: boolean
    counterpartyCity?: boolean
    counterpartyCountry?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    taxableBase?: boolean
    totalTax?: boolean
    total?: boolean
    currency?: boolean
    exchangeRate?: boolean
    cryptoPayment?: boolean
    cryptoAsset?: boolean
    cryptoAmount?: boolean
    cryptoRate?: boolean
    cryptoTxHash?: boolean
    verifactuHash?: boolean
    verifactuPrevHash?: boolean
    verifactuQrData?: boolean
    verifactuSentAt?: boolean
    verifactuResponse?: boolean
    verifactuStatus?: boolean
    notes?: boolean
    internalNotes?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    journalEntryId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    series?: boolean | InvoiceSeriesDefaultArgs<ExtArgs>
    contact?: boolean | Invoice$contactArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    taxes?: boolean | Invoice$taxesArgs<ExtArgs>
    verifactuRecords?: boolean | Invoice$verifactuRecordsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    series?: boolean | InvoiceSeriesDefaultArgs<ExtArgs>
    contact?: boolean | Invoice$contactArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      series: Prisma.$InvoiceSeriesPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      taxes: Prisma.$InvoiceTaxPayload<ExtArgs>[]
      verifactuRecords: Prisma.$VerifactuRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      seriesId: string
      contactId: string | null
      number: number
      fullNumber: string
      type: $Enums.InvoiceType
      status: $Enums.InvoiceStatus
      direction: $Enums.InvoiceDirection
      issueDate: Date
      dueDate: Date | null
      operationDate: Date | null
      paidAt: Date | null
      counterpartyName: string
      counterpartyTaxId: string | null
      counterpartyAddress: string | null
      counterpartyCity: string | null
      counterpartyCountry: string
      subtotal: Prisma.Decimal
      discountAmount: Prisma.Decimal
      taxableBase: Prisma.Decimal
      totalTax: Prisma.Decimal
      total: Prisma.Decimal
      currency: string
      exchangeRate: Prisma.Decimal
      cryptoPayment: boolean
      cryptoAsset: string | null
      cryptoAmount: Prisma.Decimal | null
      cryptoRate: Prisma.Decimal | null
      cryptoTxHash: string | null
      verifactuHash: string | null
      verifactuPrevHash: string | null
      verifactuQrData: string | null
      verifactuSentAt: Date | null
      verifactuResponse: Prisma.JsonValue | null
      verifactuStatus: $Enums.VerifactuStatus | null
      notes: string | null
      internalNotes: string | null
      paymentTerms: string | null
      paymentMethod: string | null
      journalEntryId: string | null
      pdfUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    series<T extends InvoiceSeriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceSeriesDefaultArgs<ExtArgs>>): Prisma__InvoiceSeriesClient<$Result.GetResult<Prisma.$InvoiceSeriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends Invoice$contactArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lines<T extends Invoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany"> | Null>
    taxes<T extends Invoice$taxesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$taxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "findMany"> | Null>
    verifactuRecords<T extends Invoice$verifactuRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$verifactuRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly companyId: FieldRef<"Invoice", 'String'>
    readonly seriesId: FieldRef<"Invoice", 'String'>
    readonly contactId: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'Int'>
    readonly fullNumber: FieldRef<"Invoice", 'String'>
    readonly type: FieldRef<"Invoice", 'InvoiceType'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly direction: FieldRef<"Invoice", 'InvoiceDirection'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly operationDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly counterpartyName: FieldRef<"Invoice", 'String'>
    readonly counterpartyTaxId: FieldRef<"Invoice", 'String'>
    readonly counterpartyAddress: FieldRef<"Invoice", 'String'>
    readonly counterpartyCity: FieldRef<"Invoice", 'String'>
    readonly counterpartyCountry: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly discountAmount: FieldRef<"Invoice", 'Decimal'>
    readonly taxableBase: FieldRef<"Invoice", 'Decimal'>
    readonly totalTax: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly exchangeRate: FieldRef<"Invoice", 'Decimal'>
    readonly cryptoPayment: FieldRef<"Invoice", 'Boolean'>
    readonly cryptoAsset: FieldRef<"Invoice", 'String'>
    readonly cryptoAmount: FieldRef<"Invoice", 'Decimal'>
    readonly cryptoRate: FieldRef<"Invoice", 'Decimal'>
    readonly cryptoTxHash: FieldRef<"Invoice", 'String'>
    readonly verifactuHash: FieldRef<"Invoice", 'String'>
    readonly verifactuPrevHash: FieldRef<"Invoice", 'String'>
    readonly verifactuQrData: FieldRef<"Invoice", 'String'>
    readonly verifactuSentAt: FieldRef<"Invoice", 'DateTime'>
    readonly verifactuResponse: FieldRef<"Invoice", 'Json'>
    readonly verifactuStatus: FieldRef<"Invoice", 'VerifactuStatus'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly internalNotes: FieldRef<"Invoice", 'String'>
    readonly paymentTerms: FieldRef<"Invoice", 'String'>
    readonly paymentMethod: FieldRef<"Invoice", 'String'>
    readonly journalEntryId: FieldRef<"Invoice", 'String'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.contact
   */
  export type Invoice$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Invoice.lines
   */
  export type Invoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Invoice.taxes
   */
  export type Invoice$taxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    where?: InvoiceTaxWhereInput
    orderBy?: InvoiceTaxOrderByWithRelationInput | InvoiceTaxOrderByWithRelationInput[]
    cursor?: InvoiceTaxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceTaxScalarFieldEnum | InvoiceTaxScalarFieldEnum[]
  }

  /**
   * Invoice.verifactuRecords
   */
  export type Invoice$verifactuRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    where?: VerifactuRecordWhereInput
    orderBy?: VerifactuRecordOrderByWithRelationInput | VerifactuRecordOrderByWithRelationInput[]
    cursor?: VerifactuRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerifactuRecordScalarFieldEnum | VerifactuRecordScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLine
   */

  export type AggregateInvoiceLine = {
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  export type InvoiceLineAvgAggregateOutputType = {
    lineNumber: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type InvoiceLineSumAggregateOutputType = {
    lineNumber: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type InvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    lineNumber: number | null
    description: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    accountCode: string | null
  }

  export type InvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    lineNumber: number | null
    description: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    accountCode: string | null
  }

  export type InvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    lineNumber: number
    description: number
    quantity: number
    unitPrice: number
    discount: number
    subtotal: number
    taxRate: number
    taxAmount: number
    total: number
    accountCode: number
    _all: number
  }


  export type InvoiceLineAvgAggregateInputType = {
    lineNumber?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
  }

  export type InvoiceLineSumAggregateInputType = {
    lineNumber?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
  }

  export type InvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    lineNumber?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    accountCode?: true
  }

  export type InvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    lineNumber?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    accountCode?: true
  }

  export type InvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    lineNumber?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    accountCode?: true
    _all?: true
  }

  export type InvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLine to aggregate.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLines
    **/
    _count?: true | InvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type GetInvoiceLineAggregateType<T extends InvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLine[P]>
      : GetScalarType<T[P], AggregateInvoiceLine[P]>
  }




  export type InvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithAggregationInput | InvoiceLineOrderByWithAggregationInput[]
    by: InvoiceLineScalarFieldEnum[] | InvoiceLineScalarFieldEnum
    having?: InvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineCountAggregateInputType | true
    _avg?: InvoiceLineAvgAggregateInputType
    _sum?: InvoiceLineSumAggregateInputType
    _min?: InvoiceLineMinAggregateInputType
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type InvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    lineNumber: number
    description: string
    quantity: Decimal
    unitPrice: Decimal
    discount: Decimal
    subtotal: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    total: Decimal
    accountCode: string | null
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  type GetInvoiceLineGroupByPayload<T extends InvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    lineNumber?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    accountCode?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    lineNumber?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    accountCode?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    lineNumber?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    accountCode?: boolean
  }

  export type InvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLine"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      lineNumber: number
      description: string
      quantity: Prisma.Decimal
      unitPrice: Prisma.Decimal
      discount: Prisma.Decimal
      subtotal: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      accountCode: string | null
    }, ExtArgs["result"]["invoiceLine"]>
    composites: {}
  }

  type InvoiceLineGetPayload<S extends boolean | null | undefined | InvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLinePayload, S>

  type InvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceLineCountAggregateInputType | true
    }

  export interface InvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLine'], meta: { name: 'InvoiceLine' } }
    /**
     * Find zero or one InvoiceLine that matches the filter.
     * @param {InvoiceLineFindUniqueArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineFindUniqueArgs>(args: SelectSubset<T, InvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineFindFirstArgs>(args?: SelectSubset<T, InvoiceLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany()
     * 
     * // Get first 10 InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineFindManyArgs>(args?: SelectSubset<T, InvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceLine.
     * @param {InvoiceLineCreateArgs} args - Arguments to create a InvoiceLine.
     * @example
     * // Create one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.create({
     *   data: {
     *     // ... data to create a InvoiceLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineCreateArgs>(args: SelectSubset<T, InvoiceLineCreateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceLines.
     * @param {InvoiceLineCreateManyArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineCreateManyArgs>(args?: SelectSubset<T, InvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLines and returns the data saved in the database.
     * @param {InvoiceLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceLine.
     * @param {InvoiceLineDeleteArgs} args - Arguments to delete one InvoiceLine.
     * @example
     * // Delete one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineDeleteArgs>(args: SelectSubset<T, InvoiceLineDeleteArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceLine.
     * @param {InvoiceLineUpdateArgs} args - Arguments to update one InvoiceLine.
     * @example
     * // Update one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineUpdateArgs>(args: SelectSubset<T, InvoiceLineUpdateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceLines.
     * @param {InvoiceLineDeleteManyArgs} args - Arguments to filter InvoiceLines to delete.
     * @example
     * // Delete a few InvoiceLines
     * const { count } = await prisma.invoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineUpdateManyArgs>(args: SelectSubset<T, InvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceLine.
     * @param {InvoiceLineUpsertArgs} args - Arguments to update or create a InvoiceLine.
     * @example
     * // Update or create a InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineUpsertArgs>(args: SelectSubset<T, InvoiceLineUpsertArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineCountArgs} args - Arguments to filter InvoiceLines to count.
     * @example
     * // Count the number of InvoiceLines
     * const count = await prisma.invoiceLine.count({
     *   where: {
     *     // ... the filter for the InvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineCountArgs>(
      args?: Subset<T, InvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineAggregateArgs>(args: Subset<T, InvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineAggregateType<T>>

    /**
     * Group by InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLine model
   */
  readonly fields: InvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLine model
   */ 
  interface InvoiceLineFieldRefs {
    readonly id: FieldRef<"InvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLine", 'String'>
    readonly lineNumber: FieldRef<"InvoiceLine", 'Int'>
    readonly description: FieldRef<"InvoiceLine", 'String'>
    readonly quantity: FieldRef<"InvoiceLine", 'Decimal'>
    readonly unitPrice: FieldRef<"InvoiceLine", 'Decimal'>
    readonly discount: FieldRef<"InvoiceLine", 'Decimal'>
    readonly subtotal: FieldRef<"InvoiceLine", 'Decimal'>
    readonly taxRate: FieldRef<"InvoiceLine", 'Decimal'>
    readonly taxAmount: FieldRef<"InvoiceLine", 'Decimal'>
    readonly total: FieldRef<"InvoiceLine", 'Decimal'>
    readonly accountCode: FieldRef<"InvoiceLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLine findUnique
   */
  export type InvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findUniqueOrThrow
   */
  export type InvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findFirst
   */
  export type InvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findFirstOrThrow
   */
  export type InvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findMany
   */
  export type InvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLines to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine create
   */
  export type InvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLine.
     */
    data: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
  }

  /**
   * InvoiceLine createMany
   */
  export type InvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLine createManyAndReturn
   */
  export type InvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine update
   */
  export type InvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLine.
     */
    data: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLine to update.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine updateMany
   */
  export type InvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine upsert
   */
  export type InvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLine to update in case it exists.
     */
    where: InvoiceLineWhereUniqueInput
    /**
     * In case the InvoiceLine found by the `where` argument doesn't exist, create a new InvoiceLine with this data.
     */
    create: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
    /**
     * In case the InvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
  }

  /**
   * InvoiceLine delete
   */
  export type InvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLine to delete.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine deleteMany
   */
  export type InvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLines to delete
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine without action
   */
  export type InvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceTax
   */

  export type AggregateInvoiceTax = {
    _count: InvoiceTaxCountAggregateOutputType | null
    _avg: InvoiceTaxAvgAggregateOutputType | null
    _sum: InvoiceTaxSumAggregateOutputType | null
    _min: InvoiceTaxMinAggregateOutputType | null
    _max: InvoiceTaxMaxAggregateOutputType | null
  }

  export type InvoiceTaxAvgAggregateOutputType = {
    taxRate: Decimal | null
    taxableBase: Decimal | null
    taxAmount: Decimal | null
  }

  export type InvoiceTaxSumAggregateOutputType = {
    taxRate: Decimal | null
    taxableBase: Decimal | null
    taxAmount: Decimal | null
  }

  export type InvoiceTaxMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    taxRate: Decimal | null
    taxableBase: Decimal | null
    taxAmount: Decimal | null
    taxType: $Enums.TaxType | null
  }

  export type InvoiceTaxMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    taxRate: Decimal | null
    taxableBase: Decimal | null
    taxAmount: Decimal | null
    taxType: $Enums.TaxType | null
  }

  export type InvoiceTaxCountAggregateOutputType = {
    id: number
    invoiceId: number
    taxRate: number
    taxableBase: number
    taxAmount: number
    taxType: number
    _all: number
  }


  export type InvoiceTaxAvgAggregateInputType = {
    taxRate?: true
    taxableBase?: true
    taxAmount?: true
  }

  export type InvoiceTaxSumAggregateInputType = {
    taxRate?: true
    taxableBase?: true
    taxAmount?: true
  }

  export type InvoiceTaxMinAggregateInputType = {
    id?: true
    invoiceId?: true
    taxRate?: true
    taxableBase?: true
    taxAmount?: true
    taxType?: true
  }

  export type InvoiceTaxMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    taxRate?: true
    taxableBase?: true
    taxAmount?: true
    taxType?: true
  }

  export type InvoiceTaxCountAggregateInputType = {
    id?: true
    invoiceId?: true
    taxRate?: true
    taxableBase?: true
    taxAmount?: true
    taxType?: true
    _all?: true
  }

  export type InvoiceTaxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceTax to aggregate.
     */
    where?: InvoiceTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTaxes to fetch.
     */
    orderBy?: InvoiceTaxOrderByWithRelationInput | InvoiceTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceTaxes
    **/
    _count?: true | InvoiceTaxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceTaxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceTaxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceTaxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceTaxMaxAggregateInputType
  }

  export type GetInvoiceTaxAggregateType<T extends InvoiceTaxAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceTax]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceTax[P]>
      : GetScalarType<T[P], AggregateInvoiceTax[P]>
  }




  export type InvoiceTaxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceTaxWhereInput
    orderBy?: InvoiceTaxOrderByWithAggregationInput | InvoiceTaxOrderByWithAggregationInput[]
    by: InvoiceTaxScalarFieldEnum[] | InvoiceTaxScalarFieldEnum
    having?: InvoiceTaxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceTaxCountAggregateInputType | true
    _avg?: InvoiceTaxAvgAggregateInputType
    _sum?: InvoiceTaxSumAggregateInputType
    _min?: InvoiceTaxMinAggregateInputType
    _max?: InvoiceTaxMaxAggregateInputType
  }

  export type InvoiceTaxGroupByOutputType = {
    id: string
    invoiceId: string
    taxRate: Decimal
    taxableBase: Decimal
    taxAmount: Decimal
    taxType: $Enums.TaxType
    _count: InvoiceTaxCountAggregateOutputType | null
    _avg: InvoiceTaxAvgAggregateOutputType | null
    _sum: InvoiceTaxSumAggregateOutputType | null
    _min: InvoiceTaxMinAggregateOutputType | null
    _max: InvoiceTaxMaxAggregateOutputType | null
  }

  type GetInvoiceTaxGroupByPayload<T extends InvoiceTaxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceTaxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceTaxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceTaxGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceTaxGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceTaxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    taxRate?: boolean
    taxableBase?: boolean
    taxAmount?: boolean
    taxType?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceTax"]>

  export type InvoiceTaxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    taxRate?: boolean
    taxableBase?: boolean
    taxAmount?: boolean
    taxType?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceTax"]>

  export type InvoiceTaxSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    taxRate?: boolean
    taxableBase?: boolean
    taxAmount?: boolean
    taxType?: boolean
  }

  export type InvoiceTaxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceTaxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceTaxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceTax"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      taxRate: Prisma.Decimal
      taxableBase: Prisma.Decimal
      taxAmount: Prisma.Decimal
      taxType: $Enums.TaxType
    }, ExtArgs["result"]["invoiceTax"]>
    composites: {}
  }

  type InvoiceTaxGetPayload<S extends boolean | null | undefined | InvoiceTaxDefaultArgs> = $Result.GetResult<Prisma.$InvoiceTaxPayload, S>

  type InvoiceTaxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceTaxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceTaxCountAggregateInputType | true
    }

  export interface InvoiceTaxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceTax'], meta: { name: 'InvoiceTax' } }
    /**
     * Find zero or one InvoiceTax that matches the filter.
     * @param {InvoiceTaxFindUniqueArgs} args - Arguments to find a InvoiceTax
     * @example
     * // Get one InvoiceTax
     * const invoiceTax = await prisma.invoiceTax.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceTaxFindUniqueArgs>(args: SelectSubset<T, InvoiceTaxFindUniqueArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceTax that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceTaxFindUniqueOrThrowArgs} args - Arguments to find a InvoiceTax
     * @example
     * // Get one InvoiceTax
     * const invoiceTax = await prisma.invoiceTax.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceTaxFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceTaxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceTax that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTaxFindFirstArgs} args - Arguments to find a InvoiceTax
     * @example
     * // Get one InvoiceTax
     * const invoiceTax = await prisma.invoiceTax.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceTaxFindFirstArgs>(args?: SelectSubset<T, InvoiceTaxFindFirstArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceTax that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTaxFindFirstOrThrowArgs} args - Arguments to find a InvoiceTax
     * @example
     * // Get one InvoiceTax
     * const invoiceTax = await prisma.invoiceTax.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceTaxFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceTaxFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceTaxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTaxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceTaxes
     * const invoiceTaxes = await prisma.invoiceTax.findMany()
     * 
     * // Get first 10 InvoiceTaxes
     * const invoiceTaxes = await prisma.invoiceTax.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceTaxWithIdOnly = await prisma.invoiceTax.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceTaxFindManyArgs>(args?: SelectSubset<T, InvoiceTaxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceTax.
     * @param {InvoiceTaxCreateArgs} args - Arguments to create a InvoiceTax.
     * @example
     * // Create one InvoiceTax
     * const InvoiceTax = await prisma.invoiceTax.create({
     *   data: {
     *     // ... data to create a InvoiceTax
     *   }
     * })
     * 
     */
    create<T extends InvoiceTaxCreateArgs>(args: SelectSubset<T, InvoiceTaxCreateArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceTaxes.
     * @param {InvoiceTaxCreateManyArgs} args - Arguments to create many InvoiceTaxes.
     * @example
     * // Create many InvoiceTaxes
     * const invoiceTax = await prisma.invoiceTax.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceTaxCreateManyArgs>(args?: SelectSubset<T, InvoiceTaxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceTaxes and returns the data saved in the database.
     * @param {InvoiceTaxCreateManyAndReturnArgs} args - Arguments to create many InvoiceTaxes.
     * @example
     * // Create many InvoiceTaxes
     * const invoiceTax = await prisma.invoiceTax.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceTaxes and only return the `id`
     * const invoiceTaxWithIdOnly = await prisma.invoiceTax.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceTaxCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceTaxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceTax.
     * @param {InvoiceTaxDeleteArgs} args - Arguments to delete one InvoiceTax.
     * @example
     * // Delete one InvoiceTax
     * const InvoiceTax = await prisma.invoiceTax.delete({
     *   where: {
     *     // ... filter to delete one InvoiceTax
     *   }
     * })
     * 
     */
    delete<T extends InvoiceTaxDeleteArgs>(args: SelectSubset<T, InvoiceTaxDeleteArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceTax.
     * @param {InvoiceTaxUpdateArgs} args - Arguments to update one InvoiceTax.
     * @example
     * // Update one InvoiceTax
     * const invoiceTax = await prisma.invoiceTax.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceTaxUpdateArgs>(args: SelectSubset<T, InvoiceTaxUpdateArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceTaxes.
     * @param {InvoiceTaxDeleteManyArgs} args - Arguments to filter InvoiceTaxes to delete.
     * @example
     * // Delete a few InvoiceTaxes
     * const { count } = await prisma.invoiceTax.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceTaxDeleteManyArgs>(args?: SelectSubset<T, InvoiceTaxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceTaxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTaxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceTaxes
     * const invoiceTax = await prisma.invoiceTax.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceTaxUpdateManyArgs>(args: SelectSubset<T, InvoiceTaxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceTax.
     * @param {InvoiceTaxUpsertArgs} args - Arguments to update or create a InvoiceTax.
     * @example
     * // Update or create a InvoiceTax
     * const invoiceTax = await prisma.invoiceTax.upsert({
     *   create: {
     *     // ... data to create a InvoiceTax
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceTax we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceTaxUpsertArgs>(args: SelectSubset<T, InvoiceTaxUpsertArgs<ExtArgs>>): Prisma__InvoiceTaxClient<$Result.GetResult<Prisma.$InvoiceTaxPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceTaxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTaxCountArgs} args - Arguments to filter InvoiceTaxes to count.
     * @example
     * // Count the number of InvoiceTaxes
     * const count = await prisma.invoiceTax.count({
     *   where: {
     *     // ... the filter for the InvoiceTaxes we want to count
     *   }
     * })
    **/
    count<T extends InvoiceTaxCountArgs>(
      args?: Subset<T, InvoiceTaxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceTaxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceTax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTaxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceTaxAggregateArgs>(args: Subset<T, InvoiceTaxAggregateArgs>): Prisma.PrismaPromise<GetInvoiceTaxAggregateType<T>>

    /**
     * Group by InvoiceTax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceTaxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceTaxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceTaxGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceTaxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceTaxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceTaxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceTax model
   */
  readonly fields: InvoiceTaxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceTax.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceTaxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceTax model
   */ 
  interface InvoiceTaxFieldRefs {
    readonly id: FieldRef<"InvoiceTax", 'String'>
    readonly invoiceId: FieldRef<"InvoiceTax", 'String'>
    readonly taxRate: FieldRef<"InvoiceTax", 'Decimal'>
    readonly taxableBase: FieldRef<"InvoiceTax", 'Decimal'>
    readonly taxAmount: FieldRef<"InvoiceTax", 'Decimal'>
    readonly taxType: FieldRef<"InvoiceTax", 'TaxType'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceTax findUnique
   */
  export type InvoiceTaxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceTax to fetch.
     */
    where: InvoiceTaxWhereUniqueInput
  }

  /**
   * InvoiceTax findUniqueOrThrow
   */
  export type InvoiceTaxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceTax to fetch.
     */
    where: InvoiceTaxWhereUniqueInput
  }

  /**
   * InvoiceTax findFirst
   */
  export type InvoiceTaxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceTax to fetch.
     */
    where?: InvoiceTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTaxes to fetch.
     */
    orderBy?: InvoiceTaxOrderByWithRelationInput | InvoiceTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceTaxes.
     */
    cursor?: InvoiceTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceTaxes.
     */
    distinct?: InvoiceTaxScalarFieldEnum | InvoiceTaxScalarFieldEnum[]
  }

  /**
   * InvoiceTax findFirstOrThrow
   */
  export type InvoiceTaxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceTax to fetch.
     */
    where?: InvoiceTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTaxes to fetch.
     */
    orderBy?: InvoiceTaxOrderByWithRelationInput | InvoiceTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceTaxes.
     */
    cursor?: InvoiceTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceTaxes.
     */
    distinct?: InvoiceTaxScalarFieldEnum | InvoiceTaxScalarFieldEnum[]
  }

  /**
   * InvoiceTax findMany
   */
  export type InvoiceTaxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceTaxes to fetch.
     */
    where?: InvoiceTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceTaxes to fetch.
     */
    orderBy?: InvoiceTaxOrderByWithRelationInput | InvoiceTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceTaxes.
     */
    cursor?: InvoiceTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceTaxes.
     */
    skip?: number
    distinct?: InvoiceTaxScalarFieldEnum | InvoiceTaxScalarFieldEnum[]
  }

  /**
   * InvoiceTax create
   */
  export type InvoiceTaxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceTax.
     */
    data: XOR<InvoiceTaxCreateInput, InvoiceTaxUncheckedCreateInput>
  }

  /**
   * InvoiceTax createMany
   */
  export type InvoiceTaxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceTaxes.
     */
    data: InvoiceTaxCreateManyInput | InvoiceTaxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceTax createManyAndReturn
   */
  export type InvoiceTaxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceTaxes.
     */
    data: InvoiceTaxCreateManyInput | InvoiceTaxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceTax update
   */
  export type InvoiceTaxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceTax.
     */
    data: XOR<InvoiceTaxUpdateInput, InvoiceTaxUncheckedUpdateInput>
    /**
     * Choose, which InvoiceTax to update.
     */
    where: InvoiceTaxWhereUniqueInput
  }

  /**
   * InvoiceTax updateMany
   */
  export type InvoiceTaxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceTaxes.
     */
    data: XOR<InvoiceTaxUpdateManyMutationInput, InvoiceTaxUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceTaxes to update
     */
    where?: InvoiceTaxWhereInput
  }

  /**
   * InvoiceTax upsert
   */
  export type InvoiceTaxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceTax to update in case it exists.
     */
    where: InvoiceTaxWhereUniqueInput
    /**
     * In case the InvoiceTax found by the `where` argument doesn't exist, create a new InvoiceTax with this data.
     */
    create: XOR<InvoiceTaxCreateInput, InvoiceTaxUncheckedCreateInput>
    /**
     * In case the InvoiceTax was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceTaxUpdateInput, InvoiceTaxUncheckedUpdateInput>
  }

  /**
   * InvoiceTax delete
   */
  export type InvoiceTaxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
    /**
     * Filter which InvoiceTax to delete.
     */
    where: InvoiceTaxWhereUniqueInput
  }

  /**
   * InvoiceTax deleteMany
   */
  export type InvoiceTaxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceTaxes to delete
     */
    where?: InvoiceTaxWhereInput
  }

  /**
   * InvoiceTax without action
   */
  export type InvoiceTaxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceTax
     */
    select?: InvoiceTaxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceTaxInclude<ExtArgs> | null
  }


  /**
   * Model CryptoAsset
   */

  export type AggregateCryptoAsset = {
    _count: CryptoAssetCountAggregateOutputType | null
    _avg: CryptoAssetAvgAggregateOutputType | null
    _sum: CryptoAssetSumAggregateOutputType | null
    _min: CryptoAssetMinAggregateOutputType | null
    _max: CryptoAssetMaxAggregateOutputType | null
  }

  export type CryptoAssetAvgAggregateOutputType = {
    decimals: number | null
    lastPrice: Decimal | null
  }

  export type CryptoAssetSumAggregateOutputType = {
    decimals: number | null
    lastPrice: Decimal | null
  }

  export type CryptoAssetMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    symbol: string | null
    name: string | null
    decimals: number | null
    contractAddress: string | null
    classification: $Enums.CryptoClassification | null
    coingeckoId: string | null
    lastPrice: Decimal | null
    lastPriceAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoAssetMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    symbol: string | null
    name: string | null
    decimals: number | null
    contractAddress: string | null
    classification: $Enums.CryptoClassification | null
    coingeckoId: string | null
    lastPrice: Decimal | null
    lastPriceAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoAssetCountAggregateOutputType = {
    id: number
    companyId: number
    symbol: number
    name: number
    decimals: number
    contractAddress: number
    classification: number
    coingeckoId: number
    lastPrice: number
    lastPriceAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoAssetAvgAggregateInputType = {
    decimals?: true
    lastPrice?: true
  }

  export type CryptoAssetSumAggregateInputType = {
    decimals?: true
    lastPrice?: true
  }

  export type CryptoAssetMinAggregateInputType = {
    id?: true
    companyId?: true
    symbol?: true
    name?: true
    decimals?: true
    contractAddress?: true
    classification?: true
    coingeckoId?: true
    lastPrice?: true
    lastPriceAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoAssetMaxAggregateInputType = {
    id?: true
    companyId?: true
    symbol?: true
    name?: true
    decimals?: true
    contractAddress?: true
    classification?: true
    coingeckoId?: true
    lastPrice?: true
    lastPriceAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoAssetCountAggregateInputType = {
    id?: true
    companyId?: true
    symbol?: true
    name?: true
    decimals?: true
    contractAddress?: true
    classification?: true
    coingeckoId?: true
    lastPrice?: true
    lastPriceAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoAsset to aggregate.
     */
    where?: CryptoAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoAssets to fetch.
     */
    orderBy?: CryptoAssetOrderByWithRelationInput | CryptoAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoAssets
    **/
    _count?: true | CryptoAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoAssetMaxAggregateInputType
  }

  export type GetCryptoAssetAggregateType<T extends CryptoAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoAsset[P]>
      : GetScalarType<T[P], AggregateCryptoAsset[P]>
  }




  export type CryptoAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoAssetWhereInput
    orderBy?: CryptoAssetOrderByWithAggregationInput | CryptoAssetOrderByWithAggregationInput[]
    by: CryptoAssetScalarFieldEnum[] | CryptoAssetScalarFieldEnum
    having?: CryptoAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoAssetCountAggregateInputType | true
    _avg?: CryptoAssetAvgAggregateInputType
    _sum?: CryptoAssetSumAggregateInputType
    _min?: CryptoAssetMinAggregateInputType
    _max?: CryptoAssetMaxAggregateInputType
  }

  export type CryptoAssetGroupByOutputType = {
    id: string
    companyId: string
    symbol: string
    name: string
    decimals: number
    contractAddress: string | null
    classification: $Enums.CryptoClassification
    coingeckoId: string | null
    lastPrice: Decimal | null
    lastPriceAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CryptoAssetCountAggregateOutputType | null
    _avg: CryptoAssetAvgAggregateOutputType | null
    _sum: CryptoAssetSumAggregateOutputType | null
    _min: CryptoAssetMinAggregateOutputType | null
    _max: CryptoAssetMaxAggregateOutputType | null
  }

  type GetCryptoAssetGroupByPayload<T extends CryptoAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoAssetGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoAssetGroupByOutputType[P]>
        }
      >
    >


  export type CryptoAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    symbol?: boolean
    name?: boolean
    decimals?: boolean
    contractAddress?: boolean
    classification?: boolean
    coingeckoId?: boolean
    lastPrice?: boolean
    lastPriceAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    accounts?: boolean | CryptoAsset$accountsArgs<ExtArgs>
    lots?: boolean | CryptoAsset$lotsArgs<ExtArgs>
    _count?: boolean | CryptoAssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoAsset"]>

  export type CryptoAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    symbol?: boolean
    name?: boolean
    decimals?: boolean
    contractAddress?: boolean
    classification?: boolean
    coingeckoId?: boolean
    lastPrice?: boolean
    lastPriceAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoAsset"]>

  export type CryptoAssetSelectScalar = {
    id?: boolean
    companyId?: boolean
    symbol?: boolean
    name?: boolean
    decimals?: boolean
    contractAddress?: boolean
    classification?: boolean
    coingeckoId?: boolean
    lastPrice?: boolean
    lastPriceAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    accounts?: boolean | CryptoAsset$accountsArgs<ExtArgs>
    lots?: boolean | CryptoAsset$lotsArgs<ExtArgs>
    _count?: boolean | CryptoAssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CryptoAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CryptoAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoAsset"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      lots: Prisma.$CryptoLotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      symbol: string
      name: string
      decimals: number
      contractAddress: string | null
      classification: $Enums.CryptoClassification
      coingeckoId: string | null
      lastPrice: Prisma.Decimal | null
      lastPriceAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoAsset"]>
    composites: {}
  }

  type CryptoAssetGetPayload<S extends boolean | null | undefined | CryptoAssetDefaultArgs> = $Result.GetResult<Prisma.$CryptoAssetPayload, S>

  type CryptoAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CryptoAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CryptoAssetCountAggregateInputType | true
    }

  export interface CryptoAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoAsset'], meta: { name: 'CryptoAsset' } }
    /**
     * Find zero or one CryptoAsset that matches the filter.
     * @param {CryptoAssetFindUniqueArgs} args - Arguments to find a CryptoAsset
     * @example
     * // Get one CryptoAsset
     * const cryptoAsset = await prisma.cryptoAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoAssetFindUniqueArgs>(args: SelectSubset<T, CryptoAssetFindUniqueArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CryptoAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CryptoAssetFindUniqueOrThrowArgs} args - Arguments to find a CryptoAsset
     * @example
     * // Get one CryptoAsset
     * const cryptoAsset = await prisma.cryptoAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CryptoAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoAssetFindFirstArgs} args - Arguments to find a CryptoAsset
     * @example
     * // Get one CryptoAsset
     * const cryptoAsset = await prisma.cryptoAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoAssetFindFirstArgs>(args?: SelectSubset<T, CryptoAssetFindFirstArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CryptoAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoAssetFindFirstOrThrowArgs} args - Arguments to find a CryptoAsset
     * @example
     * // Get one CryptoAsset
     * const cryptoAsset = await prisma.cryptoAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CryptoAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoAssets
     * const cryptoAssets = await prisma.cryptoAsset.findMany()
     * 
     * // Get first 10 CryptoAssets
     * const cryptoAssets = await prisma.cryptoAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoAssetWithIdOnly = await prisma.cryptoAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoAssetFindManyArgs>(args?: SelectSubset<T, CryptoAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CryptoAsset.
     * @param {CryptoAssetCreateArgs} args - Arguments to create a CryptoAsset.
     * @example
     * // Create one CryptoAsset
     * const CryptoAsset = await prisma.cryptoAsset.create({
     *   data: {
     *     // ... data to create a CryptoAsset
     *   }
     * })
     * 
     */
    create<T extends CryptoAssetCreateArgs>(args: SelectSubset<T, CryptoAssetCreateArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CryptoAssets.
     * @param {CryptoAssetCreateManyArgs} args - Arguments to create many CryptoAssets.
     * @example
     * // Create many CryptoAssets
     * const cryptoAsset = await prisma.cryptoAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoAssetCreateManyArgs>(args?: SelectSubset<T, CryptoAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoAssets and returns the data saved in the database.
     * @param {CryptoAssetCreateManyAndReturnArgs} args - Arguments to create many CryptoAssets.
     * @example
     * // Create many CryptoAssets
     * const cryptoAsset = await prisma.cryptoAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoAssets and only return the `id`
     * const cryptoAssetWithIdOnly = await prisma.cryptoAsset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CryptoAsset.
     * @param {CryptoAssetDeleteArgs} args - Arguments to delete one CryptoAsset.
     * @example
     * // Delete one CryptoAsset
     * const CryptoAsset = await prisma.cryptoAsset.delete({
     *   where: {
     *     // ... filter to delete one CryptoAsset
     *   }
     * })
     * 
     */
    delete<T extends CryptoAssetDeleteArgs>(args: SelectSubset<T, CryptoAssetDeleteArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CryptoAsset.
     * @param {CryptoAssetUpdateArgs} args - Arguments to update one CryptoAsset.
     * @example
     * // Update one CryptoAsset
     * const cryptoAsset = await prisma.cryptoAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoAssetUpdateArgs>(args: SelectSubset<T, CryptoAssetUpdateArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CryptoAssets.
     * @param {CryptoAssetDeleteManyArgs} args - Arguments to filter CryptoAssets to delete.
     * @example
     * // Delete a few CryptoAssets
     * const { count } = await prisma.cryptoAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoAssetDeleteManyArgs>(args?: SelectSubset<T, CryptoAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoAssets
     * const cryptoAsset = await prisma.cryptoAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoAssetUpdateManyArgs>(args: SelectSubset<T, CryptoAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoAsset.
     * @param {CryptoAssetUpsertArgs} args - Arguments to update or create a CryptoAsset.
     * @example
     * // Update or create a CryptoAsset
     * const cryptoAsset = await prisma.cryptoAsset.upsert({
     *   create: {
     *     // ... data to create a CryptoAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoAsset we want to update
     *   }
     * })
     */
    upsert<T extends CryptoAssetUpsertArgs>(args: SelectSubset<T, CryptoAssetUpsertArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CryptoAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoAssetCountArgs} args - Arguments to filter CryptoAssets to count.
     * @example
     * // Count the number of CryptoAssets
     * const count = await prisma.cryptoAsset.count({
     *   where: {
     *     // ... the filter for the CryptoAssets we want to count
     *   }
     * })
    **/
    count<T extends CryptoAssetCountArgs>(
      args?: Subset<T, CryptoAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoAssetAggregateArgs>(args: Subset<T, CryptoAssetAggregateArgs>): Prisma.PrismaPromise<GetCryptoAssetAggregateType<T>>

    /**
     * Group by CryptoAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoAssetGroupByArgs['orderBy'] }
        : { orderBy?: CryptoAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoAsset model
   */
  readonly fields: CryptoAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    accounts<T extends CryptoAsset$accountsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoAsset$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    lots<T extends CryptoAsset$lotsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoAsset$lotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoAsset model
   */ 
  interface CryptoAssetFieldRefs {
    readonly id: FieldRef<"CryptoAsset", 'String'>
    readonly companyId: FieldRef<"CryptoAsset", 'String'>
    readonly symbol: FieldRef<"CryptoAsset", 'String'>
    readonly name: FieldRef<"CryptoAsset", 'String'>
    readonly decimals: FieldRef<"CryptoAsset", 'Int'>
    readonly contractAddress: FieldRef<"CryptoAsset", 'String'>
    readonly classification: FieldRef<"CryptoAsset", 'CryptoClassification'>
    readonly coingeckoId: FieldRef<"CryptoAsset", 'String'>
    readonly lastPrice: FieldRef<"CryptoAsset", 'Decimal'>
    readonly lastPriceAt: FieldRef<"CryptoAsset", 'DateTime'>
    readonly isActive: FieldRef<"CryptoAsset", 'Boolean'>
    readonly createdAt: FieldRef<"CryptoAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoAsset findUnique
   */
  export type CryptoAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * Filter, which CryptoAsset to fetch.
     */
    where: CryptoAssetWhereUniqueInput
  }

  /**
   * CryptoAsset findUniqueOrThrow
   */
  export type CryptoAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * Filter, which CryptoAsset to fetch.
     */
    where: CryptoAssetWhereUniqueInput
  }

  /**
   * CryptoAsset findFirst
   */
  export type CryptoAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * Filter, which CryptoAsset to fetch.
     */
    where?: CryptoAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoAssets to fetch.
     */
    orderBy?: CryptoAssetOrderByWithRelationInput | CryptoAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoAssets.
     */
    cursor?: CryptoAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoAssets.
     */
    distinct?: CryptoAssetScalarFieldEnum | CryptoAssetScalarFieldEnum[]
  }

  /**
   * CryptoAsset findFirstOrThrow
   */
  export type CryptoAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * Filter, which CryptoAsset to fetch.
     */
    where?: CryptoAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoAssets to fetch.
     */
    orderBy?: CryptoAssetOrderByWithRelationInput | CryptoAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoAssets.
     */
    cursor?: CryptoAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoAssets.
     */
    distinct?: CryptoAssetScalarFieldEnum | CryptoAssetScalarFieldEnum[]
  }

  /**
   * CryptoAsset findMany
   */
  export type CryptoAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * Filter, which CryptoAssets to fetch.
     */
    where?: CryptoAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoAssets to fetch.
     */
    orderBy?: CryptoAssetOrderByWithRelationInput | CryptoAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoAssets.
     */
    cursor?: CryptoAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoAssets.
     */
    skip?: number
    distinct?: CryptoAssetScalarFieldEnum | CryptoAssetScalarFieldEnum[]
  }

  /**
   * CryptoAsset create
   */
  export type CryptoAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoAsset.
     */
    data: XOR<CryptoAssetCreateInput, CryptoAssetUncheckedCreateInput>
  }

  /**
   * CryptoAsset createMany
   */
  export type CryptoAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoAssets.
     */
    data: CryptoAssetCreateManyInput | CryptoAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoAsset createManyAndReturn
   */
  export type CryptoAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CryptoAssets.
     */
    data: CryptoAssetCreateManyInput | CryptoAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoAsset update
   */
  export type CryptoAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoAsset.
     */
    data: XOR<CryptoAssetUpdateInput, CryptoAssetUncheckedUpdateInput>
    /**
     * Choose, which CryptoAsset to update.
     */
    where: CryptoAssetWhereUniqueInput
  }

  /**
   * CryptoAsset updateMany
   */
  export type CryptoAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoAssets.
     */
    data: XOR<CryptoAssetUpdateManyMutationInput, CryptoAssetUncheckedUpdateManyInput>
    /**
     * Filter which CryptoAssets to update
     */
    where?: CryptoAssetWhereInput
  }

  /**
   * CryptoAsset upsert
   */
  export type CryptoAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoAsset to update in case it exists.
     */
    where: CryptoAssetWhereUniqueInput
    /**
     * In case the CryptoAsset found by the `where` argument doesn't exist, create a new CryptoAsset with this data.
     */
    create: XOR<CryptoAssetCreateInput, CryptoAssetUncheckedCreateInput>
    /**
     * In case the CryptoAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoAssetUpdateInput, CryptoAssetUncheckedUpdateInput>
  }

  /**
   * CryptoAsset delete
   */
  export type CryptoAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
    /**
     * Filter which CryptoAsset to delete.
     */
    where: CryptoAssetWhereUniqueInput
  }

  /**
   * CryptoAsset deleteMany
   */
  export type CryptoAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoAssets to delete
     */
    where?: CryptoAssetWhereInput
  }

  /**
   * CryptoAsset.accounts
   */
  export type CryptoAsset$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * CryptoAsset.lots
   */
  export type CryptoAsset$lotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    where?: CryptoLotWhereInput
    orderBy?: CryptoLotOrderByWithRelationInput | CryptoLotOrderByWithRelationInput[]
    cursor?: CryptoLotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoLotScalarFieldEnum | CryptoLotScalarFieldEnum[]
  }

  /**
   * CryptoAsset without action
   */
  export type CryptoAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoAsset
     */
    select?: CryptoAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoAssetInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    lastSyncBlock: number | null
  }

  export type WalletSumAggregateOutputType = {
    lastSyncBlock: bigint | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    address: string | null
    chain: string | null
    label: string | null
    type: $Enums.WalletType | null
    lastSyncAt: Date | null
    lastSyncBlock: bigint | null
    syncStatus: $Enums.SyncStatus | null
    syncError: string | null
    accountCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    address: string | null
    chain: string | null
    label: string | null
    type: $Enums.WalletType | null
    lastSyncAt: Date | null
    lastSyncBlock: bigint | null
    syncStatus: $Enums.SyncStatus | null
    syncError: string | null
    accountCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    companyId: number
    address: number
    chain: number
    label: number
    type: number
    lastSyncAt: number
    lastSyncBlock: number
    syncStatus: number
    syncError: number
    accountCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    lastSyncBlock?: true
  }

  export type WalletSumAggregateInputType = {
    lastSyncBlock?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    companyId?: true
    address?: true
    chain?: true
    label?: true
    type?: true
    lastSyncAt?: true
    lastSyncBlock?: true
    syncStatus?: true
    syncError?: true
    accountCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    companyId?: true
    address?: true
    chain?: true
    label?: true
    type?: true
    lastSyncAt?: true
    lastSyncBlock?: true
    syncStatus?: true
    syncError?: true
    accountCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    companyId?: true
    address?: true
    chain?: true
    label?: true
    type?: true
    lastSyncAt?: true
    lastSyncBlock?: true
    syncStatus?: true
    syncError?: true
    accountCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    companyId: string
    address: string
    chain: string
    label: string | null
    type: $Enums.WalletType
    lastSyncAt: Date | null
    lastSyncBlock: bigint | null
    syncStatus: $Enums.SyncStatus
    syncError: string | null
    accountCode: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    address?: boolean
    chain?: boolean
    label?: boolean
    type?: boolean
    lastSyncAt?: boolean
    lastSyncBlock?: boolean
    syncStatus?: boolean
    syncError?: boolean
    accountCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    address?: boolean
    chain?: boolean
    label?: boolean
    type?: boolean
    lastSyncAt?: boolean
    lastSyncBlock?: boolean
    syncStatus?: boolean
    syncError?: boolean
    accountCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    companyId?: boolean
    address?: boolean
    chain?: boolean
    label?: boolean
    type?: boolean
    lastSyncAt?: boolean
    lastSyncBlock?: boolean
    syncStatus?: boolean
    syncError?: boolean
    accountCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      transactions: Prisma.$CryptoTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      address: string
      chain: string
      label: string | null
      type: $Enums.WalletType
      lastSyncAt: Date | null
      lastSyncBlock: bigint | null
      syncStatus: $Enums.SyncStatus
      syncError: string | null
      accountCode: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Wallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */ 
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly companyId: FieldRef<"Wallet", 'String'>
    readonly address: FieldRef<"Wallet", 'String'>
    readonly chain: FieldRef<"Wallet", 'String'>
    readonly label: FieldRef<"Wallet", 'String'>
    readonly type: FieldRef<"Wallet", 'WalletType'>
    readonly lastSyncAt: FieldRef<"Wallet", 'DateTime'>
    readonly lastSyncBlock: FieldRef<"Wallet", 'BigInt'>
    readonly syncStatus: FieldRef<"Wallet", 'SyncStatus'>
    readonly syncError: FieldRef<"Wallet", 'String'>
    readonly accountCode: FieldRef<"Wallet", 'String'>
    readonly isActive: FieldRef<"Wallet", 'Boolean'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet.transactions
   */
  export type Wallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    where?: CryptoTransactionWhereInput
    orderBy?: CryptoTransactionOrderByWithRelationInput | CryptoTransactionOrderByWithRelationInput[]
    cursor?: CryptoTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoTransactionScalarFieldEnum | CryptoTransactionScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model ExchangeAccount
   */

  export type AggregateExchangeAccount = {
    _count: ExchangeAccountCountAggregateOutputType | null
    _min: ExchangeAccountMinAggregateOutputType | null
    _max: ExchangeAccountMaxAggregateOutputType | null
  }

  export type ExchangeAccountMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    exchange: string | null
    label: string | null
    apiKey: string | null
    apiSecret: string | null
    isReadOnly: boolean | null
    lastSyncAt: Date | null
    syncStatus: $Enums.SyncStatus | null
    syncError: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExchangeAccountMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    exchange: string | null
    label: string | null
    apiKey: string | null
    apiSecret: string | null
    isReadOnly: boolean | null
    lastSyncAt: Date | null
    syncStatus: $Enums.SyncStatus | null
    syncError: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExchangeAccountCountAggregateOutputType = {
    id: number
    companyId: number
    exchange: number
    label: number
    apiKey: number
    apiSecret: number
    isReadOnly: number
    lastSyncAt: number
    syncStatus: number
    syncError: number
    country: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExchangeAccountMinAggregateInputType = {
    id?: true
    companyId?: true
    exchange?: true
    label?: true
    apiKey?: true
    apiSecret?: true
    isReadOnly?: true
    lastSyncAt?: true
    syncStatus?: true
    syncError?: true
    country?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExchangeAccountMaxAggregateInputType = {
    id?: true
    companyId?: true
    exchange?: true
    label?: true
    apiKey?: true
    apiSecret?: true
    isReadOnly?: true
    lastSyncAt?: true
    syncStatus?: true
    syncError?: true
    country?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExchangeAccountCountAggregateInputType = {
    id?: true
    companyId?: true
    exchange?: true
    label?: true
    apiKey?: true
    apiSecret?: true
    isReadOnly?: true
    lastSyncAt?: true
    syncStatus?: true
    syncError?: true
    country?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExchangeAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeAccount to aggregate.
     */
    where?: ExchangeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeAccounts to fetch.
     */
    orderBy?: ExchangeAccountOrderByWithRelationInput | ExchangeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExchangeAccounts
    **/
    _count?: true | ExchangeAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeAccountMaxAggregateInputType
  }

  export type GetExchangeAccountAggregateType<T extends ExchangeAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangeAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangeAccount[P]>
      : GetScalarType<T[P], AggregateExchangeAccount[P]>
  }




  export type ExchangeAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeAccountWhereInput
    orderBy?: ExchangeAccountOrderByWithAggregationInput | ExchangeAccountOrderByWithAggregationInput[]
    by: ExchangeAccountScalarFieldEnum[] | ExchangeAccountScalarFieldEnum
    having?: ExchangeAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeAccountCountAggregateInputType | true
    _min?: ExchangeAccountMinAggregateInputType
    _max?: ExchangeAccountMaxAggregateInputType
  }

  export type ExchangeAccountGroupByOutputType = {
    id: string
    companyId: string
    exchange: string
    label: string | null
    apiKey: string | null
    apiSecret: string | null
    isReadOnly: boolean
    lastSyncAt: Date | null
    syncStatus: $Enums.SyncStatus
    syncError: string | null
    country: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExchangeAccountCountAggregateOutputType | null
    _min: ExchangeAccountMinAggregateOutputType | null
    _max: ExchangeAccountMaxAggregateOutputType | null
  }

  type GetExchangeAccountGroupByPayload<T extends ExchangeAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangeAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeAccountGroupByOutputType[P]>
        }
      >
    >


  export type ExchangeAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    exchange?: boolean
    label?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    isReadOnly?: boolean
    lastSyncAt?: boolean
    syncStatus?: boolean
    syncError?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeAccount"]>

  export type ExchangeAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    exchange?: boolean
    label?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    isReadOnly?: boolean
    lastSyncAt?: boolean
    syncStatus?: boolean
    syncError?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeAccount"]>

  export type ExchangeAccountSelectScalar = {
    id?: boolean
    companyId?: boolean
    exchange?: boolean
    label?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    isReadOnly?: boolean
    lastSyncAt?: boolean
    syncStatus?: boolean
    syncError?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExchangeAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ExchangeAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ExchangeAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExchangeAccount"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      exchange: string
      label: string | null
      apiKey: string | null
      apiSecret: string | null
      isReadOnly: boolean
      lastSyncAt: Date | null
      syncStatus: $Enums.SyncStatus
      syncError: string | null
      country: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exchangeAccount"]>
    composites: {}
  }

  type ExchangeAccountGetPayload<S extends boolean | null | undefined | ExchangeAccountDefaultArgs> = $Result.GetResult<Prisma.$ExchangeAccountPayload, S>

  type ExchangeAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExchangeAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExchangeAccountCountAggregateInputType | true
    }

  export interface ExchangeAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExchangeAccount'], meta: { name: 'ExchangeAccount' } }
    /**
     * Find zero or one ExchangeAccount that matches the filter.
     * @param {ExchangeAccountFindUniqueArgs} args - Arguments to find a ExchangeAccount
     * @example
     * // Get one ExchangeAccount
     * const exchangeAccount = await prisma.exchangeAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangeAccountFindUniqueArgs>(args: SelectSubset<T, ExchangeAccountFindUniqueArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExchangeAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExchangeAccountFindUniqueOrThrowArgs} args - Arguments to find a ExchangeAccount
     * @example
     * // Get one ExchangeAccount
     * const exchangeAccount = await prisma.exchangeAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangeAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangeAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExchangeAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeAccountFindFirstArgs} args - Arguments to find a ExchangeAccount
     * @example
     * // Get one ExchangeAccount
     * const exchangeAccount = await prisma.exchangeAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangeAccountFindFirstArgs>(args?: SelectSubset<T, ExchangeAccountFindFirstArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExchangeAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeAccountFindFirstOrThrowArgs} args - Arguments to find a ExchangeAccount
     * @example
     * // Get one ExchangeAccount
     * const exchangeAccount = await prisma.exchangeAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangeAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangeAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExchangeAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangeAccounts
     * const exchangeAccounts = await prisma.exchangeAccount.findMany()
     * 
     * // Get first 10 ExchangeAccounts
     * const exchangeAccounts = await prisma.exchangeAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangeAccountWithIdOnly = await prisma.exchangeAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangeAccountFindManyArgs>(args?: SelectSubset<T, ExchangeAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExchangeAccount.
     * @param {ExchangeAccountCreateArgs} args - Arguments to create a ExchangeAccount.
     * @example
     * // Create one ExchangeAccount
     * const ExchangeAccount = await prisma.exchangeAccount.create({
     *   data: {
     *     // ... data to create a ExchangeAccount
     *   }
     * })
     * 
     */
    create<T extends ExchangeAccountCreateArgs>(args: SelectSubset<T, ExchangeAccountCreateArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExchangeAccounts.
     * @param {ExchangeAccountCreateManyArgs} args - Arguments to create many ExchangeAccounts.
     * @example
     * // Create many ExchangeAccounts
     * const exchangeAccount = await prisma.exchangeAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangeAccountCreateManyArgs>(args?: SelectSubset<T, ExchangeAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExchangeAccounts and returns the data saved in the database.
     * @param {ExchangeAccountCreateManyAndReturnArgs} args - Arguments to create many ExchangeAccounts.
     * @example
     * // Create many ExchangeAccounts
     * const exchangeAccount = await prisma.exchangeAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExchangeAccounts and only return the `id`
     * const exchangeAccountWithIdOnly = await prisma.exchangeAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangeAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangeAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExchangeAccount.
     * @param {ExchangeAccountDeleteArgs} args - Arguments to delete one ExchangeAccount.
     * @example
     * // Delete one ExchangeAccount
     * const ExchangeAccount = await prisma.exchangeAccount.delete({
     *   where: {
     *     // ... filter to delete one ExchangeAccount
     *   }
     * })
     * 
     */
    delete<T extends ExchangeAccountDeleteArgs>(args: SelectSubset<T, ExchangeAccountDeleteArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExchangeAccount.
     * @param {ExchangeAccountUpdateArgs} args - Arguments to update one ExchangeAccount.
     * @example
     * // Update one ExchangeAccount
     * const exchangeAccount = await prisma.exchangeAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangeAccountUpdateArgs>(args: SelectSubset<T, ExchangeAccountUpdateArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExchangeAccounts.
     * @param {ExchangeAccountDeleteManyArgs} args - Arguments to filter ExchangeAccounts to delete.
     * @example
     * // Delete a few ExchangeAccounts
     * const { count } = await prisma.exchangeAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangeAccountDeleteManyArgs>(args?: SelectSubset<T, ExchangeAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangeAccounts
     * const exchangeAccount = await prisma.exchangeAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangeAccountUpdateManyArgs>(args: SelectSubset<T, ExchangeAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExchangeAccount.
     * @param {ExchangeAccountUpsertArgs} args - Arguments to update or create a ExchangeAccount.
     * @example
     * // Update or create a ExchangeAccount
     * const exchangeAccount = await prisma.exchangeAccount.upsert({
     *   create: {
     *     // ... data to create a ExchangeAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangeAccount we want to update
     *   }
     * })
     */
    upsert<T extends ExchangeAccountUpsertArgs>(args: SelectSubset<T, ExchangeAccountUpsertArgs<ExtArgs>>): Prisma__ExchangeAccountClient<$Result.GetResult<Prisma.$ExchangeAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExchangeAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeAccountCountArgs} args - Arguments to filter ExchangeAccounts to count.
     * @example
     * // Count the number of ExchangeAccounts
     * const count = await prisma.exchangeAccount.count({
     *   where: {
     *     // ... the filter for the ExchangeAccounts we want to count
     *   }
     * })
    **/
    count<T extends ExchangeAccountCountArgs>(
      args?: Subset<T, ExchangeAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangeAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeAccountAggregateArgs>(args: Subset<T, ExchangeAccountAggregateArgs>): Prisma.PrismaPromise<GetExchangeAccountAggregateType<T>>

    /**
     * Group by ExchangeAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangeAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangeAccountGroupByArgs['orderBy'] }
        : { orderBy?: ExchangeAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangeAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExchangeAccount model
   */
  readonly fields: ExchangeAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExchangeAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangeAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExchangeAccount model
   */ 
  interface ExchangeAccountFieldRefs {
    readonly id: FieldRef<"ExchangeAccount", 'String'>
    readonly companyId: FieldRef<"ExchangeAccount", 'String'>
    readonly exchange: FieldRef<"ExchangeAccount", 'String'>
    readonly label: FieldRef<"ExchangeAccount", 'String'>
    readonly apiKey: FieldRef<"ExchangeAccount", 'String'>
    readonly apiSecret: FieldRef<"ExchangeAccount", 'String'>
    readonly isReadOnly: FieldRef<"ExchangeAccount", 'Boolean'>
    readonly lastSyncAt: FieldRef<"ExchangeAccount", 'DateTime'>
    readonly syncStatus: FieldRef<"ExchangeAccount", 'SyncStatus'>
    readonly syncError: FieldRef<"ExchangeAccount", 'String'>
    readonly country: FieldRef<"ExchangeAccount", 'String'>
    readonly isActive: FieldRef<"ExchangeAccount", 'Boolean'>
    readonly createdAt: FieldRef<"ExchangeAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"ExchangeAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExchangeAccount findUnique
   */
  export type ExchangeAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeAccount to fetch.
     */
    where: ExchangeAccountWhereUniqueInput
  }

  /**
   * ExchangeAccount findUniqueOrThrow
   */
  export type ExchangeAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeAccount to fetch.
     */
    where: ExchangeAccountWhereUniqueInput
  }

  /**
   * ExchangeAccount findFirst
   */
  export type ExchangeAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeAccount to fetch.
     */
    where?: ExchangeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeAccounts to fetch.
     */
    orderBy?: ExchangeAccountOrderByWithRelationInput | ExchangeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeAccounts.
     */
    cursor?: ExchangeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeAccounts.
     */
    distinct?: ExchangeAccountScalarFieldEnum | ExchangeAccountScalarFieldEnum[]
  }

  /**
   * ExchangeAccount findFirstOrThrow
   */
  export type ExchangeAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeAccount to fetch.
     */
    where?: ExchangeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeAccounts to fetch.
     */
    orderBy?: ExchangeAccountOrderByWithRelationInput | ExchangeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeAccounts.
     */
    cursor?: ExchangeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeAccounts.
     */
    distinct?: ExchangeAccountScalarFieldEnum | ExchangeAccountScalarFieldEnum[]
  }

  /**
   * ExchangeAccount findMany
   */
  export type ExchangeAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeAccounts to fetch.
     */
    where?: ExchangeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeAccounts to fetch.
     */
    orderBy?: ExchangeAccountOrderByWithRelationInput | ExchangeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExchangeAccounts.
     */
    cursor?: ExchangeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeAccounts.
     */
    skip?: number
    distinct?: ExchangeAccountScalarFieldEnum | ExchangeAccountScalarFieldEnum[]
  }

  /**
   * ExchangeAccount create
   */
  export type ExchangeAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ExchangeAccount.
     */
    data: XOR<ExchangeAccountCreateInput, ExchangeAccountUncheckedCreateInput>
  }

  /**
   * ExchangeAccount createMany
   */
  export type ExchangeAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExchangeAccounts.
     */
    data: ExchangeAccountCreateManyInput | ExchangeAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangeAccount createManyAndReturn
   */
  export type ExchangeAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExchangeAccounts.
     */
    data: ExchangeAccountCreateManyInput | ExchangeAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangeAccount update
   */
  export type ExchangeAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ExchangeAccount.
     */
    data: XOR<ExchangeAccountUpdateInput, ExchangeAccountUncheckedUpdateInput>
    /**
     * Choose, which ExchangeAccount to update.
     */
    where: ExchangeAccountWhereUniqueInput
  }

  /**
   * ExchangeAccount updateMany
   */
  export type ExchangeAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExchangeAccounts.
     */
    data: XOR<ExchangeAccountUpdateManyMutationInput, ExchangeAccountUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeAccounts to update
     */
    where?: ExchangeAccountWhereInput
  }

  /**
   * ExchangeAccount upsert
   */
  export type ExchangeAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ExchangeAccount to update in case it exists.
     */
    where: ExchangeAccountWhereUniqueInput
    /**
     * In case the ExchangeAccount found by the `where` argument doesn't exist, create a new ExchangeAccount with this data.
     */
    create: XOR<ExchangeAccountCreateInput, ExchangeAccountUncheckedCreateInput>
    /**
     * In case the ExchangeAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangeAccountUpdateInput, ExchangeAccountUncheckedUpdateInput>
  }

  /**
   * ExchangeAccount delete
   */
  export type ExchangeAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
    /**
     * Filter which ExchangeAccount to delete.
     */
    where: ExchangeAccountWhereUniqueInput
  }

  /**
   * ExchangeAccount deleteMany
   */
  export type ExchangeAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeAccounts to delete
     */
    where?: ExchangeAccountWhereInput
  }

  /**
   * ExchangeAccount without action
   */
  export type ExchangeAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeAccount
     */
    select?: ExchangeAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeAccountInclude<ExtArgs> | null
  }


  /**
   * Model CryptoTransaction
   */

  export type AggregateCryptoTransaction = {
    _count: CryptoTransactionCountAggregateOutputType | null
    _avg: CryptoTransactionAvgAggregateOutputType | null
    _sum: CryptoTransactionSumAggregateOutputType | null
    _min: CryptoTransactionMinAggregateOutputType | null
    _max: CryptoTransactionMaxAggregateOutputType | null
  }

  export type CryptoTransactionAvgAggregateOutputType = {
    blockNumber: number | null
    amountIn: Decimal | null
    amountOut: Decimal | null
    feeAmount: Decimal | null
    priceInEur: Decimal | null
    priceOutEur: Decimal | null
    feeEur: Decimal | null
    costBasis: Decimal | null
    realizedGain: Decimal | null
    aiConfidence: Decimal | null
  }

  export type CryptoTransactionSumAggregateOutputType = {
    blockNumber: bigint | null
    amountIn: Decimal | null
    amountOut: Decimal | null
    feeAmount: Decimal | null
    priceInEur: Decimal | null
    priceOutEur: Decimal | null
    feeEur: Decimal | null
    costBasis: Decimal | null
    realizedGain: Decimal | null
    aiConfidence: Decimal | null
  }

  export type CryptoTransactionMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    txHash: string | null
    blockNumber: bigint | null
    blockTimestamp: Date | null
    chain: string | null
    type: $Enums.CryptoTxType | null
    subtype: string | null
    assetIn: string | null
    amountIn: Decimal | null
    assetOut: string | null
    amountOut: Decimal | null
    feeAsset: string | null
    feeAmount: Decimal | null
    priceInEur: Decimal | null
    priceOutEur: Decimal | null
    feeEur: Decimal | null
    costBasis: Decimal | null
    realizedGain: Decimal | null
    aiCategorized: boolean | null
    aiConfidence: Decimal | null
    aiReasoning: string | null
    manualType: $Enums.CryptoTxType | null
    manualNotes: string | null
    journalEntryId: string | null
    status: $Enums.TxStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoTransactionMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    txHash: string | null
    blockNumber: bigint | null
    blockTimestamp: Date | null
    chain: string | null
    type: $Enums.CryptoTxType | null
    subtype: string | null
    assetIn: string | null
    amountIn: Decimal | null
    assetOut: string | null
    amountOut: Decimal | null
    feeAsset: string | null
    feeAmount: Decimal | null
    priceInEur: Decimal | null
    priceOutEur: Decimal | null
    feeEur: Decimal | null
    costBasis: Decimal | null
    realizedGain: Decimal | null
    aiCategorized: boolean | null
    aiConfidence: Decimal | null
    aiReasoning: string | null
    manualType: $Enums.CryptoTxType | null
    manualNotes: string | null
    journalEntryId: string | null
    status: $Enums.TxStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoTransactionCountAggregateOutputType = {
    id: number
    walletId: number
    txHash: number
    blockNumber: number
    blockTimestamp: number
    chain: number
    type: number
    subtype: number
    assetIn: number
    amountIn: number
    assetOut: number
    amountOut: number
    feeAsset: number
    feeAmount: number
    priceInEur: number
    priceOutEur: number
    feeEur: number
    costBasis: number
    realizedGain: number
    aiCategorized: number
    aiConfidence: number
    aiReasoning: number
    manualType: number
    manualNotes: number
    journalEntryId: number
    status: number
    rawData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoTransactionAvgAggregateInputType = {
    blockNumber?: true
    amountIn?: true
    amountOut?: true
    feeAmount?: true
    priceInEur?: true
    priceOutEur?: true
    feeEur?: true
    costBasis?: true
    realizedGain?: true
    aiConfidence?: true
  }

  export type CryptoTransactionSumAggregateInputType = {
    blockNumber?: true
    amountIn?: true
    amountOut?: true
    feeAmount?: true
    priceInEur?: true
    priceOutEur?: true
    feeEur?: true
    costBasis?: true
    realizedGain?: true
    aiConfidence?: true
  }

  export type CryptoTransactionMinAggregateInputType = {
    id?: true
    walletId?: true
    txHash?: true
    blockNumber?: true
    blockTimestamp?: true
    chain?: true
    type?: true
    subtype?: true
    assetIn?: true
    amountIn?: true
    assetOut?: true
    amountOut?: true
    feeAsset?: true
    feeAmount?: true
    priceInEur?: true
    priceOutEur?: true
    feeEur?: true
    costBasis?: true
    realizedGain?: true
    aiCategorized?: true
    aiConfidence?: true
    aiReasoning?: true
    manualType?: true
    manualNotes?: true
    journalEntryId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoTransactionMaxAggregateInputType = {
    id?: true
    walletId?: true
    txHash?: true
    blockNumber?: true
    blockTimestamp?: true
    chain?: true
    type?: true
    subtype?: true
    assetIn?: true
    amountIn?: true
    assetOut?: true
    amountOut?: true
    feeAsset?: true
    feeAmount?: true
    priceInEur?: true
    priceOutEur?: true
    feeEur?: true
    costBasis?: true
    realizedGain?: true
    aiCategorized?: true
    aiConfidence?: true
    aiReasoning?: true
    manualType?: true
    manualNotes?: true
    journalEntryId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoTransactionCountAggregateInputType = {
    id?: true
    walletId?: true
    txHash?: true
    blockNumber?: true
    blockTimestamp?: true
    chain?: true
    type?: true
    subtype?: true
    assetIn?: true
    amountIn?: true
    assetOut?: true
    amountOut?: true
    feeAsset?: true
    feeAmount?: true
    priceInEur?: true
    priceOutEur?: true
    feeEur?: true
    costBasis?: true
    realizedGain?: true
    aiCategorized?: true
    aiConfidence?: true
    aiReasoning?: true
    manualType?: true
    manualNotes?: true
    journalEntryId?: true
    status?: true
    rawData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoTransaction to aggregate.
     */
    where?: CryptoTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTransactions to fetch.
     */
    orderBy?: CryptoTransactionOrderByWithRelationInput | CryptoTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoTransactions
    **/
    _count?: true | CryptoTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoTransactionMaxAggregateInputType
  }

  export type GetCryptoTransactionAggregateType<T extends CryptoTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoTransaction[P]>
      : GetScalarType<T[P], AggregateCryptoTransaction[P]>
  }




  export type CryptoTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoTransactionWhereInput
    orderBy?: CryptoTransactionOrderByWithAggregationInput | CryptoTransactionOrderByWithAggregationInput[]
    by: CryptoTransactionScalarFieldEnum[] | CryptoTransactionScalarFieldEnum
    having?: CryptoTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoTransactionCountAggregateInputType | true
    _avg?: CryptoTransactionAvgAggregateInputType
    _sum?: CryptoTransactionSumAggregateInputType
    _min?: CryptoTransactionMinAggregateInputType
    _max?: CryptoTransactionMaxAggregateInputType
  }

  export type CryptoTransactionGroupByOutputType = {
    id: string
    walletId: string
    txHash: string
    blockNumber: bigint
    blockTimestamp: Date
    chain: string
    type: $Enums.CryptoTxType
    subtype: string | null
    assetIn: string | null
    amountIn: Decimal | null
    assetOut: string | null
    amountOut: Decimal | null
    feeAsset: string | null
    feeAmount: Decimal | null
    priceInEur: Decimal | null
    priceOutEur: Decimal | null
    feeEur: Decimal | null
    costBasis: Decimal | null
    realizedGain: Decimal | null
    aiCategorized: boolean
    aiConfidence: Decimal | null
    aiReasoning: string | null
    manualType: $Enums.CryptoTxType | null
    manualNotes: string | null
    journalEntryId: string | null
    status: $Enums.TxStatus
    rawData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CryptoTransactionCountAggregateOutputType | null
    _avg: CryptoTransactionAvgAggregateOutputType | null
    _sum: CryptoTransactionSumAggregateOutputType | null
    _min: CryptoTransactionMinAggregateOutputType | null
    _max: CryptoTransactionMaxAggregateOutputType | null
  }

  type GetCryptoTransactionGroupByPayload<T extends CryptoTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CryptoTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    txHash?: boolean
    blockNumber?: boolean
    blockTimestamp?: boolean
    chain?: boolean
    type?: boolean
    subtype?: boolean
    assetIn?: boolean
    amountIn?: boolean
    assetOut?: boolean
    amountOut?: boolean
    feeAsset?: boolean
    feeAmount?: boolean
    priceInEur?: boolean
    priceOutEur?: boolean
    feeEur?: boolean
    costBasis?: boolean
    realizedGain?: boolean
    aiCategorized?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    manualType?: boolean
    manualNotes?: boolean
    journalEntryId?: boolean
    status?: boolean
    rawData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoTransaction"]>

  export type CryptoTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    txHash?: boolean
    blockNumber?: boolean
    blockTimestamp?: boolean
    chain?: boolean
    type?: boolean
    subtype?: boolean
    assetIn?: boolean
    amountIn?: boolean
    assetOut?: boolean
    amountOut?: boolean
    feeAsset?: boolean
    feeAmount?: boolean
    priceInEur?: boolean
    priceOutEur?: boolean
    feeEur?: boolean
    costBasis?: boolean
    realizedGain?: boolean
    aiCategorized?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    manualType?: boolean
    manualNotes?: boolean
    journalEntryId?: boolean
    status?: boolean
    rawData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoTransaction"]>

  export type CryptoTransactionSelectScalar = {
    id?: boolean
    walletId?: boolean
    txHash?: boolean
    blockNumber?: boolean
    blockTimestamp?: boolean
    chain?: boolean
    type?: boolean
    subtype?: boolean
    assetIn?: boolean
    amountIn?: boolean
    assetOut?: boolean
    amountOut?: boolean
    feeAsset?: boolean
    feeAmount?: boolean
    priceInEur?: boolean
    priceOutEur?: boolean
    feeEur?: boolean
    costBasis?: boolean
    realizedGain?: boolean
    aiCategorized?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    manualType?: boolean
    manualNotes?: boolean
    journalEntryId?: boolean
    status?: boolean
    rawData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type CryptoTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }

  export type $CryptoTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoTransaction"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      txHash: string
      blockNumber: bigint
      blockTimestamp: Date
      chain: string
      type: $Enums.CryptoTxType
      subtype: string | null
      assetIn: string | null
      amountIn: Prisma.Decimal | null
      assetOut: string | null
      amountOut: Prisma.Decimal | null
      feeAsset: string | null
      feeAmount: Prisma.Decimal | null
      priceInEur: Prisma.Decimal | null
      priceOutEur: Prisma.Decimal | null
      feeEur: Prisma.Decimal | null
      costBasis: Prisma.Decimal | null
      realizedGain: Prisma.Decimal | null
      aiCategorized: boolean
      aiConfidence: Prisma.Decimal | null
      aiReasoning: string | null
      manualType: $Enums.CryptoTxType | null
      manualNotes: string | null
      journalEntryId: string | null
      status: $Enums.TxStatus
      rawData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoTransaction"]>
    composites: {}
  }

  type CryptoTransactionGetPayload<S extends boolean | null | undefined | CryptoTransactionDefaultArgs> = $Result.GetResult<Prisma.$CryptoTransactionPayload, S>

  type CryptoTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CryptoTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CryptoTransactionCountAggregateInputType | true
    }

  export interface CryptoTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoTransaction'], meta: { name: 'CryptoTransaction' } }
    /**
     * Find zero or one CryptoTransaction that matches the filter.
     * @param {CryptoTransactionFindUniqueArgs} args - Arguments to find a CryptoTransaction
     * @example
     * // Get one CryptoTransaction
     * const cryptoTransaction = await prisma.cryptoTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoTransactionFindUniqueArgs>(args: SelectSubset<T, CryptoTransactionFindUniqueArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CryptoTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CryptoTransactionFindUniqueOrThrowArgs} args - Arguments to find a CryptoTransaction
     * @example
     * // Get one CryptoTransaction
     * const cryptoTransaction = await prisma.cryptoTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CryptoTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTransactionFindFirstArgs} args - Arguments to find a CryptoTransaction
     * @example
     * // Get one CryptoTransaction
     * const cryptoTransaction = await prisma.cryptoTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoTransactionFindFirstArgs>(args?: SelectSubset<T, CryptoTransactionFindFirstArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CryptoTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTransactionFindFirstOrThrowArgs} args - Arguments to find a CryptoTransaction
     * @example
     * // Get one CryptoTransaction
     * const cryptoTransaction = await prisma.cryptoTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CryptoTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoTransactions
     * const cryptoTransactions = await prisma.cryptoTransaction.findMany()
     * 
     * // Get first 10 CryptoTransactions
     * const cryptoTransactions = await prisma.cryptoTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoTransactionWithIdOnly = await prisma.cryptoTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoTransactionFindManyArgs>(args?: SelectSubset<T, CryptoTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CryptoTransaction.
     * @param {CryptoTransactionCreateArgs} args - Arguments to create a CryptoTransaction.
     * @example
     * // Create one CryptoTransaction
     * const CryptoTransaction = await prisma.cryptoTransaction.create({
     *   data: {
     *     // ... data to create a CryptoTransaction
     *   }
     * })
     * 
     */
    create<T extends CryptoTransactionCreateArgs>(args: SelectSubset<T, CryptoTransactionCreateArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CryptoTransactions.
     * @param {CryptoTransactionCreateManyArgs} args - Arguments to create many CryptoTransactions.
     * @example
     * // Create many CryptoTransactions
     * const cryptoTransaction = await prisma.cryptoTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoTransactionCreateManyArgs>(args?: SelectSubset<T, CryptoTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoTransactions and returns the data saved in the database.
     * @param {CryptoTransactionCreateManyAndReturnArgs} args - Arguments to create many CryptoTransactions.
     * @example
     * // Create many CryptoTransactions
     * const cryptoTransaction = await prisma.cryptoTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoTransactions and only return the `id`
     * const cryptoTransactionWithIdOnly = await prisma.cryptoTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CryptoTransaction.
     * @param {CryptoTransactionDeleteArgs} args - Arguments to delete one CryptoTransaction.
     * @example
     * // Delete one CryptoTransaction
     * const CryptoTransaction = await prisma.cryptoTransaction.delete({
     *   where: {
     *     // ... filter to delete one CryptoTransaction
     *   }
     * })
     * 
     */
    delete<T extends CryptoTransactionDeleteArgs>(args: SelectSubset<T, CryptoTransactionDeleteArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CryptoTransaction.
     * @param {CryptoTransactionUpdateArgs} args - Arguments to update one CryptoTransaction.
     * @example
     * // Update one CryptoTransaction
     * const cryptoTransaction = await prisma.cryptoTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoTransactionUpdateArgs>(args: SelectSubset<T, CryptoTransactionUpdateArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CryptoTransactions.
     * @param {CryptoTransactionDeleteManyArgs} args - Arguments to filter CryptoTransactions to delete.
     * @example
     * // Delete a few CryptoTransactions
     * const { count } = await prisma.cryptoTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoTransactionDeleteManyArgs>(args?: SelectSubset<T, CryptoTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoTransactions
     * const cryptoTransaction = await prisma.cryptoTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoTransactionUpdateManyArgs>(args: SelectSubset<T, CryptoTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoTransaction.
     * @param {CryptoTransactionUpsertArgs} args - Arguments to update or create a CryptoTransaction.
     * @example
     * // Update or create a CryptoTransaction
     * const cryptoTransaction = await prisma.cryptoTransaction.upsert({
     *   create: {
     *     // ... data to create a CryptoTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CryptoTransactionUpsertArgs>(args: SelectSubset<T, CryptoTransactionUpsertArgs<ExtArgs>>): Prisma__CryptoTransactionClient<$Result.GetResult<Prisma.$CryptoTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CryptoTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTransactionCountArgs} args - Arguments to filter CryptoTransactions to count.
     * @example
     * // Count the number of CryptoTransactions
     * const count = await prisma.cryptoTransaction.count({
     *   where: {
     *     // ... the filter for the CryptoTransactions we want to count
     *   }
     * })
    **/
    count<T extends CryptoTransactionCountArgs>(
      args?: Subset<T, CryptoTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoTransactionAggregateArgs>(args: Subset<T, CryptoTransactionAggregateArgs>): Prisma.PrismaPromise<GetCryptoTransactionAggregateType<T>>

    /**
     * Group by CryptoTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CryptoTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoTransaction model
   */
  readonly fields: CryptoTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoTransaction model
   */ 
  interface CryptoTransactionFieldRefs {
    readonly id: FieldRef<"CryptoTransaction", 'String'>
    readonly walletId: FieldRef<"CryptoTransaction", 'String'>
    readonly txHash: FieldRef<"CryptoTransaction", 'String'>
    readonly blockNumber: FieldRef<"CryptoTransaction", 'BigInt'>
    readonly blockTimestamp: FieldRef<"CryptoTransaction", 'DateTime'>
    readonly chain: FieldRef<"CryptoTransaction", 'String'>
    readonly type: FieldRef<"CryptoTransaction", 'CryptoTxType'>
    readonly subtype: FieldRef<"CryptoTransaction", 'String'>
    readonly assetIn: FieldRef<"CryptoTransaction", 'String'>
    readonly amountIn: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly assetOut: FieldRef<"CryptoTransaction", 'String'>
    readonly amountOut: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly feeAsset: FieldRef<"CryptoTransaction", 'String'>
    readonly feeAmount: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly priceInEur: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly priceOutEur: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly feeEur: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly costBasis: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly realizedGain: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly aiCategorized: FieldRef<"CryptoTransaction", 'Boolean'>
    readonly aiConfidence: FieldRef<"CryptoTransaction", 'Decimal'>
    readonly aiReasoning: FieldRef<"CryptoTransaction", 'String'>
    readonly manualType: FieldRef<"CryptoTransaction", 'CryptoTxType'>
    readonly manualNotes: FieldRef<"CryptoTransaction", 'String'>
    readonly journalEntryId: FieldRef<"CryptoTransaction", 'String'>
    readonly status: FieldRef<"CryptoTransaction", 'TxStatus'>
    readonly rawData: FieldRef<"CryptoTransaction", 'Json'>
    readonly createdAt: FieldRef<"CryptoTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoTransaction findUnique
   */
  export type CryptoTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTransaction to fetch.
     */
    where: CryptoTransactionWhereUniqueInput
  }

  /**
   * CryptoTransaction findUniqueOrThrow
   */
  export type CryptoTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTransaction to fetch.
     */
    where: CryptoTransactionWhereUniqueInput
  }

  /**
   * CryptoTransaction findFirst
   */
  export type CryptoTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTransaction to fetch.
     */
    where?: CryptoTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTransactions to fetch.
     */
    orderBy?: CryptoTransactionOrderByWithRelationInput | CryptoTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTransactions.
     */
    cursor?: CryptoTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTransactions.
     */
    distinct?: CryptoTransactionScalarFieldEnum | CryptoTransactionScalarFieldEnum[]
  }

  /**
   * CryptoTransaction findFirstOrThrow
   */
  export type CryptoTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTransaction to fetch.
     */
    where?: CryptoTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTransactions to fetch.
     */
    orderBy?: CryptoTransactionOrderByWithRelationInput | CryptoTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTransactions.
     */
    cursor?: CryptoTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTransactions.
     */
    distinct?: CryptoTransactionScalarFieldEnum | CryptoTransactionScalarFieldEnum[]
  }

  /**
   * CryptoTransaction findMany
   */
  export type CryptoTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTransactions to fetch.
     */
    where?: CryptoTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTransactions to fetch.
     */
    orderBy?: CryptoTransactionOrderByWithRelationInput | CryptoTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoTransactions.
     */
    cursor?: CryptoTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTransactions.
     */
    skip?: number
    distinct?: CryptoTransactionScalarFieldEnum | CryptoTransactionScalarFieldEnum[]
  }

  /**
   * CryptoTransaction create
   */
  export type CryptoTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoTransaction.
     */
    data: XOR<CryptoTransactionCreateInput, CryptoTransactionUncheckedCreateInput>
  }

  /**
   * CryptoTransaction createMany
   */
  export type CryptoTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoTransactions.
     */
    data: CryptoTransactionCreateManyInput | CryptoTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoTransaction createManyAndReturn
   */
  export type CryptoTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CryptoTransactions.
     */
    data: CryptoTransactionCreateManyInput | CryptoTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoTransaction update
   */
  export type CryptoTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoTransaction.
     */
    data: XOR<CryptoTransactionUpdateInput, CryptoTransactionUncheckedUpdateInput>
    /**
     * Choose, which CryptoTransaction to update.
     */
    where: CryptoTransactionWhereUniqueInput
  }

  /**
   * CryptoTransaction updateMany
   */
  export type CryptoTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoTransactions.
     */
    data: XOR<CryptoTransactionUpdateManyMutationInput, CryptoTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CryptoTransactions to update
     */
    where?: CryptoTransactionWhereInput
  }

  /**
   * CryptoTransaction upsert
   */
  export type CryptoTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoTransaction to update in case it exists.
     */
    where: CryptoTransactionWhereUniqueInput
    /**
     * In case the CryptoTransaction found by the `where` argument doesn't exist, create a new CryptoTransaction with this data.
     */
    create: XOR<CryptoTransactionCreateInput, CryptoTransactionUncheckedCreateInput>
    /**
     * In case the CryptoTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoTransactionUpdateInput, CryptoTransactionUncheckedUpdateInput>
  }

  /**
   * CryptoTransaction delete
   */
  export type CryptoTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
    /**
     * Filter which CryptoTransaction to delete.
     */
    where: CryptoTransactionWhereUniqueInput
  }

  /**
   * CryptoTransaction deleteMany
   */
  export type CryptoTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoTransactions to delete
     */
    where?: CryptoTransactionWhereInput
  }

  /**
   * CryptoTransaction without action
   */
  export type CryptoTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTransaction
     */
    select?: CryptoTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTransactionInclude<ExtArgs> | null
  }


  /**
   * Model CryptoLot
   */

  export type AggregateCryptoLot = {
    _count: CryptoLotCountAggregateOutputType | null
    _avg: CryptoLotAvgAggregateOutputType | null
    _sum: CryptoLotSumAggregateOutputType | null
    _min: CryptoLotMinAggregateOutputType | null
    _max: CryptoLotMaxAggregateOutputType | null
  }

  export type CryptoLotAvgAggregateOutputType = {
    acquiredAmount: Decimal | null
    costBasisEur: Decimal | null
    costPerUnit: Decimal | null
    remainingAmount: Decimal | null
  }

  export type CryptoLotSumAggregateOutputType = {
    acquiredAmount: Decimal | null
    costBasisEur: Decimal | null
    costPerUnit: Decimal | null
    remainingAmount: Decimal | null
  }

  export type CryptoLotMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    cryptoAssetId: string | null
    acquiredAt: Date | null
    acquiredAmount: Decimal | null
    costBasisEur: Decimal | null
    costPerUnit: Decimal | null
    remainingAmount: Decimal | null
    sourceTxId: string | null
    sourceType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoLotMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    cryptoAssetId: string | null
    acquiredAt: Date | null
    acquiredAmount: Decimal | null
    costBasisEur: Decimal | null
    costPerUnit: Decimal | null
    remainingAmount: Decimal | null
    sourceTxId: string | null
    sourceType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoLotCountAggregateOutputType = {
    id: number
    companyId: number
    cryptoAssetId: number
    acquiredAt: number
    acquiredAmount: number
    costBasisEur: number
    costPerUnit: number
    remainingAmount: number
    sourceTxId: number
    sourceType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoLotAvgAggregateInputType = {
    acquiredAmount?: true
    costBasisEur?: true
    costPerUnit?: true
    remainingAmount?: true
  }

  export type CryptoLotSumAggregateInputType = {
    acquiredAmount?: true
    costBasisEur?: true
    costPerUnit?: true
    remainingAmount?: true
  }

  export type CryptoLotMinAggregateInputType = {
    id?: true
    companyId?: true
    cryptoAssetId?: true
    acquiredAt?: true
    acquiredAmount?: true
    costBasisEur?: true
    costPerUnit?: true
    remainingAmount?: true
    sourceTxId?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoLotMaxAggregateInputType = {
    id?: true
    companyId?: true
    cryptoAssetId?: true
    acquiredAt?: true
    acquiredAmount?: true
    costBasisEur?: true
    costPerUnit?: true
    remainingAmount?: true
    sourceTxId?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoLotCountAggregateInputType = {
    id?: true
    companyId?: true
    cryptoAssetId?: true
    acquiredAt?: true
    acquiredAmount?: true
    costBasisEur?: true
    costPerUnit?: true
    remainingAmount?: true
    sourceTxId?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoLotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoLot to aggregate.
     */
    where?: CryptoLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLots to fetch.
     */
    orderBy?: CryptoLotOrderByWithRelationInput | CryptoLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoLots
    **/
    _count?: true | CryptoLotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoLotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoLotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoLotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoLotMaxAggregateInputType
  }

  export type GetCryptoLotAggregateType<T extends CryptoLotAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoLot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoLot[P]>
      : GetScalarType<T[P], AggregateCryptoLot[P]>
  }




  export type CryptoLotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoLotWhereInput
    orderBy?: CryptoLotOrderByWithAggregationInput | CryptoLotOrderByWithAggregationInput[]
    by: CryptoLotScalarFieldEnum[] | CryptoLotScalarFieldEnum
    having?: CryptoLotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoLotCountAggregateInputType | true
    _avg?: CryptoLotAvgAggregateInputType
    _sum?: CryptoLotSumAggregateInputType
    _min?: CryptoLotMinAggregateInputType
    _max?: CryptoLotMaxAggregateInputType
  }

  export type CryptoLotGroupByOutputType = {
    id: string
    companyId: string
    cryptoAssetId: string
    acquiredAt: Date
    acquiredAmount: Decimal
    costBasisEur: Decimal
    costPerUnit: Decimal
    remainingAmount: Decimal
    sourceTxId: string | null
    sourceType: string | null
    createdAt: Date
    updatedAt: Date
    _count: CryptoLotCountAggregateOutputType | null
    _avg: CryptoLotAvgAggregateOutputType | null
    _sum: CryptoLotSumAggregateOutputType | null
    _min: CryptoLotMinAggregateOutputType | null
    _max: CryptoLotMaxAggregateOutputType | null
  }

  type GetCryptoLotGroupByPayload<T extends CryptoLotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoLotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoLotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoLotGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoLotGroupByOutputType[P]>
        }
      >
    >


  export type CryptoLotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    cryptoAssetId?: boolean
    acquiredAt?: boolean
    acquiredAmount?: boolean
    costBasisEur?: boolean
    costPerUnit?: boolean
    remainingAmount?: boolean
    sourceTxId?: boolean
    sourceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | CryptoAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoLot"]>

  export type CryptoLotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    cryptoAssetId?: boolean
    acquiredAt?: boolean
    acquiredAmount?: boolean
    costBasisEur?: boolean
    costPerUnit?: boolean
    remainingAmount?: boolean
    sourceTxId?: boolean
    sourceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | CryptoAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoLot"]>

  export type CryptoLotSelectScalar = {
    id?: boolean
    companyId?: boolean
    cryptoAssetId?: boolean
    acquiredAt?: boolean
    acquiredAmount?: boolean
    costBasisEur?: boolean
    costPerUnit?: boolean
    remainingAmount?: boolean
    sourceTxId?: boolean
    sourceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoLotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | CryptoAssetDefaultArgs<ExtArgs>
  }
  export type CryptoLotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    cryptoAsset?: boolean | CryptoAssetDefaultArgs<ExtArgs>
  }

  export type $CryptoLotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoLot"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      cryptoAsset: Prisma.$CryptoAssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      cryptoAssetId: string
      acquiredAt: Date
      acquiredAmount: Prisma.Decimal
      costBasisEur: Prisma.Decimal
      costPerUnit: Prisma.Decimal
      remainingAmount: Prisma.Decimal
      sourceTxId: string | null
      sourceType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoLot"]>
    composites: {}
  }

  type CryptoLotGetPayload<S extends boolean | null | undefined | CryptoLotDefaultArgs> = $Result.GetResult<Prisma.$CryptoLotPayload, S>

  type CryptoLotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CryptoLotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CryptoLotCountAggregateInputType | true
    }

  export interface CryptoLotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoLot'], meta: { name: 'CryptoLot' } }
    /**
     * Find zero or one CryptoLot that matches the filter.
     * @param {CryptoLotFindUniqueArgs} args - Arguments to find a CryptoLot
     * @example
     * // Get one CryptoLot
     * const cryptoLot = await prisma.cryptoLot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoLotFindUniqueArgs>(args: SelectSubset<T, CryptoLotFindUniqueArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CryptoLot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CryptoLotFindUniqueOrThrowArgs} args - Arguments to find a CryptoLot
     * @example
     * // Get one CryptoLot
     * const cryptoLot = await prisma.cryptoLot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoLotFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoLotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CryptoLot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLotFindFirstArgs} args - Arguments to find a CryptoLot
     * @example
     * // Get one CryptoLot
     * const cryptoLot = await prisma.cryptoLot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoLotFindFirstArgs>(args?: SelectSubset<T, CryptoLotFindFirstArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CryptoLot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLotFindFirstOrThrowArgs} args - Arguments to find a CryptoLot
     * @example
     * // Get one CryptoLot
     * const cryptoLot = await prisma.cryptoLot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoLotFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoLotFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CryptoLots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoLots
     * const cryptoLots = await prisma.cryptoLot.findMany()
     * 
     * // Get first 10 CryptoLots
     * const cryptoLots = await prisma.cryptoLot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoLotWithIdOnly = await prisma.cryptoLot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoLotFindManyArgs>(args?: SelectSubset<T, CryptoLotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CryptoLot.
     * @param {CryptoLotCreateArgs} args - Arguments to create a CryptoLot.
     * @example
     * // Create one CryptoLot
     * const CryptoLot = await prisma.cryptoLot.create({
     *   data: {
     *     // ... data to create a CryptoLot
     *   }
     * })
     * 
     */
    create<T extends CryptoLotCreateArgs>(args: SelectSubset<T, CryptoLotCreateArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CryptoLots.
     * @param {CryptoLotCreateManyArgs} args - Arguments to create many CryptoLots.
     * @example
     * // Create many CryptoLots
     * const cryptoLot = await prisma.cryptoLot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoLotCreateManyArgs>(args?: SelectSubset<T, CryptoLotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoLots and returns the data saved in the database.
     * @param {CryptoLotCreateManyAndReturnArgs} args - Arguments to create many CryptoLots.
     * @example
     * // Create many CryptoLots
     * const cryptoLot = await prisma.cryptoLot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoLots and only return the `id`
     * const cryptoLotWithIdOnly = await prisma.cryptoLot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoLotCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoLotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CryptoLot.
     * @param {CryptoLotDeleteArgs} args - Arguments to delete one CryptoLot.
     * @example
     * // Delete one CryptoLot
     * const CryptoLot = await prisma.cryptoLot.delete({
     *   where: {
     *     // ... filter to delete one CryptoLot
     *   }
     * })
     * 
     */
    delete<T extends CryptoLotDeleteArgs>(args: SelectSubset<T, CryptoLotDeleteArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CryptoLot.
     * @param {CryptoLotUpdateArgs} args - Arguments to update one CryptoLot.
     * @example
     * // Update one CryptoLot
     * const cryptoLot = await prisma.cryptoLot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoLotUpdateArgs>(args: SelectSubset<T, CryptoLotUpdateArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CryptoLots.
     * @param {CryptoLotDeleteManyArgs} args - Arguments to filter CryptoLots to delete.
     * @example
     * // Delete a few CryptoLots
     * const { count } = await prisma.cryptoLot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoLotDeleteManyArgs>(args?: SelectSubset<T, CryptoLotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoLots
     * const cryptoLot = await prisma.cryptoLot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoLotUpdateManyArgs>(args: SelectSubset<T, CryptoLotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoLot.
     * @param {CryptoLotUpsertArgs} args - Arguments to update or create a CryptoLot.
     * @example
     * // Update or create a CryptoLot
     * const cryptoLot = await prisma.cryptoLot.upsert({
     *   create: {
     *     // ... data to create a CryptoLot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoLot we want to update
     *   }
     * })
     */
    upsert<T extends CryptoLotUpsertArgs>(args: SelectSubset<T, CryptoLotUpsertArgs<ExtArgs>>): Prisma__CryptoLotClient<$Result.GetResult<Prisma.$CryptoLotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CryptoLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLotCountArgs} args - Arguments to filter CryptoLots to count.
     * @example
     * // Count the number of CryptoLots
     * const count = await prisma.cryptoLot.count({
     *   where: {
     *     // ... the filter for the CryptoLots we want to count
     *   }
     * })
    **/
    count<T extends CryptoLotCountArgs>(
      args?: Subset<T, CryptoLotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoLotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoLot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoLotAggregateArgs>(args: Subset<T, CryptoLotAggregateArgs>): Prisma.PrismaPromise<GetCryptoLotAggregateType<T>>

    /**
     * Group by CryptoLot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoLotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoLotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoLotGroupByArgs['orderBy'] }
        : { orderBy?: CryptoLotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoLotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoLotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoLot model
   */
  readonly fields: CryptoLotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoLot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoLotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cryptoAsset<T extends CryptoAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoAssetDefaultArgs<ExtArgs>>): Prisma__CryptoAssetClient<$Result.GetResult<Prisma.$CryptoAssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoLot model
   */ 
  interface CryptoLotFieldRefs {
    readonly id: FieldRef<"CryptoLot", 'String'>
    readonly companyId: FieldRef<"CryptoLot", 'String'>
    readonly cryptoAssetId: FieldRef<"CryptoLot", 'String'>
    readonly acquiredAt: FieldRef<"CryptoLot", 'DateTime'>
    readonly acquiredAmount: FieldRef<"CryptoLot", 'Decimal'>
    readonly costBasisEur: FieldRef<"CryptoLot", 'Decimal'>
    readonly costPerUnit: FieldRef<"CryptoLot", 'Decimal'>
    readonly remainingAmount: FieldRef<"CryptoLot", 'Decimal'>
    readonly sourceTxId: FieldRef<"CryptoLot", 'String'>
    readonly sourceType: FieldRef<"CryptoLot", 'String'>
    readonly createdAt: FieldRef<"CryptoLot", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoLot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoLot findUnique
   */
  export type CryptoLotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLot to fetch.
     */
    where: CryptoLotWhereUniqueInput
  }

  /**
   * CryptoLot findUniqueOrThrow
   */
  export type CryptoLotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLot to fetch.
     */
    where: CryptoLotWhereUniqueInput
  }

  /**
   * CryptoLot findFirst
   */
  export type CryptoLotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLot to fetch.
     */
    where?: CryptoLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLots to fetch.
     */
    orderBy?: CryptoLotOrderByWithRelationInput | CryptoLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoLots.
     */
    cursor?: CryptoLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoLots.
     */
    distinct?: CryptoLotScalarFieldEnum | CryptoLotScalarFieldEnum[]
  }

  /**
   * CryptoLot findFirstOrThrow
   */
  export type CryptoLotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLot to fetch.
     */
    where?: CryptoLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLots to fetch.
     */
    orderBy?: CryptoLotOrderByWithRelationInput | CryptoLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoLots.
     */
    cursor?: CryptoLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoLots.
     */
    distinct?: CryptoLotScalarFieldEnum | CryptoLotScalarFieldEnum[]
  }

  /**
   * CryptoLot findMany
   */
  export type CryptoLotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * Filter, which CryptoLots to fetch.
     */
    where?: CryptoLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoLots to fetch.
     */
    orderBy?: CryptoLotOrderByWithRelationInput | CryptoLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoLots.
     */
    cursor?: CryptoLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoLots.
     */
    skip?: number
    distinct?: CryptoLotScalarFieldEnum | CryptoLotScalarFieldEnum[]
  }

  /**
   * CryptoLot create
   */
  export type CryptoLotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoLot.
     */
    data: XOR<CryptoLotCreateInput, CryptoLotUncheckedCreateInput>
  }

  /**
   * CryptoLot createMany
   */
  export type CryptoLotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoLots.
     */
    data: CryptoLotCreateManyInput | CryptoLotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoLot createManyAndReturn
   */
  export type CryptoLotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CryptoLots.
     */
    data: CryptoLotCreateManyInput | CryptoLotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoLot update
   */
  export type CryptoLotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoLot.
     */
    data: XOR<CryptoLotUpdateInput, CryptoLotUncheckedUpdateInput>
    /**
     * Choose, which CryptoLot to update.
     */
    where: CryptoLotWhereUniqueInput
  }

  /**
   * CryptoLot updateMany
   */
  export type CryptoLotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoLots.
     */
    data: XOR<CryptoLotUpdateManyMutationInput, CryptoLotUncheckedUpdateManyInput>
    /**
     * Filter which CryptoLots to update
     */
    where?: CryptoLotWhereInput
  }

  /**
   * CryptoLot upsert
   */
  export type CryptoLotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoLot to update in case it exists.
     */
    where: CryptoLotWhereUniqueInput
    /**
     * In case the CryptoLot found by the `where` argument doesn't exist, create a new CryptoLot with this data.
     */
    create: XOR<CryptoLotCreateInput, CryptoLotUncheckedCreateInput>
    /**
     * In case the CryptoLot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoLotUpdateInput, CryptoLotUncheckedUpdateInput>
  }

  /**
   * CryptoLot delete
   */
  export type CryptoLotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
    /**
     * Filter which CryptoLot to delete.
     */
    where: CryptoLotWhereUniqueInput
  }

  /**
   * CryptoLot deleteMany
   */
  export type CryptoLotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoLots to delete
     */
    where?: CryptoLotWhereInput
  }

  /**
   * CryptoLot without action
   */
  export type CryptoLotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoLot
     */
    select?: CryptoLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoLotInclude<ExtArgs> | null
  }


  /**
   * Model PriceHistory
   */

  export type AggregatePriceHistory = {
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  export type PriceHistoryAvgAggregateOutputType = {
    priceEur: Decimal | null
  }

  export type PriceHistorySumAggregateOutputType = {
    priceEur: Decimal | null
  }

  export type PriceHistoryMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    priceEur: Decimal | null
    source: string | null
    timestamp: Date | null
  }

  export type PriceHistoryMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    priceEur: Decimal | null
    source: string | null
    timestamp: Date | null
  }

  export type PriceHistoryCountAggregateOutputType = {
    id: number
    symbol: number
    priceEur: number
    source: number
    timestamp: number
    _all: number
  }


  export type PriceHistoryAvgAggregateInputType = {
    priceEur?: true
  }

  export type PriceHistorySumAggregateInputType = {
    priceEur?: true
  }

  export type PriceHistoryMinAggregateInputType = {
    id?: true
    symbol?: true
    priceEur?: true
    source?: true
    timestamp?: true
  }

  export type PriceHistoryMaxAggregateInputType = {
    id?: true
    symbol?: true
    priceEur?: true
    source?: true
    timestamp?: true
  }

  export type PriceHistoryCountAggregateInputType = {
    id?: true
    symbol?: true
    priceEur?: true
    source?: true
    timestamp?: true
    _all?: true
  }

  export type PriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistory to aggregate.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceHistories
    **/
    _count?: true | PriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type GetPriceHistoryAggregateType<T extends PriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceHistory[P]>
      : GetScalarType<T[P], AggregatePriceHistory[P]>
  }




  export type PriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithAggregationInput | PriceHistoryOrderByWithAggregationInput[]
    by: PriceHistoryScalarFieldEnum[] | PriceHistoryScalarFieldEnum
    having?: PriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceHistoryCountAggregateInputType | true
    _avg?: PriceHistoryAvgAggregateInputType
    _sum?: PriceHistorySumAggregateInputType
    _min?: PriceHistoryMinAggregateInputType
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type PriceHistoryGroupByOutputType = {
    id: string
    symbol: string
    priceEur: Decimal
    source: string
    timestamp: Date
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  type GetPriceHistoryGroupByPayload<T extends PriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    priceEur?: boolean
    source?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    priceEur?: boolean
    source?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectScalar = {
    id?: boolean
    symbol?: boolean
    priceEur?: boolean
    source?: boolean
    timestamp?: boolean
  }


  export type $PriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      priceEur: Prisma.Decimal
      source: string
      timestamp: Date
    }, ExtArgs["result"]["priceHistory"]>
    composites: {}
  }

  type PriceHistoryGetPayload<S extends boolean | null | undefined | PriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$PriceHistoryPayload, S>

  type PriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceHistoryCountAggregateInputType | true
    }

  export interface PriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceHistory'], meta: { name: 'PriceHistory' } }
    /**
     * Find zero or one PriceHistory that matches the filter.
     * @param {PriceHistoryFindUniqueArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceHistoryFindUniqueArgs>(args: SelectSubset<T, PriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriceHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceHistoryFindFirstArgs>(args?: SelectSubset<T, PriceHistoryFindFirstArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany()
     * 
     * // Get first 10 PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceHistoryFindManyArgs>(args?: SelectSubset<T, PriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriceHistory.
     * @param {PriceHistoryCreateArgs} args - Arguments to create a PriceHistory.
     * @example
     * // Create one PriceHistory
     * const PriceHistory = await prisma.priceHistory.create({
     *   data: {
     *     // ... data to create a PriceHistory
     *   }
     * })
     * 
     */
    create<T extends PriceHistoryCreateArgs>(args: SelectSubset<T, PriceHistoryCreateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriceHistories.
     * @param {PriceHistoryCreateManyArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceHistoryCreateManyArgs>(args?: SelectSubset<T, PriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceHistories and returns the data saved in the database.
     * @param {PriceHistoryCreateManyAndReturnArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PriceHistory.
     * @param {PriceHistoryDeleteArgs} args - Arguments to delete one PriceHistory.
     * @example
     * // Delete one PriceHistory
     * const PriceHistory = await prisma.priceHistory.delete({
     *   where: {
     *     // ... filter to delete one PriceHistory
     *   }
     * })
     * 
     */
    delete<T extends PriceHistoryDeleteArgs>(args: SelectSubset<T, PriceHistoryDeleteArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriceHistory.
     * @param {PriceHistoryUpdateArgs} args - Arguments to update one PriceHistory.
     * @example
     * // Update one PriceHistory
     * const priceHistory = await prisma.priceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceHistoryUpdateArgs>(args: SelectSubset<T, PriceHistoryUpdateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriceHistories.
     * @param {PriceHistoryDeleteManyArgs} args - Arguments to filter PriceHistories to delete.
     * @example
     * // Delete a few PriceHistories
     * const { count } = await prisma.priceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceHistoryDeleteManyArgs>(args?: SelectSubset<T, PriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceHistoryUpdateManyArgs>(args: SelectSubset<T, PriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceHistory.
     * @param {PriceHistoryUpsertArgs} args - Arguments to update or create a PriceHistory.
     * @example
     * // Update or create a PriceHistory
     * const priceHistory = await prisma.priceHistory.upsert({
     *   create: {
     *     // ... data to create a PriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends PriceHistoryUpsertArgs>(args: SelectSubset<T, PriceHistoryUpsertArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryCountArgs} args - Arguments to filter PriceHistories to count.
     * @example
     * // Count the number of PriceHistories
     * const count = await prisma.priceHistory.count({
     *   where: {
     *     // ... the filter for the PriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PriceHistoryCountArgs>(
      args?: Subset<T, PriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceHistoryAggregateArgs>(args: Subset<T, PriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPriceHistoryAggregateType<T>>

    /**
     * Group by PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceHistory model
   */
  readonly fields: PriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceHistory model
   */ 
  interface PriceHistoryFieldRefs {
    readonly id: FieldRef<"PriceHistory", 'String'>
    readonly symbol: FieldRef<"PriceHistory", 'String'>
    readonly priceEur: FieldRef<"PriceHistory", 'Decimal'>
    readonly source: FieldRef<"PriceHistory", 'String'>
    readonly timestamp: FieldRef<"PriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceHistory findUnique
   */
  export type PriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findUniqueOrThrow
   */
  export type PriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findFirst
   */
  export type PriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findFirstOrThrow
   */
  export type PriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findMany
   */
  export type PriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Filter, which PriceHistories to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory create
   */
  export type PriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a PriceHistory.
     */
    data: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
  }

  /**
   * PriceHistory createMany
   */
  export type PriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceHistory createManyAndReturn
   */
  export type PriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceHistory update
   */
  export type PriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a PriceHistory.
     */
    data: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PriceHistory to update.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory updateMany
   */
  export type PriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
  }

  /**
   * PriceHistory upsert
   */
  export type PriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the PriceHistory to update in case it exists.
     */
    where: PriceHistoryWhereUniqueInput
    /**
     * In case the PriceHistory found by the `where` argument doesn't exist, create a new PriceHistory with this data.
     */
    create: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
    /**
     * In case the PriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
  }

  /**
   * PriceHistory delete
   */
  export type PriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Filter which PriceHistory to delete.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory deleteMany
   */
  export type PriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistories to delete
     */
    where?: PriceHistoryWhereInput
  }

  /**
   * PriceHistory without action
   */
  export type PriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
  }


  /**
   * Model VerifactuRecord
   */

  export type AggregateVerifactuRecord = {
    _count: VerifactuRecordCountAggregateOutputType | null
    _avg: VerifactuRecordAvgAggregateOutputType | null
    _sum: VerifactuRecordSumAggregateOutputType | null
    _min: VerifactuRecordMinAggregateOutputType | null
    _max: VerifactuRecordMaxAggregateOutputType | null
  }

  export type VerifactuRecordAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type VerifactuRecordSumAggregateOutputType = {
    retryCount: number | null
  }

  export type VerifactuRecordMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    hash: string | null
    prevHash: string | null
    xmlContent: string | null
    state: $Enums.VerifactuRecordState | null
    csv: string | null
    sentAt: Date | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerifactuRecordMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    hash: string | null
    prevHash: string | null
    xmlContent: string | null
    state: $Enums.VerifactuRecordState | null
    csv: string | null
    sentAt: Date | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerifactuRecordCountAggregateOutputType = {
    id: number
    invoiceId: number
    hash: number
    prevHash: number
    xmlContent: number
    state: number
    csv: number
    sentAt: number
    retryCount: number
    aeatResponse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerifactuRecordAvgAggregateInputType = {
    retryCount?: true
  }

  export type VerifactuRecordSumAggregateInputType = {
    retryCount?: true
  }

  export type VerifactuRecordMinAggregateInputType = {
    id?: true
    invoiceId?: true
    hash?: true
    prevHash?: true
    xmlContent?: true
    state?: true
    csv?: true
    sentAt?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerifactuRecordMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    hash?: true
    prevHash?: true
    xmlContent?: true
    state?: true
    csv?: true
    sentAt?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerifactuRecordCountAggregateInputType = {
    id?: true
    invoiceId?: true
    hash?: true
    prevHash?: true
    xmlContent?: true
    state?: true
    csv?: true
    sentAt?: true
    retryCount?: true
    aeatResponse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerifactuRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerifactuRecord to aggregate.
     */
    where?: VerifactuRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerifactuRecords to fetch.
     */
    orderBy?: VerifactuRecordOrderByWithRelationInput | VerifactuRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerifactuRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerifactuRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerifactuRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerifactuRecords
    **/
    _count?: true | VerifactuRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerifactuRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerifactuRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerifactuRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerifactuRecordMaxAggregateInputType
  }

  export type GetVerifactuRecordAggregateType<T extends VerifactuRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateVerifactuRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerifactuRecord[P]>
      : GetScalarType<T[P], AggregateVerifactuRecord[P]>
  }




  export type VerifactuRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerifactuRecordWhereInput
    orderBy?: VerifactuRecordOrderByWithAggregationInput | VerifactuRecordOrderByWithAggregationInput[]
    by: VerifactuRecordScalarFieldEnum[] | VerifactuRecordScalarFieldEnum
    having?: VerifactuRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerifactuRecordCountAggregateInputType | true
    _avg?: VerifactuRecordAvgAggregateInputType
    _sum?: VerifactuRecordSumAggregateInputType
    _min?: VerifactuRecordMinAggregateInputType
    _max?: VerifactuRecordMaxAggregateInputType
  }

  export type VerifactuRecordGroupByOutputType = {
    id: string
    invoiceId: string
    hash: string
    prevHash: string | null
    xmlContent: string
    state: $Enums.VerifactuRecordState
    csv: string | null
    sentAt: Date | null
    retryCount: number
    aeatResponse: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: VerifactuRecordCountAggregateOutputType | null
    _avg: VerifactuRecordAvgAggregateOutputType | null
    _sum: VerifactuRecordSumAggregateOutputType | null
    _min: VerifactuRecordMinAggregateOutputType | null
    _max: VerifactuRecordMaxAggregateOutputType | null
  }

  type GetVerifactuRecordGroupByPayload<T extends VerifactuRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerifactuRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerifactuRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerifactuRecordGroupByOutputType[P]>
            : GetScalarType<T[P], VerifactuRecordGroupByOutputType[P]>
        }
      >
    >


  export type VerifactuRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    hash?: boolean
    prevHash?: boolean
    xmlContent?: boolean
    state?: boolean
    csv?: boolean
    sentAt?: boolean
    retryCount?: boolean
    aeatResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verifactuRecord"]>

  export type VerifactuRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    hash?: boolean
    prevHash?: boolean
    xmlContent?: boolean
    state?: boolean
    csv?: boolean
    sentAt?: boolean
    retryCount?: boolean
    aeatResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verifactuRecord"]>

  export type VerifactuRecordSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    hash?: boolean
    prevHash?: boolean
    xmlContent?: boolean
    state?: boolean
    csv?: boolean
    sentAt?: boolean
    retryCount?: boolean
    aeatResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerifactuRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type VerifactuRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $VerifactuRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerifactuRecord"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      hash: string
      prevHash: string | null
      xmlContent: string
      state: $Enums.VerifactuRecordState
      csv: string | null
      sentAt: Date | null
      retryCount: number
      aeatResponse: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verifactuRecord"]>
    composites: {}
  }

  type VerifactuRecordGetPayload<S extends boolean | null | undefined | VerifactuRecordDefaultArgs> = $Result.GetResult<Prisma.$VerifactuRecordPayload, S>

  type VerifactuRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerifactuRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerifactuRecordCountAggregateInputType | true
    }

  export interface VerifactuRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerifactuRecord'], meta: { name: 'VerifactuRecord' } }
    /**
     * Find zero or one VerifactuRecord that matches the filter.
     * @param {VerifactuRecordFindUniqueArgs} args - Arguments to find a VerifactuRecord
     * @example
     * // Get one VerifactuRecord
     * const verifactuRecord = await prisma.verifactuRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerifactuRecordFindUniqueArgs>(args: SelectSubset<T, VerifactuRecordFindUniqueArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerifactuRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerifactuRecordFindUniqueOrThrowArgs} args - Arguments to find a VerifactuRecord
     * @example
     * // Get one VerifactuRecord
     * const verifactuRecord = await prisma.verifactuRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerifactuRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, VerifactuRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerifactuRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifactuRecordFindFirstArgs} args - Arguments to find a VerifactuRecord
     * @example
     * // Get one VerifactuRecord
     * const verifactuRecord = await prisma.verifactuRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerifactuRecordFindFirstArgs>(args?: SelectSubset<T, VerifactuRecordFindFirstArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerifactuRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifactuRecordFindFirstOrThrowArgs} args - Arguments to find a VerifactuRecord
     * @example
     * // Get one VerifactuRecord
     * const verifactuRecord = await prisma.verifactuRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerifactuRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, VerifactuRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerifactuRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifactuRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerifactuRecords
     * const verifactuRecords = await prisma.verifactuRecord.findMany()
     * 
     * // Get first 10 VerifactuRecords
     * const verifactuRecords = await prisma.verifactuRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verifactuRecordWithIdOnly = await prisma.verifactuRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerifactuRecordFindManyArgs>(args?: SelectSubset<T, VerifactuRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerifactuRecord.
     * @param {VerifactuRecordCreateArgs} args - Arguments to create a VerifactuRecord.
     * @example
     * // Create one VerifactuRecord
     * const VerifactuRecord = await prisma.verifactuRecord.create({
     *   data: {
     *     // ... data to create a VerifactuRecord
     *   }
     * })
     * 
     */
    create<T extends VerifactuRecordCreateArgs>(args: SelectSubset<T, VerifactuRecordCreateArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerifactuRecords.
     * @param {VerifactuRecordCreateManyArgs} args - Arguments to create many VerifactuRecords.
     * @example
     * // Create many VerifactuRecords
     * const verifactuRecord = await prisma.verifactuRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerifactuRecordCreateManyArgs>(args?: SelectSubset<T, VerifactuRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerifactuRecords and returns the data saved in the database.
     * @param {VerifactuRecordCreateManyAndReturnArgs} args - Arguments to create many VerifactuRecords.
     * @example
     * // Create many VerifactuRecords
     * const verifactuRecord = await prisma.verifactuRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerifactuRecords and only return the `id`
     * const verifactuRecordWithIdOnly = await prisma.verifactuRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerifactuRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, VerifactuRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerifactuRecord.
     * @param {VerifactuRecordDeleteArgs} args - Arguments to delete one VerifactuRecord.
     * @example
     * // Delete one VerifactuRecord
     * const VerifactuRecord = await prisma.verifactuRecord.delete({
     *   where: {
     *     // ... filter to delete one VerifactuRecord
     *   }
     * })
     * 
     */
    delete<T extends VerifactuRecordDeleteArgs>(args: SelectSubset<T, VerifactuRecordDeleteArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerifactuRecord.
     * @param {VerifactuRecordUpdateArgs} args - Arguments to update one VerifactuRecord.
     * @example
     * // Update one VerifactuRecord
     * const verifactuRecord = await prisma.verifactuRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerifactuRecordUpdateArgs>(args: SelectSubset<T, VerifactuRecordUpdateArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerifactuRecords.
     * @param {VerifactuRecordDeleteManyArgs} args - Arguments to filter VerifactuRecords to delete.
     * @example
     * // Delete a few VerifactuRecords
     * const { count } = await prisma.verifactuRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerifactuRecordDeleteManyArgs>(args?: SelectSubset<T, VerifactuRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerifactuRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifactuRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerifactuRecords
     * const verifactuRecord = await prisma.verifactuRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerifactuRecordUpdateManyArgs>(args: SelectSubset<T, VerifactuRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerifactuRecord.
     * @param {VerifactuRecordUpsertArgs} args - Arguments to update or create a VerifactuRecord.
     * @example
     * // Update or create a VerifactuRecord
     * const verifactuRecord = await prisma.verifactuRecord.upsert({
     *   create: {
     *     // ... data to create a VerifactuRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerifactuRecord we want to update
     *   }
     * })
     */
    upsert<T extends VerifactuRecordUpsertArgs>(args: SelectSubset<T, VerifactuRecordUpsertArgs<ExtArgs>>): Prisma__VerifactuRecordClient<$Result.GetResult<Prisma.$VerifactuRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerifactuRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifactuRecordCountArgs} args - Arguments to filter VerifactuRecords to count.
     * @example
     * // Count the number of VerifactuRecords
     * const count = await prisma.verifactuRecord.count({
     *   where: {
     *     // ... the filter for the VerifactuRecords we want to count
     *   }
     * })
    **/
    count<T extends VerifactuRecordCountArgs>(
      args?: Subset<T, VerifactuRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerifactuRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerifactuRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifactuRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerifactuRecordAggregateArgs>(args: Subset<T, VerifactuRecordAggregateArgs>): Prisma.PrismaPromise<GetVerifactuRecordAggregateType<T>>

    /**
     * Group by VerifactuRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifactuRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerifactuRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerifactuRecordGroupByArgs['orderBy'] }
        : { orderBy?: VerifactuRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerifactuRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerifactuRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerifactuRecord model
   */
  readonly fields: VerifactuRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerifactuRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerifactuRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerifactuRecord model
   */ 
  interface VerifactuRecordFieldRefs {
    readonly id: FieldRef<"VerifactuRecord", 'String'>
    readonly invoiceId: FieldRef<"VerifactuRecord", 'String'>
    readonly hash: FieldRef<"VerifactuRecord", 'String'>
    readonly prevHash: FieldRef<"VerifactuRecord", 'String'>
    readonly xmlContent: FieldRef<"VerifactuRecord", 'String'>
    readonly state: FieldRef<"VerifactuRecord", 'VerifactuRecordState'>
    readonly csv: FieldRef<"VerifactuRecord", 'String'>
    readonly sentAt: FieldRef<"VerifactuRecord", 'DateTime'>
    readonly retryCount: FieldRef<"VerifactuRecord", 'Int'>
    readonly aeatResponse: FieldRef<"VerifactuRecord", 'Json'>
    readonly createdAt: FieldRef<"VerifactuRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"VerifactuRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerifactuRecord findUnique
   */
  export type VerifactuRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * Filter, which VerifactuRecord to fetch.
     */
    where: VerifactuRecordWhereUniqueInput
  }

  /**
   * VerifactuRecord findUniqueOrThrow
   */
  export type VerifactuRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * Filter, which VerifactuRecord to fetch.
     */
    where: VerifactuRecordWhereUniqueInput
  }

  /**
   * VerifactuRecord findFirst
   */
  export type VerifactuRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * Filter, which VerifactuRecord to fetch.
     */
    where?: VerifactuRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerifactuRecords to fetch.
     */
    orderBy?: VerifactuRecordOrderByWithRelationInput | VerifactuRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerifactuRecords.
     */
    cursor?: VerifactuRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerifactuRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerifactuRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerifactuRecords.
     */
    distinct?: VerifactuRecordScalarFieldEnum | VerifactuRecordScalarFieldEnum[]
  }

  /**
   * VerifactuRecord findFirstOrThrow
   */
  export type VerifactuRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * Filter, which VerifactuRecord to fetch.
     */
    where?: VerifactuRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerifactuRecords to fetch.
     */
    orderBy?: VerifactuRecordOrderByWithRelationInput | VerifactuRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerifactuRecords.
     */
    cursor?: VerifactuRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerifactuRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerifactuRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerifactuRecords.
     */
    distinct?: VerifactuRecordScalarFieldEnum | VerifactuRecordScalarFieldEnum[]
  }

  /**
   * VerifactuRecord findMany
   */
  export type VerifactuRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * Filter, which VerifactuRecords to fetch.
     */
    where?: VerifactuRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerifactuRecords to fetch.
     */
    orderBy?: VerifactuRecordOrderByWithRelationInput | VerifactuRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerifactuRecords.
     */
    cursor?: VerifactuRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerifactuRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerifactuRecords.
     */
    skip?: number
    distinct?: VerifactuRecordScalarFieldEnum | VerifactuRecordScalarFieldEnum[]
  }

  /**
   * VerifactuRecord create
   */
  export type VerifactuRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a VerifactuRecord.
     */
    data: XOR<VerifactuRecordCreateInput, VerifactuRecordUncheckedCreateInput>
  }

  /**
   * VerifactuRecord createMany
   */
  export type VerifactuRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerifactuRecords.
     */
    data: VerifactuRecordCreateManyInput | VerifactuRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerifactuRecord createManyAndReturn
   */
  export type VerifactuRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerifactuRecords.
     */
    data: VerifactuRecordCreateManyInput | VerifactuRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerifactuRecord update
   */
  export type VerifactuRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a VerifactuRecord.
     */
    data: XOR<VerifactuRecordUpdateInput, VerifactuRecordUncheckedUpdateInput>
    /**
     * Choose, which VerifactuRecord to update.
     */
    where: VerifactuRecordWhereUniqueInput
  }

  /**
   * VerifactuRecord updateMany
   */
  export type VerifactuRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerifactuRecords.
     */
    data: XOR<VerifactuRecordUpdateManyMutationInput, VerifactuRecordUncheckedUpdateManyInput>
    /**
     * Filter which VerifactuRecords to update
     */
    where?: VerifactuRecordWhereInput
  }

  /**
   * VerifactuRecord upsert
   */
  export type VerifactuRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the VerifactuRecord to update in case it exists.
     */
    where: VerifactuRecordWhereUniqueInput
    /**
     * In case the VerifactuRecord found by the `where` argument doesn't exist, create a new VerifactuRecord with this data.
     */
    create: XOR<VerifactuRecordCreateInput, VerifactuRecordUncheckedCreateInput>
    /**
     * In case the VerifactuRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerifactuRecordUpdateInput, VerifactuRecordUncheckedUpdateInput>
  }

  /**
   * VerifactuRecord delete
   */
  export type VerifactuRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
    /**
     * Filter which VerifactuRecord to delete.
     */
    where: VerifactuRecordWhereUniqueInput
  }

  /**
   * VerifactuRecord deleteMany
   */
  export type VerifactuRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerifactuRecords to delete
     */
    where?: VerifactuRecordWhereInput
  }

  /**
   * VerifactuRecord without action
   */
  export type VerifactuRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerifactuRecord
     */
    select?: VerifactuRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerifactuRecordInclude<ExtArgs> | null
  }


  /**
   * Model AiConversation
   */

  export type AggregateAiConversation = {
    _count: AiConversationCountAggregateOutputType | null
    _min: AiConversationMinAggregateOutputType | null
    _max: AiConversationMaxAggregateOutputType | null
  }

  export type AiConversationMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiConversationMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiConversationCountAggregateOutputType = {
    id: number
    companyId: number
    userId: number
    title: number
    context: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiConversationMinAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiConversationMaxAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiConversationCountAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    title?: true
    context?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiConversation to aggregate.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiConversations
    **/
    _count?: true | AiConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiConversationMaxAggregateInputType
  }

  export type GetAiConversationAggregateType<T extends AiConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateAiConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiConversation[P]>
      : GetScalarType<T[P], AggregateAiConversation[P]>
  }




  export type AiConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiConversationWhereInput
    orderBy?: AiConversationOrderByWithAggregationInput | AiConversationOrderByWithAggregationInput[]
    by: AiConversationScalarFieldEnum[] | AiConversationScalarFieldEnum
    having?: AiConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiConversationCountAggregateInputType | true
    _min?: AiConversationMinAggregateInputType
    _max?: AiConversationMaxAggregateInputType
  }

  export type AiConversationGroupByOutputType = {
    id: string
    companyId: string
    userId: string
    title: string | null
    context: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AiConversationCountAggregateOutputType | null
    _min: AiConversationMinAggregateOutputType | null
    _max: AiConversationMaxAggregateOutputType | null
  }

  type GetAiConversationGroupByPayload<T extends AiConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiConversationGroupByOutputType[P]>
            : GetScalarType<T[P], AiConversationGroupByOutputType[P]>
        }
      >
    >


  export type AiConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | AiConversation$messagesArgs<ExtArgs>
    _count?: boolean | AiConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiConversation"]>

  export type AiConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiConversation"]>

  export type AiConversationSelectScalar = {
    id?: boolean
    companyId?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | AiConversation$messagesArgs<ExtArgs>
    _count?: boolean | AiConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AiConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiConversation"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$AiMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      userId: string
      title: string | null
      context: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiConversation"]>
    composites: {}
  }

  type AiConversationGetPayload<S extends boolean | null | undefined | AiConversationDefaultArgs> = $Result.GetResult<Prisma.$AiConversationPayload, S>

  type AiConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiConversationCountAggregateInputType | true
    }

  export interface AiConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiConversation'], meta: { name: 'AiConversation' } }
    /**
     * Find zero or one AiConversation that matches the filter.
     * @param {AiConversationFindUniqueArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiConversationFindUniqueArgs>(args: SelectSubset<T, AiConversationFindUniqueArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiConversationFindUniqueOrThrowArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, AiConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindFirstArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiConversationFindFirstArgs>(args?: SelectSubset<T, AiConversationFindFirstArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindFirstOrThrowArgs} args - Arguments to find a AiConversation
     * @example
     * // Get one AiConversation
     * const aiConversation = await prisma.aiConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, AiConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiConversations
     * const aiConversations = await prisma.aiConversation.findMany()
     * 
     * // Get first 10 AiConversations
     * const aiConversations = await prisma.aiConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiConversationWithIdOnly = await prisma.aiConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiConversationFindManyArgs>(args?: SelectSubset<T, AiConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiConversation.
     * @param {AiConversationCreateArgs} args - Arguments to create a AiConversation.
     * @example
     * // Create one AiConversation
     * const AiConversation = await prisma.aiConversation.create({
     *   data: {
     *     // ... data to create a AiConversation
     *   }
     * })
     * 
     */
    create<T extends AiConversationCreateArgs>(args: SelectSubset<T, AiConversationCreateArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiConversations.
     * @param {AiConversationCreateManyArgs} args - Arguments to create many AiConversations.
     * @example
     * // Create many AiConversations
     * const aiConversation = await prisma.aiConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiConversationCreateManyArgs>(args?: SelectSubset<T, AiConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiConversations and returns the data saved in the database.
     * @param {AiConversationCreateManyAndReturnArgs} args - Arguments to create many AiConversations.
     * @example
     * // Create many AiConversations
     * const aiConversation = await prisma.aiConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiConversations and only return the `id`
     * const aiConversationWithIdOnly = await prisma.aiConversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, AiConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiConversation.
     * @param {AiConversationDeleteArgs} args - Arguments to delete one AiConversation.
     * @example
     * // Delete one AiConversation
     * const AiConversation = await prisma.aiConversation.delete({
     *   where: {
     *     // ... filter to delete one AiConversation
     *   }
     * })
     * 
     */
    delete<T extends AiConversationDeleteArgs>(args: SelectSubset<T, AiConversationDeleteArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiConversation.
     * @param {AiConversationUpdateArgs} args - Arguments to update one AiConversation.
     * @example
     * // Update one AiConversation
     * const aiConversation = await prisma.aiConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiConversationUpdateArgs>(args: SelectSubset<T, AiConversationUpdateArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiConversations.
     * @param {AiConversationDeleteManyArgs} args - Arguments to filter AiConversations to delete.
     * @example
     * // Delete a few AiConversations
     * const { count } = await prisma.aiConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiConversationDeleteManyArgs>(args?: SelectSubset<T, AiConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiConversations
     * const aiConversation = await prisma.aiConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiConversationUpdateManyArgs>(args: SelectSubset<T, AiConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiConversation.
     * @param {AiConversationUpsertArgs} args - Arguments to update or create a AiConversation.
     * @example
     * // Update or create a AiConversation
     * const aiConversation = await prisma.aiConversation.upsert({
     *   create: {
     *     // ... data to create a AiConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiConversation we want to update
     *   }
     * })
     */
    upsert<T extends AiConversationUpsertArgs>(args: SelectSubset<T, AiConversationUpsertArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationCountArgs} args - Arguments to filter AiConversations to count.
     * @example
     * // Count the number of AiConversations
     * const count = await prisma.aiConversation.count({
     *   where: {
     *     // ... the filter for the AiConversations we want to count
     *   }
     * })
    **/
    count<T extends AiConversationCountArgs>(
      args?: Subset<T, AiConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiConversationAggregateArgs>(args: Subset<T, AiConversationAggregateArgs>): Prisma.PrismaPromise<GetAiConversationAggregateType<T>>

    /**
     * Group by AiConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiConversationGroupByArgs['orderBy'] }
        : { orderBy?: AiConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiConversation model
   */
  readonly fields: AiConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends AiConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AiConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiConversation model
   */ 
  interface AiConversationFieldRefs {
    readonly id: FieldRef<"AiConversation", 'String'>
    readonly companyId: FieldRef<"AiConversation", 'String'>
    readonly userId: FieldRef<"AiConversation", 'String'>
    readonly title: FieldRef<"AiConversation", 'String'>
    readonly context: FieldRef<"AiConversation", 'Json'>
    readonly createdAt: FieldRef<"AiConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"AiConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiConversation findUnique
   */
  export type AiConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation findUniqueOrThrow
   */
  export type AiConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation findFirst
   */
  export type AiConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiConversations.
     */
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation findFirstOrThrow
   */
  export type AiConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversation to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiConversations.
     */
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation findMany
   */
  export type AiConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter, which AiConversations to fetch.
     */
    where?: AiConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiConversations to fetch.
     */
    orderBy?: AiConversationOrderByWithRelationInput | AiConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiConversations.
     */
    cursor?: AiConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiConversations.
     */
    skip?: number
    distinct?: AiConversationScalarFieldEnum | AiConversationScalarFieldEnum[]
  }

  /**
   * AiConversation create
   */
  export type AiConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a AiConversation.
     */
    data: XOR<AiConversationCreateInput, AiConversationUncheckedCreateInput>
  }

  /**
   * AiConversation createMany
   */
  export type AiConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiConversations.
     */
    data: AiConversationCreateManyInput | AiConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiConversation createManyAndReturn
   */
  export type AiConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiConversations.
     */
    data: AiConversationCreateManyInput | AiConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiConversation update
   */
  export type AiConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a AiConversation.
     */
    data: XOR<AiConversationUpdateInput, AiConversationUncheckedUpdateInput>
    /**
     * Choose, which AiConversation to update.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation updateMany
   */
  export type AiConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiConversations.
     */
    data: XOR<AiConversationUpdateManyMutationInput, AiConversationUncheckedUpdateManyInput>
    /**
     * Filter which AiConversations to update
     */
    where?: AiConversationWhereInput
  }

  /**
   * AiConversation upsert
   */
  export type AiConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the AiConversation to update in case it exists.
     */
    where: AiConversationWhereUniqueInput
    /**
     * In case the AiConversation found by the `where` argument doesn't exist, create a new AiConversation with this data.
     */
    create: XOR<AiConversationCreateInput, AiConversationUncheckedCreateInput>
    /**
     * In case the AiConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiConversationUpdateInput, AiConversationUncheckedUpdateInput>
  }

  /**
   * AiConversation delete
   */
  export type AiConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
    /**
     * Filter which AiConversation to delete.
     */
    where: AiConversationWhereUniqueInput
  }

  /**
   * AiConversation deleteMany
   */
  export type AiConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiConversations to delete
     */
    where?: AiConversationWhereInput
  }

  /**
   * AiConversation.messages
   */
  export type AiConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    where?: AiMessageWhereInput
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    cursor?: AiMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiConversation without action
   */
  export type AiConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiConversation
     */
    select?: AiConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiConversationInclude<ExtArgs> | null
  }


  /**
   * Model AiMessage
   */

  export type AggregateAiMessage = {
    _count: AiMessageCountAggregateOutputType | null
    _avg: AiMessageAvgAggregateOutputType | null
    _sum: AiMessageSumAggregateOutputType | null
    _min: AiMessageMinAggregateOutputType | null
    _max: AiMessageMaxAggregateOutputType | null
  }

  export type AiMessageAvgAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    latencyMs: number | null
  }

  export type AiMessageSumAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    latencyMs: number | null
  }

  export type AiMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.AiRole | null
    content: string | null
    inputTokens: number | null
    outputTokens: number | null
    provider: string | null
    model: string | null
    latencyMs: number | null
    createdAt: Date | null
  }

  export type AiMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.AiRole | null
    content: string | null
    inputTokens: number | null
    outputTokens: number | null
    provider: string | null
    model: string | null
    latencyMs: number | null
    createdAt: Date | null
  }

  export type AiMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    inputTokens: number
    outputTokens: number
    provider: number
    model: number
    latencyMs: number
    createdAt: number
    _all: number
  }


  export type AiMessageAvgAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    latencyMs?: true
  }

  export type AiMessageSumAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    latencyMs?: true
  }

  export type AiMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    inputTokens?: true
    outputTokens?: true
    provider?: true
    model?: true
    latencyMs?: true
    createdAt?: true
  }

  export type AiMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    inputTokens?: true
    outputTokens?: true
    provider?: true
    model?: true
    latencyMs?: true
    createdAt?: true
  }

  export type AiMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    inputTokens?: true
    outputTokens?: true
    provider?: true
    model?: true
    latencyMs?: true
    createdAt?: true
    _all?: true
  }

  export type AiMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMessage to aggregate.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiMessages
    **/
    _count?: true | AiMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiMessageMaxAggregateInputType
  }

  export type GetAiMessageAggregateType<T extends AiMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAiMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiMessage[P]>
      : GetScalarType<T[P], AggregateAiMessage[P]>
  }




  export type AiMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiMessageWhereInput
    orderBy?: AiMessageOrderByWithAggregationInput | AiMessageOrderByWithAggregationInput[]
    by: AiMessageScalarFieldEnum[] | AiMessageScalarFieldEnum
    having?: AiMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiMessageCountAggregateInputType | true
    _avg?: AiMessageAvgAggregateInputType
    _sum?: AiMessageSumAggregateInputType
    _min?: AiMessageMinAggregateInputType
    _max?: AiMessageMaxAggregateInputType
  }

  export type AiMessageGroupByOutputType = {
    id: string
    conversationId: string
    role: $Enums.AiRole
    content: string
    inputTokens: number | null
    outputTokens: number | null
    provider: string | null
    model: string | null
    latencyMs: number | null
    createdAt: Date
    _count: AiMessageCountAggregateOutputType | null
    _avg: AiMessageAvgAggregateOutputType | null
    _sum: AiMessageSumAggregateOutputType | null
    _min: AiMessageMinAggregateOutputType | null
    _max: AiMessageMaxAggregateOutputType | null
  }

  type GetAiMessageGroupByPayload<T extends AiMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AiMessageGroupByOutputType[P]>
        }
      >
    >


  export type AiMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    provider?: boolean
    model?: boolean
    latencyMs?: boolean
    createdAt?: boolean
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMessage"]>

  export type AiMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    provider?: boolean
    model?: boolean
    latencyMs?: boolean
    createdAt?: boolean
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiMessage"]>

  export type AiMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    provider?: boolean
    model?: boolean
    latencyMs?: boolean
    createdAt?: boolean
  }

  export type AiMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }
  export type AiMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | AiConversationDefaultArgs<ExtArgs>
  }

  export type $AiMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiMessage"
    objects: {
      conversation: Prisma.$AiConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: $Enums.AiRole
      content: string
      inputTokens: number | null
      outputTokens: number | null
      provider: string | null
      model: string | null
      latencyMs: number | null
      createdAt: Date
    }, ExtArgs["result"]["aiMessage"]>
    composites: {}
  }

  type AiMessageGetPayload<S extends boolean | null | undefined | AiMessageDefaultArgs> = $Result.GetResult<Prisma.$AiMessagePayload, S>

  type AiMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiMessageCountAggregateInputType | true
    }

  export interface AiMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiMessage'], meta: { name: 'AiMessage' } }
    /**
     * Find zero or one AiMessage that matches the filter.
     * @param {AiMessageFindUniqueArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiMessageFindUniqueArgs>(args: SelectSubset<T, AiMessageFindUniqueArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiMessageFindUniqueOrThrowArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AiMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindFirstArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiMessageFindFirstArgs>(args?: SelectSubset<T, AiMessageFindFirstArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindFirstOrThrowArgs} args - Arguments to find a AiMessage
     * @example
     * // Get one AiMessage
     * const aiMessage = await prisma.aiMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AiMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiMessages
     * const aiMessages = await prisma.aiMessage.findMany()
     * 
     * // Get first 10 AiMessages
     * const aiMessages = await prisma.aiMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiMessageWithIdOnly = await prisma.aiMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiMessageFindManyArgs>(args?: SelectSubset<T, AiMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiMessage.
     * @param {AiMessageCreateArgs} args - Arguments to create a AiMessage.
     * @example
     * // Create one AiMessage
     * const AiMessage = await prisma.aiMessage.create({
     *   data: {
     *     // ... data to create a AiMessage
     *   }
     * })
     * 
     */
    create<T extends AiMessageCreateArgs>(args: SelectSubset<T, AiMessageCreateArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiMessages.
     * @param {AiMessageCreateManyArgs} args - Arguments to create many AiMessages.
     * @example
     * // Create many AiMessages
     * const aiMessage = await prisma.aiMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiMessageCreateManyArgs>(args?: SelectSubset<T, AiMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiMessages and returns the data saved in the database.
     * @param {AiMessageCreateManyAndReturnArgs} args - Arguments to create many AiMessages.
     * @example
     * // Create many AiMessages
     * const aiMessage = await prisma.aiMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiMessages and only return the `id`
     * const aiMessageWithIdOnly = await prisma.aiMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AiMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiMessage.
     * @param {AiMessageDeleteArgs} args - Arguments to delete one AiMessage.
     * @example
     * // Delete one AiMessage
     * const AiMessage = await prisma.aiMessage.delete({
     *   where: {
     *     // ... filter to delete one AiMessage
     *   }
     * })
     * 
     */
    delete<T extends AiMessageDeleteArgs>(args: SelectSubset<T, AiMessageDeleteArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiMessage.
     * @param {AiMessageUpdateArgs} args - Arguments to update one AiMessage.
     * @example
     * // Update one AiMessage
     * const aiMessage = await prisma.aiMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiMessageUpdateArgs>(args: SelectSubset<T, AiMessageUpdateArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiMessages.
     * @param {AiMessageDeleteManyArgs} args - Arguments to filter AiMessages to delete.
     * @example
     * // Delete a few AiMessages
     * const { count } = await prisma.aiMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiMessageDeleteManyArgs>(args?: SelectSubset<T, AiMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiMessages
     * const aiMessage = await prisma.aiMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiMessageUpdateManyArgs>(args: SelectSubset<T, AiMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiMessage.
     * @param {AiMessageUpsertArgs} args - Arguments to update or create a AiMessage.
     * @example
     * // Update or create a AiMessage
     * const aiMessage = await prisma.aiMessage.upsert({
     *   create: {
     *     // ... data to create a AiMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiMessage we want to update
     *   }
     * })
     */
    upsert<T extends AiMessageUpsertArgs>(args: SelectSubset<T, AiMessageUpsertArgs<ExtArgs>>): Prisma__AiMessageClient<$Result.GetResult<Prisma.$AiMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageCountArgs} args - Arguments to filter AiMessages to count.
     * @example
     * // Count the number of AiMessages
     * const count = await prisma.aiMessage.count({
     *   where: {
     *     // ... the filter for the AiMessages we want to count
     *   }
     * })
    **/
    count<T extends AiMessageCountArgs>(
      args?: Subset<T, AiMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiMessageAggregateArgs>(args: Subset<T, AiMessageAggregateArgs>): Prisma.PrismaPromise<GetAiMessageAggregateType<T>>

    /**
     * Group by AiMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiMessageGroupByArgs['orderBy'] }
        : { orderBy?: AiMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiMessage model
   */
  readonly fields: AiMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends AiConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiConversationDefaultArgs<ExtArgs>>): Prisma__AiConversationClient<$Result.GetResult<Prisma.$AiConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiMessage model
   */ 
  interface AiMessageFieldRefs {
    readonly id: FieldRef<"AiMessage", 'String'>
    readonly conversationId: FieldRef<"AiMessage", 'String'>
    readonly role: FieldRef<"AiMessage", 'AiRole'>
    readonly content: FieldRef<"AiMessage", 'String'>
    readonly inputTokens: FieldRef<"AiMessage", 'Int'>
    readonly outputTokens: FieldRef<"AiMessage", 'Int'>
    readonly provider: FieldRef<"AiMessage", 'String'>
    readonly model: FieldRef<"AiMessage", 'String'>
    readonly latencyMs: FieldRef<"AiMessage", 'Int'>
    readonly createdAt: FieldRef<"AiMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiMessage findUnique
   */
  export type AiMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage findUniqueOrThrow
   */
  export type AiMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage findFirst
   */
  export type AiMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMessages.
     */
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage findFirstOrThrow
   */
  export type AiMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessage to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiMessages.
     */
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage findMany
   */
  export type AiMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiMessages to fetch.
     */
    where?: AiMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiMessages to fetch.
     */
    orderBy?: AiMessageOrderByWithRelationInput | AiMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiMessages.
     */
    cursor?: AiMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiMessages.
     */
    skip?: number
    distinct?: AiMessageScalarFieldEnum | AiMessageScalarFieldEnum[]
  }

  /**
   * AiMessage create
   */
  export type AiMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AiMessage.
     */
    data: XOR<AiMessageCreateInput, AiMessageUncheckedCreateInput>
  }

  /**
   * AiMessage createMany
   */
  export type AiMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiMessages.
     */
    data: AiMessageCreateManyInput | AiMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiMessage createManyAndReturn
   */
  export type AiMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiMessages.
     */
    data: AiMessageCreateManyInput | AiMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiMessage update
   */
  export type AiMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AiMessage.
     */
    data: XOR<AiMessageUpdateInput, AiMessageUncheckedUpdateInput>
    /**
     * Choose, which AiMessage to update.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage updateMany
   */
  export type AiMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiMessages.
     */
    data: XOR<AiMessageUpdateManyMutationInput, AiMessageUncheckedUpdateManyInput>
    /**
     * Filter which AiMessages to update
     */
    where?: AiMessageWhereInput
  }

  /**
   * AiMessage upsert
   */
  export type AiMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AiMessage to update in case it exists.
     */
    where: AiMessageWhereUniqueInput
    /**
     * In case the AiMessage found by the `where` argument doesn't exist, create a new AiMessage with this data.
     */
    create: XOR<AiMessageCreateInput, AiMessageUncheckedCreateInput>
    /**
     * In case the AiMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiMessageUpdateInput, AiMessageUncheckedUpdateInput>
  }

  /**
   * AiMessage delete
   */
  export type AiMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
    /**
     * Filter which AiMessage to delete.
     */
    where: AiMessageWhereUniqueInput
  }

  /**
   * AiMessage deleteMany
   */
  export type AiMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiMessages to delete
     */
    where?: AiMessageWhereInput
  }

  /**
   * AiMessage without action
   */
  export type AiMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiMessage
     */
    select?: AiMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiMessageInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    title: string | null
    content: string | null
    type: $Enums.DocumentType | null
    sourceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    title: string | null
    content: string | null
    type: $Enums.DocumentType | null
    sourceUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    companyId: number
    title: number
    content: number
    type: number
    sourceUrl: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    companyId?: true
    title?: true
    content?: true
    type?: true
    sourceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    companyId?: true
    title?: true
    content?: true
    type?: true
    sourceUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    companyId?: true
    title?: true
    content?: true
    type?: true
    sourceUrl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    companyId: string
    title: string
    content: string
    type: $Enums.DocumentType
    sourceUrl: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    sourceUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    sourceUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    companyId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    sourceUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      title: string
      content: string
      type: $Enums.DocumentType
      sourceUrl: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly companyId: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly content: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly sourceUrl: FieldRef<"Document", 'String'>
    readonly metadata: FieldRef<"Document", 'Json'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model CompanyInvitation
   */

  export type AggregateCompanyInvitation = {
    _count: CompanyInvitationCountAggregateOutputType | null
    _min: CompanyInvitationMinAggregateOutputType | null
    _max: CompanyInvitationMaxAggregateOutputType | null
  }

  export type CompanyInvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.UserRole | null
    token: string | null
    status: $Enums.InvitationStatus | null
    companyId: string | null
    inviterId: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    acceptedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyInvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    role: $Enums.UserRole | null
    token: string | null
    status: $Enums.InvitationStatus | null
    companyId: string | null
    inviterId: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    acceptedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyInvitationCountAggregateOutputType = {
    id: number
    email: number
    role: number
    token: number
    status: number
    companyId: number
    inviterId: number
    expiresAt: number
    acceptedAt: number
    acceptedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyInvitationMinAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    status?: true
    companyId?: true
    inviterId?: true
    expiresAt?: true
    acceptedAt?: true
    acceptedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyInvitationMaxAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    status?: true
    companyId?: true
    inviterId?: true
    expiresAt?: true
    acceptedAt?: true
    acceptedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyInvitationCountAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    status?: true
    companyId?: true
    inviterId?: true
    expiresAt?: true
    acceptedAt?: true
    acceptedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvitation to aggregate.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyInvitations
    **/
    _count?: true | CompanyInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyInvitationMaxAggregateInputType
  }

  export type GetCompanyInvitationAggregateType<T extends CompanyInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyInvitation[P]>
      : GetScalarType<T[P], AggregateCompanyInvitation[P]>
  }




  export type CompanyInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvitationWhereInput
    orderBy?: CompanyInvitationOrderByWithAggregationInput | CompanyInvitationOrderByWithAggregationInput[]
    by: CompanyInvitationScalarFieldEnum[] | CompanyInvitationScalarFieldEnum
    having?: CompanyInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyInvitationCountAggregateInputType | true
    _min?: CompanyInvitationMinAggregateInputType
    _max?: CompanyInvitationMaxAggregateInputType
  }

  export type CompanyInvitationGroupByOutputType = {
    id: string
    email: string
    role: $Enums.UserRole
    token: string
    status: $Enums.InvitationStatus
    companyId: string
    inviterId: string
    expiresAt: Date
    acceptedAt: Date | null
    acceptedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyInvitationCountAggregateOutputType | null
    _min: CompanyInvitationMinAggregateOutputType | null
    _max: CompanyInvitationMaxAggregateOutputType | null
  }

  type GetCompanyInvitationGroupByPayload<T extends CompanyInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyInvitationGroupByOutputType[P]>
        }
      >
    >


  export type CompanyInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    status?: boolean
    companyId?: boolean
    inviterId?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    acceptedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    acceptedUser?: boolean | CompanyInvitation$acceptedUserArgs<ExtArgs>
  }, ExtArgs["result"]["companyInvitation"]>

  export type CompanyInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    status?: boolean
    companyId?: boolean
    inviterId?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    acceptedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    acceptedUser?: boolean | CompanyInvitation$acceptedUserArgs<ExtArgs>
  }, ExtArgs["result"]["companyInvitation"]>

  export type CompanyInvitationSelectScalar = {
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    status?: boolean
    companyId?: boolean
    inviterId?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    acceptedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    acceptedUser?: boolean | CompanyInvitation$acceptedUserArgs<ExtArgs>
  }
  export type CompanyInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    acceptedUser?: boolean | CompanyInvitation$acceptedUserArgs<ExtArgs>
  }

  export type $CompanyInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyInvitation"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      acceptedUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      role: $Enums.UserRole
      token: string
      status: $Enums.InvitationStatus
      companyId: string
      inviterId: string
      expiresAt: Date
      acceptedAt: Date | null
      acceptedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyInvitation"]>
    composites: {}
  }

  type CompanyInvitationGetPayload<S extends boolean | null | undefined | CompanyInvitationDefaultArgs> = $Result.GetResult<Prisma.$CompanyInvitationPayload, S>

  type CompanyInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyInvitationCountAggregateInputType | true
    }

  export interface CompanyInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyInvitation'], meta: { name: 'CompanyInvitation' } }
    /**
     * Find zero or one CompanyInvitation that matches the filter.
     * @param {CompanyInvitationFindUniqueArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyInvitationFindUniqueArgs>(args: SelectSubset<T, CompanyInvitationFindUniqueArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyInvitationFindUniqueOrThrowArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationFindFirstArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyInvitationFindFirstArgs>(args?: SelectSubset<T, CompanyInvitationFindFirstArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationFindFirstOrThrowArgs} args - Arguments to find a CompanyInvitation
     * @example
     * // Get one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyInvitations
     * const companyInvitations = await prisma.companyInvitation.findMany()
     * 
     * // Get first 10 CompanyInvitations
     * const companyInvitations = await prisma.companyInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyInvitationWithIdOnly = await prisma.companyInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyInvitationFindManyArgs>(args?: SelectSubset<T, CompanyInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyInvitation.
     * @param {CompanyInvitationCreateArgs} args - Arguments to create a CompanyInvitation.
     * @example
     * // Create one CompanyInvitation
     * const CompanyInvitation = await prisma.companyInvitation.create({
     *   data: {
     *     // ... data to create a CompanyInvitation
     *   }
     * })
     * 
     */
    create<T extends CompanyInvitationCreateArgs>(args: SelectSubset<T, CompanyInvitationCreateArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyInvitations.
     * @param {CompanyInvitationCreateManyArgs} args - Arguments to create many CompanyInvitations.
     * @example
     * // Create many CompanyInvitations
     * const companyInvitation = await prisma.companyInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyInvitationCreateManyArgs>(args?: SelectSubset<T, CompanyInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyInvitations and returns the data saved in the database.
     * @param {CompanyInvitationCreateManyAndReturnArgs} args - Arguments to create many CompanyInvitations.
     * @example
     * // Create many CompanyInvitations
     * const companyInvitation = await prisma.companyInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyInvitations and only return the `id`
     * const companyInvitationWithIdOnly = await prisma.companyInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyInvitation.
     * @param {CompanyInvitationDeleteArgs} args - Arguments to delete one CompanyInvitation.
     * @example
     * // Delete one CompanyInvitation
     * const CompanyInvitation = await prisma.companyInvitation.delete({
     *   where: {
     *     // ... filter to delete one CompanyInvitation
     *   }
     * })
     * 
     */
    delete<T extends CompanyInvitationDeleteArgs>(args: SelectSubset<T, CompanyInvitationDeleteArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyInvitation.
     * @param {CompanyInvitationUpdateArgs} args - Arguments to update one CompanyInvitation.
     * @example
     * // Update one CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyInvitationUpdateArgs>(args: SelectSubset<T, CompanyInvitationUpdateArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyInvitations.
     * @param {CompanyInvitationDeleteManyArgs} args - Arguments to filter CompanyInvitations to delete.
     * @example
     * // Delete a few CompanyInvitations
     * const { count } = await prisma.companyInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyInvitationDeleteManyArgs>(args?: SelectSubset<T, CompanyInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyInvitations
     * const companyInvitation = await prisma.companyInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyInvitationUpdateManyArgs>(args: SelectSubset<T, CompanyInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyInvitation.
     * @param {CompanyInvitationUpsertArgs} args - Arguments to update or create a CompanyInvitation.
     * @example
     * // Update or create a CompanyInvitation
     * const companyInvitation = await prisma.companyInvitation.upsert({
     *   create: {
     *     // ... data to create a CompanyInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyInvitation we want to update
     *   }
     * })
     */
    upsert<T extends CompanyInvitationUpsertArgs>(args: SelectSubset<T, CompanyInvitationUpsertArgs<ExtArgs>>): Prisma__CompanyInvitationClient<$Result.GetResult<Prisma.$CompanyInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationCountArgs} args - Arguments to filter CompanyInvitations to count.
     * @example
     * // Count the number of CompanyInvitations
     * const count = await prisma.companyInvitation.count({
     *   where: {
     *     // ... the filter for the CompanyInvitations we want to count
     *   }
     * })
    **/
    count<T extends CompanyInvitationCountArgs>(
      args?: Subset<T, CompanyInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyInvitationAggregateArgs>(args: Subset<T, CompanyInvitationAggregateArgs>): Prisma.PrismaPromise<GetCompanyInvitationAggregateType<T>>

    /**
     * Group by CompanyInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyInvitationGroupByArgs['orderBy'] }
        : { orderBy?: CompanyInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyInvitation model
   */
  readonly fields: CompanyInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    acceptedUser<T extends CompanyInvitation$acceptedUserArgs<ExtArgs> = {}>(args?: Subset<T, CompanyInvitation$acceptedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyInvitation model
   */ 
  interface CompanyInvitationFieldRefs {
    readonly id: FieldRef<"CompanyInvitation", 'String'>
    readonly email: FieldRef<"CompanyInvitation", 'String'>
    readonly role: FieldRef<"CompanyInvitation", 'UserRole'>
    readonly token: FieldRef<"CompanyInvitation", 'String'>
    readonly status: FieldRef<"CompanyInvitation", 'InvitationStatus'>
    readonly companyId: FieldRef<"CompanyInvitation", 'String'>
    readonly inviterId: FieldRef<"CompanyInvitation", 'String'>
    readonly expiresAt: FieldRef<"CompanyInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"CompanyInvitation", 'DateTime'>
    readonly acceptedBy: FieldRef<"CompanyInvitation", 'String'>
    readonly createdAt: FieldRef<"CompanyInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyInvitation findUnique
   */
  export type CompanyInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation findUniqueOrThrow
   */
  export type CompanyInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation findFirst
   */
  export type CompanyInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvitations.
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvitations.
     */
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * CompanyInvitation findFirstOrThrow
   */
  export type CompanyInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitation to fetch.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvitations.
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvitations.
     */
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * CompanyInvitation findMany
   */
  export type CompanyInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvitations to fetch.
     */
    where?: CompanyInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvitations to fetch.
     */
    orderBy?: CompanyInvitationOrderByWithRelationInput | CompanyInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyInvitations.
     */
    cursor?: CompanyInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvitations.
     */
    skip?: number
    distinct?: CompanyInvitationScalarFieldEnum | CompanyInvitationScalarFieldEnum[]
  }

  /**
   * CompanyInvitation create
   */
  export type CompanyInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyInvitation.
     */
    data: XOR<CompanyInvitationCreateInput, CompanyInvitationUncheckedCreateInput>
  }

  /**
   * CompanyInvitation createMany
   */
  export type CompanyInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyInvitations.
     */
    data: CompanyInvitationCreateManyInput | CompanyInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyInvitation createManyAndReturn
   */
  export type CompanyInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyInvitations.
     */
    data: CompanyInvitationCreateManyInput | CompanyInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyInvitation update
   */
  export type CompanyInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyInvitation.
     */
    data: XOR<CompanyInvitationUpdateInput, CompanyInvitationUncheckedUpdateInput>
    /**
     * Choose, which CompanyInvitation to update.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation updateMany
   */
  export type CompanyInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyInvitations.
     */
    data: XOR<CompanyInvitationUpdateManyMutationInput, CompanyInvitationUncheckedUpdateManyInput>
    /**
     * Filter which CompanyInvitations to update
     */
    where?: CompanyInvitationWhereInput
  }

  /**
   * CompanyInvitation upsert
   */
  export type CompanyInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyInvitation to update in case it exists.
     */
    where: CompanyInvitationWhereUniqueInput
    /**
     * In case the CompanyInvitation found by the `where` argument doesn't exist, create a new CompanyInvitation with this data.
     */
    create: XOR<CompanyInvitationCreateInput, CompanyInvitationUncheckedCreateInput>
    /**
     * In case the CompanyInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyInvitationUpdateInput, CompanyInvitationUncheckedUpdateInput>
  }

  /**
   * CompanyInvitation delete
   */
  export type CompanyInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
    /**
     * Filter which CompanyInvitation to delete.
     */
    where: CompanyInvitationWhereUniqueInput
  }

  /**
   * CompanyInvitation deleteMany
   */
  export type CompanyInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvitations to delete
     */
    where?: CompanyInvitationWhereInput
  }

  /**
   * CompanyInvitation.acceptedUser
   */
  export type CompanyInvitation$acceptedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CompanyInvitation without action
   */
  export type CompanyInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvitation
     */
    select?: CompanyInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvitationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    action: $Enums.AuditAction | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    action: $Enums.AuditAction | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    action: number
    entity: number
    entityId: number
    changes: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    action?: true
    entity?: true
    entityId?: true
    changes?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    companyId: string | null
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | AuditLog$companyArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string | null
      action: $Enums.AuditAction
      entity: string
      entityId: string
      changes: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends AuditLog$companyArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly companyId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.company
   */
  export type AuditLog$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _avg: AnalyticsEventAvgAggregateOutputType | null
    _sum: AnalyticsEventSumAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventAvgAggregateOutputType = {
    value: Decimal | null
  }

  export type AnalyticsEventSumAggregateOutputType = {
    value: Decimal | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    eventType: string | null
    category: string | null
    value: Decimal | null
    currency: string | null
    timestamp: Date | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    eventType: string | null
    category: string | null
    value: Decimal | null
    currency: string | null
    timestamp: Date | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    companyId: number
    userId: number
    eventType: number
    category: number
    value: number
    currency: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type AnalyticsEventAvgAggregateInputType = {
    value?: true
  }

  export type AnalyticsEventSumAggregateInputType = {
    value?: true
  }

  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    eventType?: true
    category?: true
    value?: true
    currency?: true
    timestamp?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    eventType?: true
    category?: true
    value?: true
    currency?: true
    timestamp?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    eventType?: true
    category?: true
    value?: true
    currency?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _avg?: AnalyticsEventAvgAggregateInputType
    _sum?: AnalyticsEventSumAggregateInputType
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    companyId: string | null
    userId: string | null
    eventType: string
    category: string
    value: Decimal | null
    currency: string | null
    metadata: JsonValue | null
    timestamp: Date
    _count: AnalyticsEventCountAggregateOutputType | null
    _avg: AnalyticsEventAvgAggregateOutputType | null
    _sum: AnalyticsEventSumAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    eventType?: boolean
    category?: boolean
    value?: boolean
    currency?: boolean
    metadata?: boolean
    timestamp?: boolean
    company?: boolean | AnalyticsEvent$companyArgs<ExtArgs>
    user?: boolean | AnalyticsEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    eventType?: boolean
    category?: boolean
    value?: boolean
    currency?: boolean
    metadata?: boolean
    timestamp?: boolean
    company?: boolean | AnalyticsEvent$companyArgs<ExtArgs>
    user?: boolean | AnalyticsEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    companyId?: boolean
    userId?: boolean
    eventType?: boolean
    category?: boolean
    value?: boolean
    currency?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type AnalyticsEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | AnalyticsEvent$companyArgs<ExtArgs>
    user?: boolean | AnalyticsEvent$userArgs<ExtArgs>
  }
  export type AnalyticsEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | AnalyticsEvent$companyArgs<ExtArgs>
    user?: boolean | AnalyticsEvent$userArgs<ExtArgs>
  }

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string | null
      userId: string | null
      eventType: string
      category: string
      value: Prisma.Decimal | null
      currency: string | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends AnalyticsEvent$companyArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticsEvent$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends AnalyticsEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, AnalyticsEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */ 
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly companyId: FieldRef<"AnalyticsEvent", 'String'>
    readonly userId: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventType: FieldRef<"AnalyticsEvent", 'String'>
    readonly category: FieldRef<"AnalyticsEvent", 'String'>
    readonly value: FieldRef<"AnalyticsEvent", 'Decimal'>
    readonly currency: FieldRef<"AnalyticsEvent", 'String'>
    readonly metadata: FieldRef<"AnalyticsEvent", 'Json'>
    readonly timestamp: FieldRef<"AnalyticsEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
  }

  /**
   * AnalyticsEvent.company
   */
  export type AnalyticsEvent$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * AnalyticsEvent.user
   */
  export type AnalyticsEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
  }


  /**
   * Model OAuthApp
   */

  export type AggregateOAuthApp = {
    _count: OAuthAppCountAggregateOutputType | null
    _avg: OAuthAppAvgAggregateOutputType | null
    _sum: OAuthAppSumAggregateOutputType | null
    _min: OAuthAppMinAggregateOutputType | null
    _max: OAuthAppMaxAggregateOutputType | null
  }

  export type OAuthAppAvgAggregateOutputType = {
    rateLimit: number | null
    dailyQuota: number | null
  }

  export type OAuthAppSumAggregateOutputType = {
    rateLimit: number | null
    dailyQuota: number | null
  }

  export type OAuthAppMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    createdById: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    website: string | null
    clientId: string | null
    clientSecret: string | null
    rateLimit: number | null
    dailyQuota: number | null
    isActive: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthAppMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    createdById: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    website: string | null
    clientId: string | null
    clientSecret: string | null
    rateLimit: number | null
    dailyQuota: number | null
    isActive: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthAppCountAggregateOutputType = {
    id: number
    companyId: number
    createdById: number
    name: number
    description: number
    logoUrl: number
    website: number
    clientId: number
    clientSecret: number
    redirectUris: number
    scopes: number
    rateLimit: number
    dailyQuota: number
    isActive: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OAuthAppAvgAggregateInputType = {
    rateLimit?: true
    dailyQuota?: true
  }

  export type OAuthAppSumAggregateInputType = {
    rateLimit?: true
    dailyQuota?: true
  }

  export type OAuthAppMinAggregateInputType = {
    id?: true
    companyId?: true
    createdById?: true
    name?: true
    description?: true
    logoUrl?: true
    website?: true
    clientId?: true
    clientSecret?: true
    rateLimit?: true
    dailyQuota?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthAppMaxAggregateInputType = {
    id?: true
    companyId?: true
    createdById?: true
    name?: true
    description?: true
    logoUrl?: true
    website?: true
    clientId?: true
    clientSecret?: true
    rateLimit?: true
    dailyQuota?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthAppCountAggregateInputType = {
    id?: true
    companyId?: true
    createdById?: true
    name?: true
    description?: true
    logoUrl?: true
    website?: true
    clientId?: true
    clientSecret?: true
    redirectUris?: true
    scopes?: true
    rateLimit?: true
    dailyQuota?: true
    isActive?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OAuthAppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthApp to aggregate.
     */
    where?: OAuthAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApps to fetch.
     */
    orderBy?: OAuthAppOrderByWithRelationInput | OAuthAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthApps
    **/
    _count?: true | OAuthAppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OAuthAppAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OAuthAppSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthAppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthAppMaxAggregateInputType
  }

  export type GetOAuthAppAggregateType<T extends OAuthAppAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthApp[P]>
      : GetScalarType<T[P], AggregateOAuthApp[P]>
  }




  export type OAuthAppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAppWhereInput
    orderBy?: OAuthAppOrderByWithAggregationInput | OAuthAppOrderByWithAggregationInput[]
    by: OAuthAppScalarFieldEnum[] | OAuthAppScalarFieldEnum
    having?: OAuthAppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthAppCountAggregateInputType | true
    _avg?: OAuthAppAvgAggregateInputType
    _sum?: OAuthAppSumAggregateInputType
    _min?: OAuthAppMinAggregateInputType
    _max?: OAuthAppMaxAggregateInputType
  }

  export type OAuthAppGroupByOutputType = {
    id: string
    companyId: string
    createdById: string
    name: string
    description: string | null
    logoUrl: string | null
    website: string | null
    clientId: string
    clientSecret: string
    redirectUris: string[]
    scopes: string[]
    rateLimit: number
    dailyQuota: number
    isActive: boolean
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: OAuthAppCountAggregateOutputType | null
    _avg: OAuthAppAvgAggregateOutputType | null
    _sum: OAuthAppSumAggregateOutputType | null
    _min: OAuthAppMinAggregateOutputType | null
    _max: OAuthAppMaxAggregateOutputType | null
  }

  type GetOAuthAppGroupByPayload<T extends OAuthAppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthAppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthAppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthAppGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthAppGroupByOutputType[P]>
        }
      >
    >


  export type OAuthAppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    createdById?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    website?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUris?: boolean
    scopes?: boolean
    rateLimit?: boolean
    dailyQuota?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tokens?: boolean | OAuthApp$tokensArgs<ExtArgs>
    apiUsage?: boolean | OAuthApp$apiUsageArgs<ExtArgs>
    _count?: boolean | OAuthAppCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthApp"]>

  export type OAuthAppSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    createdById?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    website?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUris?: boolean
    scopes?: boolean
    rateLimit?: boolean
    dailyQuota?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthApp"]>

  export type OAuthAppSelectScalar = {
    id?: boolean
    companyId?: boolean
    createdById?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    website?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUris?: boolean
    scopes?: boolean
    rateLimit?: boolean
    dailyQuota?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OAuthAppInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tokens?: boolean | OAuthApp$tokensArgs<ExtArgs>
    apiUsage?: boolean | OAuthApp$apiUsageArgs<ExtArgs>
    _count?: boolean | OAuthAppCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OAuthAppIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OAuthAppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthApp"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      tokens: Prisma.$OAuthTokenPayload<ExtArgs>[]
      apiUsage: Prisma.$ApiUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      createdById: string
      name: string
      description: string | null
      logoUrl: string | null
      website: string | null
      clientId: string
      clientSecret: string
      redirectUris: string[]
      scopes: string[]
      rateLimit: number
      dailyQuota: number
      isActive: boolean
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oAuthApp"]>
    composites: {}
  }

  type OAuthAppGetPayload<S extends boolean | null | undefined | OAuthAppDefaultArgs> = $Result.GetResult<Prisma.$OAuthAppPayload, S>

  type OAuthAppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthAppFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthAppCountAggregateInputType | true
    }

  export interface OAuthAppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthApp'], meta: { name: 'OAuthApp' } }
    /**
     * Find zero or one OAuthApp that matches the filter.
     * @param {OAuthAppFindUniqueArgs} args - Arguments to find a OAuthApp
     * @example
     * // Get one OAuthApp
     * const oAuthApp = await prisma.oAuthApp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthAppFindUniqueArgs>(args: SelectSubset<T, OAuthAppFindUniqueArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthApp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthAppFindUniqueOrThrowArgs} args - Arguments to find a OAuthApp
     * @example
     * // Get one OAuthApp
     * const oAuthApp = await prisma.oAuthApp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthAppFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthAppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthApp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAppFindFirstArgs} args - Arguments to find a OAuthApp
     * @example
     * // Get one OAuthApp
     * const oAuthApp = await prisma.oAuthApp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthAppFindFirstArgs>(args?: SelectSubset<T, OAuthAppFindFirstArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthApp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAppFindFirstOrThrowArgs} args - Arguments to find a OAuthApp
     * @example
     * // Get one OAuthApp
     * const oAuthApp = await prisma.oAuthApp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthAppFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthAppFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthApps
     * const oAuthApps = await prisma.oAuthApp.findMany()
     * 
     * // Get first 10 OAuthApps
     * const oAuthApps = await prisma.oAuthApp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthAppWithIdOnly = await prisma.oAuthApp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthAppFindManyArgs>(args?: SelectSubset<T, OAuthAppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthApp.
     * @param {OAuthAppCreateArgs} args - Arguments to create a OAuthApp.
     * @example
     * // Create one OAuthApp
     * const OAuthApp = await prisma.oAuthApp.create({
     *   data: {
     *     // ... data to create a OAuthApp
     *   }
     * })
     * 
     */
    create<T extends OAuthAppCreateArgs>(args: SelectSubset<T, OAuthAppCreateArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthApps.
     * @param {OAuthAppCreateManyArgs} args - Arguments to create many OAuthApps.
     * @example
     * // Create many OAuthApps
     * const oAuthApp = await prisma.oAuthApp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthAppCreateManyArgs>(args?: SelectSubset<T, OAuthAppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthApps and returns the data saved in the database.
     * @param {OAuthAppCreateManyAndReturnArgs} args - Arguments to create many OAuthApps.
     * @example
     * // Create many OAuthApps
     * const oAuthApp = await prisma.oAuthApp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthApps and only return the `id`
     * const oAuthAppWithIdOnly = await prisma.oAuthApp.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthAppCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthAppCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OAuthApp.
     * @param {OAuthAppDeleteArgs} args - Arguments to delete one OAuthApp.
     * @example
     * // Delete one OAuthApp
     * const OAuthApp = await prisma.oAuthApp.delete({
     *   where: {
     *     // ... filter to delete one OAuthApp
     *   }
     * })
     * 
     */
    delete<T extends OAuthAppDeleteArgs>(args: SelectSubset<T, OAuthAppDeleteArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthApp.
     * @param {OAuthAppUpdateArgs} args - Arguments to update one OAuthApp.
     * @example
     * // Update one OAuthApp
     * const oAuthApp = await prisma.oAuthApp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthAppUpdateArgs>(args: SelectSubset<T, OAuthAppUpdateArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthApps.
     * @param {OAuthAppDeleteManyArgs} args - Arguments to filter OAuthApps to delete.
     * @example
     * // Delete a few OAuthApps
     * const { count } = await prisma.oAuthApp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthAppDeleteManyArgs>(args?: SelectSubset<T, OAuthAppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthApps
     * const oAuthApp = await prisma.oAuthApp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthAppUpdateManyArgs>(args: SelectSubset<T, OAuthAppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthApp.
     * @param {OAuthAppUpsertArgs} args - Arguments to update or create a OAuthApp.
     * @example
     * // Update or create a OAuthApp
     * const oAuthApp = await prisma.oAuthApp.upsert({
     *   create: {
     *     // ... data to create a OAuthApp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthApp we want to update
     *   }
     * })
     */
    upsert<T extends OAuthAppUpsertArgs>(args: SelectSubset<T, OAuthAppUpsertArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAppCountArgs} args - Arguments to filter OAuthApps to count.
     * @example
     * // Count the number of OAuthApps
     * const count = await prisma.oAuthApp.count({
     *   where: {
     *     // ... the filter for the OAuthApps we want to count
     *   }
     * })
    **/
    count<T extends OAuthAppCountArgs>(
      args?: Subset<T, OAuthAppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthAppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthAppAggregateArgs>(args: Subset<T, OAuthAppAggregateArgs>): Prisma.PrismaPromise<GetOAuthAppAggregateType<T>>

    /**
     * Group by OAuthApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthAppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthAppGroupByArgs['orderBy'] }
        : { orderBy?: OAuthAppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthAppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthApp model
   */
  readonly fields: OAuthAppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthApp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthAppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tokens<T extends OAuthApp$tokensArgs<ExtArgs> = {}>(args?: Subset<T, OAuthApp$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findMany"> | Null>
    apiUsage<T extends OAuthApp$apiUsageArgs<ExtArgs> = {}>(args?: Subset<T, OAuthApp$apiUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthApp model
   */ 
  interface OAuthAppFieldRefs {
    readonly id: FieldRef<"OAuthApp", 'String'>
    readonly companyId: FieldRef<"OAuthApp", 'String'>
    readonly createdById: FieldRef<"OAuthApp", 'String'>
    readonly name: FieldRef<"OAuthApp", 'String'>
    readonly description: FieldRef<"OAuthApp", 'String'>
    readonly logoUrl: FieldRef<"OAuthApp", 'String'>
    readonly website: FieldRef<"OAuthApp", 'String'>
    readonly clientId: FieldRef<"OAuthApp", 'String'>
    readonly clientSecret: FieldRef<"OAuthApp", 'String'>
    readonly redirectUris: FieldRef<"OAuthApp", 'String[]'>
    readonly scopes: FieldRef<"OAuthApp", 'String[]'>
    readonly rateLimit: FieldRef<"OAuthApp", 'Int'>
    readonly dailyQuota: FieldRef<"OAuthApp", 'Int'>
    readonly isActive: FieldRef<"OAuthApp", 'Boolean'>
    readonly isPublic: FieldRef<"OAuthApp", 'Boolean'>
    readonly createdAt: FieldRef<"OAuthApp", 'DateTime'>
    readonly updatedAt: FieldRef<"OAuthApp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthApp findUnique
   */
  export type OAuthAppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApp to fetch.
     */
    where: OAuthAppWhereUniqueInput
  }

  /**
   * OAuthApp findUniqueOrThrow
   */
  export type OAuthAppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApp to fetch.
     */
    where: OAuthAppWhereUniqueInput
  }

  /**
   * OAuthApp findFirst
   */
  export type OAuthAppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApp to fetch.
     */
    where?: OAuthAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApps to fetch.
     */
    orderBy?: OAuthAppOrderByWithRelationInput | OAuthAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthApps.
     */
    cursor?: OAuthAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthApps.
     */
    distinct?: OAuthAppScalarFieldEnum | OAuthAppScalarFieldEnum[]
  }

  /**
   * OAuthApp findFirstOrThrow
   */
  export type OAuthAppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApp to fetch.
     */
    where?: OAuthAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApps to fetch.
     */
    orderBy?: OAuthAppOrderByWithRelationInput | OAuthAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthApps.
     */
    cursor?: OAuthAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthApps.
     */
    distinct?: OAuthAppScalarFieldEnum | OAuthAppScalarFieldEnum[]
  }

  /**
   * OAuthApp findMany
   */
  export type OAuthAppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApps to fetch.
     */
    where?: OAuthAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApps to fetch.
     */
    orderBy?: OAuthAppOrderByWithRelationInput | OAuthAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthApps.
     */
    cursor?: OAuthAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApps.
     */
    skip?: number
    distinct?: OAuthAppScalarFieldEnum | OAuthAppScalarFieldEnum[]
  }

  /**
   * OAuthApp create
   */
  export type OAuthAppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthApp.
     */
    data: XOR<OAuthAppCreateInput, OAuthAppUncheckedCreateInput>
  }

  /**
   * OAuthApp createMany
   */
  export type OAuthAppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthApps.
     */
    data: OAuthAppCreateManyInput | OAuthAppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthApp createManyAndReturn
   */
  export type OAuthAppCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OAuthApps.
     */
    data: OAuthAppCreateManyInput | OAuthAppCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OAuthApp update
   */
  export type OAuthAppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthApp.
     */
    data: XOR<OAuthAppUpdateInput, OAuthAppUncheckedUpdateInput>
    /**
     * Choose, which OAuthApp to update.
     */
    where: OAuthAppWhereUniqueInput
  }

  /**
   * OAuthApp updateMany
   */
  export type OAuthAppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthApps.
     */
    data: XOR<OAuthAppUpdateManyMutationInput, OAuthAppUncheckedUpdateManyInput>
    /**
     * Filter which OAuthApps to update
     */
    where?: OAuthAppWhereInput
  }

  /**
   * OAuthApp upsert
   */
  export type OAuthAppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthApp to update in case it exists.
     */
    where: OAuthAppWhereUniqueInput
    /**
     * In case the OAuthApp found by the `where` argument doesn't exist, create a new OAuthApp with this data.
     */
    create: XOR<OAuthAppCreateInput, OAuthAppUncheckedCreateInput>
    /**
     * In case the OAuthApp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthAppUpdateInput, OAuthAppUncheckedUpdateInput>
  }

  /**
   * OAuthApp delete
   */
  export type OAuthAppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    /**
     * Filter which OAuthApp to delete.
     */
    where: OAuthAppWhereUniqueInput
  }

  /**
   * OAuthApp deleteMany
   */
  export type OAuthAppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthApps to delete
     */
    where?: OAuthAppWhereInput
  }

  /**
   * OAuthApp.tokens
   */
  export type OAuthApp$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    where?: OAuthTokenWhereInput
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    cursor?: OAuthTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * OAuthApp.apiUsage
   */
  export type OAuthApp$apiUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    where?: ApiUsageWhereInput
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[]
    cursor?: ApiUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[]
  }

  /**
   * OAuthApp without action
   */
  export type OAuthAppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
  }


  /**
   * Model OAuthToken
   */

  export type AggregateOAuthToken = {
    _count: OAuthTokenCountAggregateOutputType | null
    _min: OAuthTokenMinAggregateOutputType | null
    _max: OAuthTokenMaxAggregateOutputType | null
  }

  export type OAuthTokenMinAggregateOutputType = {
    id: string | null
    appId: string | null
    userId: string | null
    companyId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    refreshExpiresAt: Date | null
    authorizationCode: string | null
    codeExpiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type OAuthTokenMaxAggregateOutputType = {
    id: string | null
    appId: string | null
    userId: string | null
    companyId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    refreshExpiresAt: Date | null
    authorizationCode: string | null
    codeExpiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type OAuthTokenCountAggregateOutputType = {
    id: number
    appId: number
    userId: number
    companyId: number
    accessToken: number
    refreshToken: number
    scopes: number
    expiresAt: number
    refreshExpiresAt: number
    authorizationCode: number
    codeExpiresAt: number
    isRevoked: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type OAuthTokenMinAggregateInputType = {
    id?: true
    appId?: true
    userId?: true
    companyId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    refreshExpiresAt?: true
    authorizationCode?: true
    codeExpiresAt?: true
    isRevoked?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type OAuthTokenMaxAggregateInputType = {
    id?: true
    appId?: true
    userId?: true
    companyId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    refreshExpiresAt?: true
    authorizationCode?: true
    codeExpiresAt?: true
    isRevoked?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type OAuthTokenCountAggregateInputType = {
    id?: true
    appId?: true
    userId?: true
    companyId?: true
    accessToken?: true
    refreshToken?: true
    scopes?: true
    expiresAt?: true
    refreshExpiresAt?: true
    authorizationCode?: true
    codeExpiresAt?: true
    isRevoked?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type OAuthTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthToken to aggregate.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthTokens
    **/
    _count?: true | OAuthTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthTokenMaxAggregateInputType
  }

  export type GetOAuthTokenAggregateType<T extends OAuthTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthToken[P]>
      : GetScalarType<T[P], AggregateOAuthToken[P]>
  }




  export type OAuthTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthTokenWhereInput
    orderBy?: OAuthTokenOrderByWithAggregationInput | OAuthTokenOrderByWithAggregationInput[]
    by: OAuthTokenScalarFieldEnum[] | OAuthTokenScalarFieldEnum
    having?: OAuthTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthTokenCountAggregateInputType | true
    _min?: OAuthTokenMinAggregateInputType
    _max?: OAuthTokenMaxAggregateInputType
  }

  export type OAuthTokenGroupByOutputType = {
    id: string
    appId: string
    userId: string
    companyId: string
    accessToken: string
    refreshToken: string | null
    scopes: string[]
    expiresAt: Date
    refreshExpiresAt: Date | null
    authorizationCode: string | null
    codeExpiresAt: Date | null
    isRevoked: boolean
    createdAt: Date
    lastUsedAt: Date | null
    _count: OAuthTokenCountAggregateOutputType | null
    _min: OAuthTokenMinAggregateOutputType | null
    _max: OAuthTokenMaxAggregateOutputType | null
  }

  type GetOAuthTokenGroupByPayload<T extends OAuthTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthTokenGroupByOutputType[P]>
        }
      >
    >


  export type OAuthTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    userId?: boolean
    companyId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scopes?: boolean
    expiresAt?: boolean
    refreshExpiresAt?: boolean
    authorizationCode?: boolean
    codeExpiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    app?: boolean | OAuthAppDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthToken"]>

  export type OAuthTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    userId?: boolean
    companyId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scopes?: boolean
    expiresAt?: boolean
    refreshExpiresAt?: boolean
    authorizationCode?: boolean
    codeExpiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    app?: boolean | OAuthAppDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthToken"]>

  export type OAuthTokenSelectScalar = {
    id?: boolean
    appId?: boolean
    userId?: boolean
    companyId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scopes?: boolean
    expiresAt?: boolean
    refreshExpiresAt?: boolean
    authorizationCode?: boolean
    codeExpiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type OAuthTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | OAuthAppDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type OAuthTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | OAuthAppDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $OAuthTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthToken"
    objects: {
      app: Prisma.$OAuthAppPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appId: string
      userId: string
      companyId: string
      accessToken: string
      refreshToken: string | null
      scopes: string[]
      expiresAt: Date
      refreshExpiresAt: Date | null
      authorizationCode: string | null
      codeExpiresAt: Date | null
      isRevoked: boolean
      createdAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["oAuthToken"]>
    composites: {}
  }

  type OAuthTokenGetPayload<S extends boolean | null | undefined | OAuthTokenDefaultArgs> = $Result.GetResult<Prisma.$OAuthTokenPayload, S>

  type OAuthTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthTokenCountAggregateInputType | true
    }

  export interface OAuthTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthToken'], meta: { name: 'OAuthToken' } }
    /**
     * Find zero or one OAuthToken that matches the filter.
     * @param {OAuthTokenFindUniqueArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthTokenFindUniqueArgs>(args: SelectSubset<T, OAuthTokenFindUniqueArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthTokenFindUniqueOrThrowArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindFirstArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthTokenFindFirstArgs>(args?: SelectSubset<T, OAuthTokenFindFirstArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindFirstOrThrowArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthTokens
     * const oAuthTokens = await prisma.oAuthToken.findMany()
     * 
     * // Get first 10 OAuthTokens
     * const oAuthTokens = await prisma.oAuthToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthTokenWithIdOnly = await prisma.oAuthToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthTokenFindManyArgs>(args?: SelectSubset<T, OAuthTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthToken.
     * @param {OAuthTokenCreateArgs} args - Arguments to create a OAuthToken.
     * @example
     * // Create one OAuthToken
     * const OAuthToken = await prisma.oAuthToken.create({
     *   data: {
     *     // ... data to create a OAuthToken
     *   }
     * })
     * 
     */
    create<T extends OAuthTokenCreateArgs>(args: SelectSubset<T, OAuthTokenCreateArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthTokens.
     * @param {OAuthTokenCreateManyArgs} args - Arguments to create many OAuthTokens.
     * @example
     * // Create many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthTokenCreateManyArgs>(args?: SelectSubset<T, OAuthTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthTokens and returns the data saved in the database.
     * @param {OAuthTokenCreateManyAndReturnArgs} args - Arguments to create many OAuthTokens.
     * @example
     * // Create many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthTokens and only return the `id`
     * const oAuthTokenWithIdOnly = await prisma.oAuthToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OAuthToken.
     * @param {OAuthTokenDeleteArgs} args - Arguments to delete one OAuthToken.
     * @example
     * // Delete one OAuthToken
     * const OAuthToken = await prisma.oAuthToken.delete({
     *   where: {
     *     // ... filter to delete one OAuthToken
     *   }
     * })
     * 
     */
    delete<T extends OAuthTokenDeleteArgs>(args: SelectSubset<T, OAuthTokenDeleteArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthToken.
     * @param {OAuthTokenUpdateArgs} args - Arguments to update one OAuthToken.
     * @example
     * // Update one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthTokenUpdateArgs>(args: SelectSubset<T, OAuthTokenUpdateArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthTokens.
     * @param {OAuthTokenDeleteManyArgs} args - Arguments to filter OAuthTokens to delete.
     * @example
     * // Delete a few OAuthTokens
     * const { count } = await prisma.oAuthToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthTokenDeleteManyArgs>(args?: SelectSubset<T, OAuthTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthTokenUpdateManyArgs>(args: SelectSubset<T, OAuthTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthToken.
     * @param {OAuthTokenUpsertArgs} args - Arguments to update or create a OAuthToken.
     * @example
     * // Update or create a OAuthToken
     * const oAuthToken = await prisma.oAuthToken.upsert({
     *   create: {
     *     // ... data to create a OAuthToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthToken we want to update
     *   }
     * })
     */
    upsert<T extends OAuthTokenUpsertArgs>(args: SelectSubset<T, OAuthTokenUpsertArgs<ExtArgs>>): Prisma__OAuthTokenClient<$Result.GetResult<Prisma.$OAuthTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenCountArgs} args - Arguments to filter OAuthTokens to count.
     * @example
     * // Count the number of OAuthTokens
     * const count = await prisma.oAuthToken.count({
     *   where: {
     *     // ... the filter for the OAuthTokens we want to count
     *   }
     * })
    **/
    count<T extends OAuthTokenCountArgs>(
      args?: Subset<T, OAuthTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthTokenAggregateArgs>(args: Subset<T, OAuthTokenAggregateArgs>): Prisma.PrismaPromise<GetOAuthTokenAggregateType<T>>

    /**
     * Group by OAuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthTokenGroupByArgs['orderBy'] }
        : { orderBy?: OAuthTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthToken model
   */
  readonly fields: OAuthTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends OAuthAppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OAuthAppDefaultArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthToken model
   */ 
  interface OAuthTokenFieldRefs {
    readonly id: FieldRef<"OAuthToken", 'String'>
    readonly appId: FieldRef<"OAuthToken", 'String'>
    readonly userId: FieldRef<"OAuthToken", 'String'>
    readonly companyId: FieldRef<"OAuthToken", 'String'>
    readonly accessToken: FieldRef<"OAuthToken", 'String'>
    readonly refreshToken: FieldRef<"OAuthToken", 'String'>
    readonly scopes: FieldRef<"OAuthToken", 'String[]'>
    readonly expiresAt: FieldRef<"OAuthToken", 'DateTime'>
    readonly refreshExpiresAt: FieldRef<"OAuthToken", 'DateTime'>
    readonly authorizationCode: FieldRef<"OAuthToken", 'String'>
    readonly codeExpiresAt: FieldRef<"OAuthToken", 'DateTime'>
    readonly isRevoked: FieldRef<"OAuthToken", 'Boolean'>
    readonly createdAt: FieldRef<"OAuthToken", 'DateTime'>
    readonly lastUsedAt: FieldRef<"OAuthToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthToken findUnique
   */
  export type OAuthTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken findUniqueOrThrow
   */
  export type OAuthTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken findFirst
   */
  export type OAuthTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthTokens.
     */
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * OAuthToken findFirstOrThrow
   */
  export type OAuthTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthTokens.
     */
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * OAuthToken findMany
   */
  export type OAuthTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthTokens to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }

  /**
   * OAuthToken create
   */
  export type OAuthTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthToken.
     */
    data: XOR<OAuthTokenCreateInput, OAuthTokenUncheckedCreateInput>
  }

  /**
   * OAuthToken createMany
   */
  export type OAuthTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthTokens.
     */
    data: OAuthTokenCreateManyInput | OAuthTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthToken createManyAndReturn
   */
  export type OAuthTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OAuthTokens.
     */
    data: OAuthTokenCreateManyInput | OAuthTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OAuthToken update
   */
  export type OAuthTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthToken.
     */
    data: XOR<OAuthTokenUpdateInput, OAuthTokenUncheckedUpdateInput>
    /**
     * Choose, which OAuthToken to update.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken updateMany
   */
  export type OAuthTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthTokens.
     */
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyInput>
    /**
     * Filter which OAuthTokens to update
     */
    where?: OAuthTokenWhereInput
  }

  /**
   * OAuthToken upsert
   */
  export type OAuthTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthToken to update in case it exists.
     */
    where: OAuthTokenWhereUniqueInput
    /**
     * In case the OAuthToken found by the `where` argument doesn't exist, create a new OAuthToken with this data.
     */
    create: XOR<OAuthTokenCreateInput, OAuthTokenUncheckedCreateInput>
    /**
     * In case the OAuthToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthTokenUpdateInput, OAuthTokenUncheckedUpdateInput>
  }

  /**
   * OAuthToken delete
   */
  export type OAuthTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter which OAuthToken to delete.
     */
    where: OAuthTokenWhereUniqueInput
  }

  /**
   * OAuthToken deleteMany
   */
  export type OAuthTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthTokens to delete
     */
    where?: OAuthTokenWhereInput
  }

  /**
   * OAuthToken without action
   */
  export type OAuthTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthTokenInclude<ExtArgs> | null
  }


  /**
   * Model ApiUsage
   */

  export type AggregateApiUsage = {
    _count: ApiUsageCountAggregateOutputType | null
    _avg: ApiUsageAvgAggregateOutputType | null
    _sum: ApiUsageSumAggregateOutputType | null
    _min: ApiUsageMinAggregateOutputType | null
    _max: ApiUsageMaxAggregateOutputType | null
  }

  export type ApiUsageAvgAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
    requestCount: number | null
  }

  export type ApiUsageSumAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
    requestCount: number | null
  }

  export type ApiUsageMinAggregateOutputType = {
    id: string | null
    appId: string | null
    companyId: string | null
    userId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    requestCount: number | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type ApiUsageMaxAggregateOutputType = {
    id: string | null
    appId: string | null
    companyId: string | null
    userId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    requestCount: number | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type ApiUsageCountAggregateOutputType = {
    id: number
    appId: number
    companyId: number
    userId: number
    endpoint: number
    method: number
    statusCode: number
    responseTime: number
    requestCount: number
    timestamp: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type ApiUsageAvgAggregateInputType = {
    statusCode?: true
    responseTime?: true
    requestCount?: true
  }

  export type ApiUsageSumAggregateInputType = {
    statusCode?: true
    responseTime?: true
    requestCount?: true
  }

  export type ApiUsageMinAggregateInputType = {
    id?: true
    appId?: true
    companyId?: true
    userId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    requestCount?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type ApiUsageMaxAggregateInputType = {
    id?: true
    appId?: true
    companyId?: true
    userId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    requestCount?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type ApiUsageCountAggregateInputType = {
    id?: true
    appId?: true
    companyId?: true
    userId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    requestCount?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type ApiUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiUsage to aggregate.
     */
    where?: ApiUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiUsages
    **/
    _count?: true | ApiUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiUsageMaxAggregateInputType
  }

  export type GetApiUsageAggregateType<T extends ApiUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateApiUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiUsage[P]>
      : GetScalarType<T[P], AggregateApiUsage[P]>
  }




  export type ApiUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageWhereInput
    orderBy?: ApiUsageOrderByWithAggregationInput | ApiUsageOrderByWithAggregationInput[]
    by: ApiUsageScalarFieldEnum[] | ApiUsageScalarFieldEnum
    having?: ApiUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiUsageCountAggregateInputType | true
    _avg?: ApiUsageAvgAggregateInputType
    _sum?: ApiUsageSumAggregateInputType
    _min?: ApiUsageMinAggregateInputType
    _max?: ApiUsageMaxAggregateInputType
  }

  export type ApiUsageGroupByOutputType = {
    id: string
    appId: string | null
    companyId: string
    userId: string | null
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount: number
    timestamp: Date
    ipAddress: string | null
    userAgent: string | null
    _count: ApiUsageCountAggregateOutputType | null
    _avg: ApiUsageAvgAggregateOutputType | null
    _sum: ApiUsageSumAggregateOutputType | null
    _min: ApiUsageMinAggregateOutputType | null
    _max: ApiUsageMaxAggregateOutputType | null
  }

  type GetApiUsageGroupByPayload<T extends ApiUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiUsageGroupByOutputType[P]>
            : GetScalarType<T[P], ApiUsageGroupByOutputType[P]>
        }
      >
    >


  export type ApiUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    companyId?: boolean
    userId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    requestCount?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    app?: boolean | ApiUsage$appArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | ApiUsage$userArgs<ExtArgs>
  }, ExtArgs["result"]["apiUsage"]>

  export type ApiUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    companyId?: boolean
    userId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    requestCount?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    app?: boolean | ApiUsage$appArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | ApiUsage$userArgs<ExtArgs>
  }, ExtArgs["result"]["apiUsage"]>

  export type ApiUsageSelectScalar = {
    id?: boolean
    appId?: boolean
    companyId?: boolean
    userId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    requestCount?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type ApiUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | ApiUsage$appArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | ApiUsage$userArgs<ExtArgs>
  }
  export type ApiUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | ApiUsage$appArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | ApiUsage$userArgs<ExtArgs>
  }

  export type $ApiUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiUsage"
    objects: {
      app: Prisma.$OAuthAppPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appId: string | null
      companyId: string
      userId: string | null
      endpoint: string
      method: string
      statusCode: number
      responseTime: number
      requestCount: number
      timestamp: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["apiUsage"]>
    composites: {}
  }

  type ApiUsageGetPayload<S extends boolean | null | undefined | ApiUsageDefaultArgs> = $Result.GetResult<Prisma.$ApiUsagePayload, S>

  type ApiUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiUsageCountAggregateInputType | true
    }

  export interface ApiUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiUsage'], meta: { name: 'ApiUsage' } }
    /**
     * Find zero or one ApiUsage that matches the filter.
     * @param {ApiUsageFindUniqueArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiUsageFindUniqueArgs>(args: SelectSubset<T, ApiUsageFindUniqueArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiUsageFindUniqueOrThrowArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageFindFirstArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiUsageFindFirstArgs>(args?: SelectSubset<T, ApiUsageFindFirstArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageFindFirstOrThrowArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiUsages
     * const apiUsages = await prisma.apiUsage.findMany()
     * 
     * // Get first 10 ApiUsages
     * const apiUsages = await prisma.apiUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiUsageWithIdOnly = await prisma.apiUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiUsageFindManyArgs>(args?: SelectSubset<T, ApiUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiUsage.
     * @param {ApiUsageCreateArgs} args - Arguments to create a ApiUsage.
     * @example
     * // Create one ApiUsage
     * const ApiUsage = await prisma.apiUsage.create({
     *   data: {
     *     // ... data to create a ApiUsage
     *   }
     * })
     * 
     */
    create<T extends ApiUsageCreateArgs>(args: SelectSubset<T, ApiUsageCreateArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiUsages.
     * @param {ApiUsageCreateManyArgs} args - Arguments to create many ApiUsages.
     * @example
     * // Create many ApiUsages
     * const apiUsage = await prisma.apiUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiUsageCreateManyArgs>(args?: SelectSubset<T, ApiUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiUsages and returns the data saved in the database.
     * @param {ApiUsageCreateManyAndReturnArgs} args - Arguments to create many ApiUsages.
     * @example
     * // Create many ApiUsages
     * const apiUsage = await prisma.apiUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiUsages and only return the `id`
     * const apiUsageWithIdOnly = await prisma.apiUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiUsage.
     * @param {ApiUsageDeleteArgs} args - Arguments to delete one ApiUsage.
     * @example
     * // Delete one ApiUsage
     * const ApiUsage = await prisma.apiUsage.delete({
     *   where: {
     *     // ... filter to delete one ApiUsage
     *   }
     * })
     * 
     */
    delete<T extends ApiUsageDeleteArgs>(args: SelectSubset<T, ApiUsageDeleteArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiUsage.
     * @param {ApiUsageUpdateArgs} args - Arguments to update one ApiUsage.
     * @example
     * // Update one ApiUsage
     * const apiUsage = await prisma.apiUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiUsageUpdateArgs>(args: SelectSubset<T, ApiUsageUpdateArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiUsages.
     * @param {ApiUsageDeleteManyArgs} args - Arguments to filter ApiUsages to delete.
     * @example
     * // Delete a few ApiUsages
     * const { count } = await prisma.apiUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiUsageDeleteManyArgs>(args?: SelectSubset<T, ApiUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiUsages
     * const apiUsage = await prisma.apiUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiUsageUpdateManyArgs>(args: SelectSubset<T, ApiUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiUsage.
     * @param {ApiUsageUpsertArgs} args - Arguments to update or create a ApiUsage.
     * @example
     * // Update or create a ApiUsage
     * const apiUsage = await prisma.apiUsage.upsert({
     *   create: {
     *     // ... data to create a ApiUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiUsage we want to update
     *   }
     * })
     */
    upsert<T extends ApiUsageUpsertArgs>(args: SelectSubset<T, ApiUsageUpsertArgs<ExtArgs>>): Prisma__ApiUsageClient<$Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageCountArgs} args - Arguments to filter ApiUsages to count.
     * @example
     * // Count the number of ApiUsages
     * const count = await prisma.apiUsage.count({
     *   where: {
     *     // ... the filter for the ApiUsages we want to count
     *   }
     * })
    **/
    count<T extends ApiUsageCountArgs>(
      args?: Subset<T, ApiUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiUsageAggregateArgs>(args: Subset<T, ApiUsageAggregateArgs>): Prisma.PrismaPromise<GetApiUsageAggregateType<T>>

    /**
     * Group by ApiUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiUsageGroupByArgs['orderBy'] }
        : { orderBy?: ApiUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiUsage model
   */
  readonly fields: ApiUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends ApiUsage$appArgs<ExtArgs> = {}>(args?: Subset<T, ApiUsage$appArgs<ExtArgs>>): Prisma__OAuthAppClient<$Result.GetResult<Prisma.$OAuthAppPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends ApiUsage$userArgs<ExtArgs> = {}>(args?: Subset<T, ApiUsage$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiUsage model
   */ 
  interface ApiUsageFieldRefs {
    readonly id: FieldRef<"ApiUsage", 'String'>
    readonly appId: FieldRef<"ApiUsage", 'String'>
    readonly companyId: FieldRef<"ApiUsage", 'String'>
    readonly userId: FieldRef<"ApiUsage", 'String'>
    readonly endpoint: FieldRef<"ApiUsage", 'String'>
    readonly method: FieldRef<"ApiUsage", 'String'>
    readonly statusCode: FieldRef<"ApiUsage", 'Int'>
    readonly responseTime: FieldRef<"ApiUsage", 'Int'>
    readonly requestCount: FieldRef<"ApiUsage", 'Int'>
    readonly timestamp: FieldRef<"ApiUsage", 'DateTime'>
    readonly ipAddress: FieldRef<"ApiUsage", 'String'>
    readonly userAgent: FieldRef<"ApiUsage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiUsage findUnique
   */
  export type ApiUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsage to fetch.
     */
    where: ApiUsageWhereUniqueInput
  }

  /**
   * ApiUsage findUniqueOrThrow
   */
  export type ApiUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsage to fetch.
     */
    where: ApiUsageWhereUniqueInput
  }

  /**
   * ApiUsage findFirst
   */
  export type ApiUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsage to fetch.
     */
    where?: ApiUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiUsages.
     */
    cursor?: ApiUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiUsages.
     */
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[]
  }

  /**
   * ApiUsage findFirstOrThrow
   */
  export type ApiUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsage to fetch.
     */
    where?: ApiUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiUsages.
     */
    cursor?: ApiUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiUsages.
     */
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[]
  }

  /**
   * ApiUsage findMany
   */
  export type ApiUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsages to fetch.
     */
    where?: ApiUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiUsages.
     */
    cursor?: ApiUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsages.
     */
    skip?: number
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[]
  }

  /**
   * ApiUsage create
   */
  export type ApiUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiUsage.
     */
    data: XOR<ApiUsageCreateInput, ApiUsageUncheckedCreateInput>
  }

  /**
   * ApiUsage createMany
   */
  export type ApiUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiUsages.
     */
    data: ApiUsageCreateManyInput | ApiUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiUsage createManyAndReturn
   */
  export type ApiUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiUsages.
     */
    data: ApiUsageCreateManyInput | ApiUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiUsage update
   */
  export type ApiUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiUsage.
     */
    data: XOR<ApiUsageUpdateInput, ApiUsageUncheckedUpdateInput>
    /**
     * Choose, which ApiUsage to update.
     */
    where: ApiUsageWhereUniqueInput
  }

  /**
   * ApiUsage updateMany
   */
  export type ApiUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiUsages.
     */
    data: XOR<ApiUsageUpdateManyMutationInput, ApiUsageUncheckedUpdateManyInput>
    /**
     * Filter which ApiUsages to update
     */
    where?: ApiUsageWhereInput
  }

  /**
   * ApiUsage upsert
   */
  export type ApiUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiUsage to update in case it exists.
     */
    where: ApiUsageWhereUniqueInput
    /**
     * In case the ApiUsage found by the `where` argument doesn't exist, create a new ApiUsage with this data.
     */
    create: XOR<ApiUsageCreateInput, ApiUsageUncheckedCreateInput>
    /**
     * In case the ApiUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiUsageUpdateInput, ApiUsageUncheckedUpdateInput>
  }

  /**
   * ApiUsage delete
   */
  export type ApiUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
    /**
     * Filter which ApiUsage to delete.
     */
    where: ApiUsageWhereUniqueInput
  }

  /**
   * ApiUsage deleteMany
   */
  export type ApiUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiUsages to delete
     */
    where?: ApiUsageWhereInput
  }

  /**
   * ApiUsage.app
   */
  export type ApiUsage$appArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApp
     */
    select?: OAuthAppSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAppInclude<ExtArgs> | null
    where?: OAuthAppWhereInput
  }

  /**
   * ApiUsage.user
   */
  export type ApiUsage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ApiUsage without action
   */
  export type ApiUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    monthlyPrice: Decimal | null
    yearlyPrice: Decimal | null
    maxCompanies: number | null
    maxUsers: number | null
    maxInvoicesPerMonth: number | null
    maxWallets: number | null
    maxAiMessagesPerMonth: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    monthlyPrice: Decimal | null
    yearlyPrice: Decimal | null
    maxCompanies: number | null
    maxUsers: number | null
    maxInvoicesPerMonth: number | null
    maxWallets: number | null
    maxAiMessagesPerMonth: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    stripePriceId: string | null
    monthlyPrice: Decimal | null
    yearlyPrice: Decimal | null
    currency: string | null
    maxCompanies: number | null
    maxUsers: number | null
    maxInvoicesPerMonth: number | null
    maxWallets: number | null
    maxAiMessagesPerMonth: number | null
    verifactuEnabled: boolean | null
    siiEnabled: boolean | null
    aiChatEnabled: boolean | null
    aiOcrEnabled: boolean | null
    cryptoEnabled: boolean | null
    multiUserEnabled: boolean | null
    prioritySupport: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    stripePriceId: string | null
    monthlyPrice: Decimal | null
    yearlyPrice: Decimal | null
    currency: string | null
    maxCompanies: number | null
    maxUsers: number | null
    maxInvoicesPerMonth: number | null
    maxWallets: number | null
    maxAiMessagesPerMonth: number | null
    verifactuEnabled: boolean | null
    siiEnabled: boolean | null
    aiChatEnabled: boolean | null
    aiOcrEnabled: boolean | null
    cryptoEnabled: boolean | null
    multiUserEnabled: boolean | null
    prioritySupport: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    stripePriceId: number
    monthlyPrice: number
    yearlyPrice: number
    currency: number
    maxCompanies: number
    maxUsers: number
    maxInvoicesPerMonth: number
    maxWallets: number
    maxAiMessagesPerMonth: number
    verifactuEnabled: number
    siiEnabled: number
    aiChatEnabled: number
    aiOcrEnabled: number
    cryptoEnabled: number
    multiUserEnabled: number
    prioritySupport: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    monthlyPrice?: true
    yearlyPrice?: true
    maxCompanies?: true
    maxUsers?: true
    maxInvoicesPerMonth?: true
    maxWallets?: true
    maxAiMessagesPerMonth?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    monthlyPrice?: true
    yearlyPrice?: true
    maxCompanies?: true
    maxUsers?: true
    maxInvoicesPerMonth?: true
    maxWallets?: true
    maxAiMessagesPerMonth?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    stripePriceId?: true
    monthlyPrice?: true
    yearlyPrice?: true
    currency?: true
    maxCompanies?: true
    maxUsers?: true
    maxInvoicesPerMonth?: true
    maxWallets?: true
    maxAiMessagesPerMonth?: true
    verifactuEnabled?: true
    siiEnabled?: true
    aiChatEnabled?: true
    aiOcrEnabled?: true
    cryptoEnabled?: true
    multiUserEnabled?: true
    prioritySupport?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    stripePriceId?: true
    monthlyPrice?: true
    yearlyPrice?: true
    currency?: true
    maxCompanies?: true
    maxUsers?: true
    maxInvoicesPerMonth?: true
    maxWallets?: true
    maxAiMessagesPerMonth?: true
    verifactuEnabled?: true
    siiEnabled?: true
    aiChatEnabled?: true
    aiOcrEnabled?: true
    cryptoEnabled?: true
    multiUserEnabled?: true
    prioritySupport?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    stripePriceId?: true
    monthlyPrice?: true
    yearlyPrice?: true
    currency?: true
    maxCompanies?: true
    maxUsers?: true
    maxInvoicesPerMonth?: true
    maxWallets?: true
    maxAiMessagesPerMonth?: true
    verifactuEnabled?: true
    siiEnabled?: true
    aiChatEnabled?: true
    aiOcrEnabled?: true
    cryptoEnabled?: true
    multiUserEnabled?: true
    prioritySupport?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    stripePriceId: string | null
    monthlyPrice: Decimal
    yearlyPrice: Decimal
    currency: string
    maxCompanies: number
    maxUsers: number
    maxInvoicesPerMonth: number
    maxWallets: number
    maxAiMessagesPerMonth: number
    verifactuEnabled: boolean
    siiEnabled: boolean
    aiChatEnabled: boolean
    aiOcrEnabled: boolean
    cryptoEnabled: boolean
    multiUserEnabled: boolean
    prioritySupport: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    stripePriceId?: boolean
    monthlyPrice?: boolean
    yearlyPrice?: boolean
    currency?: boolean
    maxCompanies?: boolean
    maxUsers?: boolean
    maxInvoicesPerMonth?: boolean
    maxWallets?: boolean
    maxAiMessagesPerMonth?: boolean
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    stripePriceId?: boolean
    monthlyPrice?: boolean
    yearlyPrice?: boolean
    currency?: boolean
    maxCompanies?: boolean
    maxUsers?: boolean
    maxInvoicesPerMonth?: boolean
    maxWallets?: boolean
    maxAiMessagesPerMonth?: boolean
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    stripePriceId?: boolean
    monthlyPrice?: boolean
    yearlyPrice?: boolean
    currency?: boolean
    maxCompanies?: boolean
    maxUsers?: boolean
    maxInvoicesPerMonth?: boolean
    maxWallets?: boolean
    maxAiMessagesPerMonth?: boolean
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      stripePriceId: string | null
      monthlyPrice: Prisma.Decimal
      yearlyPrice: Prisma.Decimal
      currency: string
      maxCompanies: number
      maxUsers: number
      maxInvoicesPerMonth: number
      maxWallets: number
      maxAiMessagesPerMonth: number
      verifactuEnabled: boolean
      siiEnabled: boolean
      aiChatEnabled: boolean
      aiOcrEnabled: boolean
      cryptoEnabled: boolean
      multiUserEnabled: boolean
      prioritySupport: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */ 
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly stripePriceId: FieldRef<"SubscriptionPlan", 'String'>
    readonly monthlyPrice: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly yearlyPrice: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly maxCompanies: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxUsers: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxInvoicesPerMonth: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxWallets: FieldRef<"SubscriptionPlan", 'Int'>
    readonly maxAiMessagesPerMonth: FieldRef<"SubscriptionPlan", 'Int'>
    readonly verifactuEnabled: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly siiEnabled: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly aiChatEnabled: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly aiOcrEnabled: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly cryptoEnabled: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly multiUserEnabled: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly prioritySupport: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    invoicesThisMonth: number | null
    aiMessagesThisMonth: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    invoicesThisMonth: number | null
    aiMessagesThisMonth: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    planId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialEndsAt: Date | null
    invoicesThisMonth: number | null
    aiMessagesThisMonth: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    planId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    trialEndsAt: Date | null
    invoicesThisMonth: number | null
    aiMessagesThisMonth: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    companyId: number
    planId: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    canceledAt: number
    trialEndsAt: number
    invoicesThisMonth: number
    aiMessagesThisMonth: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    invoicesThisMonth?: true
    aiMessagesThisMonth?: true
  }

  export type SubscriptionSumAggregateInputType = {
    invoicesThisMonth?: true
    aiMessagesThisMonth?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    companyId?: true
    planId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialEndsAt?: true
    invoicesThisMonth?: true
    aiMessagesThisMonth?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    companyId?: true
    planId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialEndsAt?: true
    invoicesThisMonth?: true
    aiMessagesThisMonth?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    companyId?: true
    planId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    trialEndsAt?: true
    invoicesThisMonth?: true
    aiMessagesThisMonth?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    companyId: string
    planId: string
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    canceledAt: Date | null
    trialEndsAt: Date | null
    invoicesThisMonth: number
    aiMessagesThisMonth: number
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    planId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialEndsAt?: boolean
    invoicesThisMonth?: boolean
    aiMessagesThisMonth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    planId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialEndsAt?: boolean
    invoicesThisMonth?: boolean
    aiMessagesThisMonth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    companyId?: boolean
    planId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    trialEndsAt?: boolean
    invoicesThisMonth?: boolean
    aiMessagesThisMonth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      planId: string
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      status: $Enums.SubscriptionStatus
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      canceledAt: Date | null
      trialEndsAt: Date | null
      invoicesThisMonth: number
      aiMessagesThisMonth: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly companyId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialEndsAt: FieldRef<"Subscription", 'DateTime'>
    readonly invoicesThisMonth: FieldRef<"Subscription", 'Int'>
    readonly aiMessagesThisMonth: FieldRef<"Subscription", 'Int'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    stripePaymentIntentId: string | null
    stripeInvoiceId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    description: string | null
    failureReason: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    stripePaymentIntentId: string | null
    stripeInvoiceId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    description: string | null
    failureReason: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    subscriptionId: number
    stripePaymentIntentId: number
    stripeInvoiceId: number
    amount: number
    currency: number
    status: number
    description: number
    failureReason: number
    paidAt: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripePaymentIntentId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    failureReason?: true
    paidAt?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripePaymentIntentId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    failureReason?: true
    paidAt?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripePaymentIntentId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    failureReason?: true
    paidAt?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    subscriptionId: string
    stripePaymentIntentId: string | null
    stripeInvoiceId: string | null
    amount: Decimal
    currency: string
    status: $Enums.PaymentStatus
    description: string | null
    failureReason: string | null
    paidAt: Date | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    stripePaymentIntentId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    failureReason?: boolean
    paidAt?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    stripePaymentIntentId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    failureReason?: boolean
    paidAt?: boolean
    createdAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    stripePaymentIntentId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    failureReason?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      stripePaymentIntentId: string | null
      stripeInvoiceId: string | null
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PaymentStatus
      description: string | null
      failureReason: string | null
      paidAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly subscriptionId: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly stripeInvoiceId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly failureReason: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model UserOnboarding
   */

  export type AggregateUserOnboarding = {
    _count: UserOnboardingCountAggregateOutputType | null
    _avg: UserOnboardingAvgAggregateOutputType | null
    _sum: UserOnboardingSumAggregateOutputType | null
    _min: UserOnboardingMinAggregateOutputType | null
    _max: UserOnboardingMaxAggregateOutputType | null
  }

  export type UserOnboardingAvgAggregateOutputType = {
    currentStep: number | null
  }

  export type UserOnboardingSumAggregateOutputType = {
    currentStep: number | null
  }

  export type UserOnboardingMinAggregateOutputType = {
    userId: string | null
    status: $Enums.UserOnboardingStatus | null
    currentStep: number | null
    startedAt: Date | null
    completedAt: Date | null
    lastActivityAt: Date | null
  }

  export type UserOnboardingMaxAggregateOutputType = {
    userId: string | null
    status: $Enums.UserOnboardingStatus | null
    currentStep: number | null
    startedAt: Date | null
    completedAt: Date | null
    lastActivityAt: Date | null
  }

  export type UserOnboardingCountAggregateOutputType = {
    userId: number
    status: number
    currentStep: number
    completedSteps: number
    skippedSteps: number
    startedAt: number
    completedAt: number
    lastActivityAt: number
    _all: number
  }


  export type UserOnboardingAvgAggregateInputType = {
    currentStep?: true
  }

  export type UserOnboardingSumAggregateInputType = {
    currentStep?: true
  }

  export type UserOnboardingMinAggregateInputType = {
    userId?: true
    status?: true
    currentStep?: true
    startedAt?: true
    completedAt?: true
    lastActivityAt?: true
  }

  export type UserOnboardingMaxAggregateInputType = {
    userId?: true
    status?: true
    currentStep?: true
    startedAt?: true
    completedAt?: true
    lastActivityAt?: true
  }

  export type UserOnboardingCountAggregateInputType = {
    userId?: true
    status?: true
    currentStep?: true
    completedSteps?: true
    skippedSteps?: true
    startedAt?: true
    completedAt?: true
    lastActivityAt?: true
    _all?: true
  }

  export type UserOnboardingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOnboarding to aggregate.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOnboardings
    **/
    _count?: true | UserOnboardingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOnboardingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOnboardingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOnboardingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOnboardingMaxAggregateInputType
  }

  export type GetUserOnboardingAggregateType<T extends UserOnboardingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOnboarding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOnboarding[P]>
      : GetScalarType<T[P], AggregateUserOnboarding[P]>
  }




  export type UserOnboardingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOnboardingWhereInput
    orderBy?: UserOnboardingOrderByWithAggregationInput | UserOnboardingOrderByWithAggregationInput[]
    by: UserOnboardingScalarFieldEnum[] | UserOnboardingScalarFieldEnum
    having?: UserOnboardingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOnboardingCountAggregateInputType | true
    _avg?: UserOnboardingAvgAggregateInputType
    _sum?: UserOnboardingSumAggregateInputType
    _min?: UserOnboardingMinAggregateInputType
    _max?: UserOnboardingMaxAggregateInputType
  }

  export type UserOnboardingGroupByOutputType = {
    userId: string
    status: $Enums.UserOnboardingStatus
    currentStep: number
    completedSteps: JsonValue
    skippedSteps: JsonValue
    startedAt: Date
    completedAt: Date | null
    lastActivityAt: Date
    _count: UserOnboardingCountAggregateOutputType | null
    _avg: UserOnboardingAvgAggregateOutputType | null
    _sum: UserOnboardingSumAggregateOutputType | null
    _min: UserOnboardingMinAggregateOutputType | null
    _max: UserOnboardingMaxAggregateOutputType | null
  }

  type GetUserOnboardingGroupByPayload<T extends UserOnboardingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOnboardingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOnboardingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOnboardingGroupByOutputType[P]>
            : GetScalarType<T[P], UserOnboardingGroupByOutputType[P]>
        }
      >
    >


  export type UserOnboardingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    status?: boolean
    currentStep?: boolean
    completedSteps?: boolean
    skippedSteps?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOnboarding"]>

  export type UserOnboardingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    status?: boolean
    currentStep?: boolean
    completedSteps?: boolean
    skippedSteps?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOnboarding"]>

  export type UserOnboardingSelectScalar = {
    userId?: boolean
    status?: boolean
    currentStep?: boolean
    completedSteps?: boolean
    skippedSteps?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastActivityAt?: boolean
  }

  export type UserOnboardingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOnboardingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserOnboardingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOnboarding"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      status: $Enums.UserOnboardingStatus
      currentStep: number
      completedSteps: Prisma.JsonValue
      skippedSteps: Prisma.JsonValue
      startedAt: Date
      completedAt: Date | null
      lastActivityAt: Date
    }, ExtArgs["result"]["userOnboarding"]>
    composites: {}
  }

  type UserOnboardingGetPayload<S extends boolean | null | undefined | UserOnboardingDefaultArgs> = $Result.GetResult<Prisma.$UserOnboardingPayload, S>

  type UserOnboardingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserOnboardingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserOnboardingCountAggregateInputType | true
    }

  export interface UserOnboardingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOnboarding'], meta: { name: 'UserOnboarding' } }
    /**
     * Find zero or one UserOnboarding that matches the filter.
     * @param {UserOnboardingFindUniqueArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOnboardingFindUniqueArgs>(args: SelectSubset<T, UserOnboardingFindUniqueArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserOnboarding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserOnboardingFindUniqueOrThrowArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOnboardingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOnboardingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserOnboarding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingFindFirstArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOnboardingFindFirstArgs>(args?: SelectSubset<T, UserOnboardingFindFirstArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserOnboarding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingFindFirstOrThrowArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOnboardingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOnboardingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserOnboardings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOnboardings
     * const userOnboardings = await prisma.userOnboarding.findMany()
     * 
     * // Get first 10 UserOnboardings
     * const userOnboardings = await prisma.userOnboarding.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userOnboardingWithUserIdOnly = await prisma.userOnboarding.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserOnboardingFindManyArgs>(args?: SelectSubset<T, UserOnboardingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserOnboarding.
     * @param {UserOnboardingCreateArgs} args - Arguments to create a UserOnboarding.
     * @example
     * // Create one UserOnboarding
     * const UserOnboarding = await prisma.userOnboarding.create({
     *   data: {
     *     // ... data to create a UserOnboarding
     *   }
     * })
     * 
     */
    create<T extends UserOnboardingCreateArgs>(args: SelectSubset<T, UserOnboardingCreateArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserOnboardings.
     * @param {UserOnboardingCreateManyArgs} args - Arguments to create many UserOnboardings.
     * @example
     * // Create many UserOnboardings
     * const userOnboarding = await prisma.userOnboarding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOnboardingCreateManyArgs>(args?: SelectSubset<T, UserOnboardingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserOnboardings and returns the data saved in the database.
     * @param {UserOnboardingCreateManyAndReturnArgs} args - Arguments to create many UserOnboardings.
     * @example
     * // Create many UserOnboardings
     * const userOnboarding = await prisma.userOnboarding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserOnboardings and only return the `userId`
     * const userOnboardingWithUserIdOnly = await prisma.userOnboarding.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserOnboardingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserOnboardingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserOnboarding.
     * @param {UserOnboardingDeleteArgs} args - Arguments to delete one UserOnboarding.
     * @example
     * // Delete one UserOnboarding
     * const UserOnboarding = await prisma.userOnboarding.delete({
     *   where: {
     *     // ... filter to delete one UserOnboarding
     *   }
     * })
     * 
     */
    delete<T extends UserOnboardingDeleteArgs>(args: SelectSubset<T, UserOnboardingDeleteArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserOnboarding.
     * @param {UserOnboardingUpdateArgs} args - Arguments to update one UserOnboarding.
     * @example
     * // Update one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOnboardingUpdateArgs>(args: SelectSubset<T, UserOnboardingUpdateArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserOnboardings.
     * @param {UserOnboardingDeleteManyArgs} args - Arguments to filter UserOnboardings to delete.
     * @example
     * // Delete a few UserOnboardings
     * const { count } = await prisma.userOnboarding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOnboardingDeleteManyArgs>(args?: SelectSubset<T, UserOnboardingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOnboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOnboardings
     * const userOnboarding = await prisma.userOnboarding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOnboardingUpdateManyArgs>(args: SelectSubset<T, UserOnboardingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOnboarding.
     * @param {UserOnboardingUpsertArgs} args - Arguments to update or create a UserOnboarding.
     * @example
     * // Update or create a UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.upsert({
     *   create: {
     *     // ... data to create a UserOnboarding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOnboarding we want to update
     *   }
     * })
     */
    upsert<T extends UserOnboardingUpsertArgs>(args: SelectSubset<T, UserOnboardingUpsertArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserOnboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingCountArgs} args - Arguments to filter UserOnboardings to count.
     * @example
     * // Count the number of UserOnboardings
     * const count = await prisma.userOnboarding.count({
     *   where: {
     *     // ... the filter for the UserOnboardings we want to count
     *   }
     * })
    **/
    count<T extends UserOnboardingCountArgs>(
      args?: Subset<T, UserOnboardingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOnboardingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOnboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOnboardingAggregateArgs>(args: Subset<T, UserOnboardingAggregateArgs>): Prisma.PrismaPromise<GetUserOnboardingAggregateType<T>>

    /**
     * Group by UserOnboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOnboardingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOnboardingGroupByArgs['orderBy'] }
        : { orderBy?: UserOnboardingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOnboardingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOnboardingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOnboarding model
   */
  readonly fields: UserOnboardingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOnboarding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOnboardingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOnboarding model
   */ 
  interface UserOnboardingFieldRefs {
    readonly userId: FieldRef<"UserOnboarding", 'String'>
    readonly status: FieldRef<"UserOnboarding", 'UserOnboardingStatus'>
    readonly currentStep: FieldRef<"UserOnboarding", 'Int'>
    readonly completedSteps: FieldRef<"UserOnboarding", 'Json'>
    readonly skippedSteps: FieldRef<"UserOnboarding", 'Json'>
    readonly startedAt: FieldRef<"UserOnboarding", 'DateTime'>
    readonly completedAt: FieldRef<"UserOnboarding", 'DateTime'>
    readonly lastActivityAt: FieldRef<"UserOnboarding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserOnboarding findUnique
   */
  export type UserOnboardingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding findUniqueOrThrow
   */
  export type UserOnboardingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding findFirst
   */
  export type UserOnboardingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOnboardings.
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOnboardings.
     */
    distinct?: UserOnboardingScalarFieldEnum | UserOnboardingScalarFieldEnum[]
  }

  /**
   * UserOnboarding findFirstOrThrow
   */
  export type UserOnboardingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOnboardings.
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOnboardings.
     */
    distinct?: UserOnboardingScalarFieldEnum | UserOnboardingScalarFieldEnum[]
  }

  /**
   * UserOnboarding findMany
   */
  export type UserOnboardingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboardings to fetch.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOnboardings.
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    distinct?: UserOnboardingScalarFieldEnum | UserOnboardingScalarFieldEnum[]
  }

  /**
   * UserOnboarding create
   */
  export type UserOnboardingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOnboarding.
     */
    data: XOR<UserOnboardingCreateInput, UserOnboardingUncheckedCreateInput>
  }

  /**
   * UserOnboarding createMany
   */
  export type UserOnboardingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOnboardings.
     */
    data: UserOnboardingCreateManyInput | UserOnboardingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOnboarding createManyAndReturn
   */
  export type UserOnboardingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserOnboardings.
     */
    data: UserOnboardingCreateManyInput | UserOnboardingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOnboarding update
   */
  export type UserOnboardingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOnboarding.
     */
    data: XOR<UserOnboardingUpdateInput, UserOnboardingUncheckedUpdateInput>
    /**
     * Choose, which UserOnboarding to update.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding updateMany
   */
  export type UserOnboardingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOnboardings.
     */
    data: XOR<UserOnboardingUpdateManyMutationInput, UserOnboardingUncheckedUpdateManyInput>
    /**
     * Filter which UserOnboardings to update
     */
    where?: UserOnboardingWhereInput
  }

  /**
   * UserOnboarding upsert
   */
  export type UserOnboardingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOnboarding to update in case it exists.
     */
    where: UserOnboardingWhereUniqueInput
    /**
     * In case the UserOnboarding found by the `where` argument doesn't exist, create a new UserOnboarding with this data.
     */
    create: XOR<UserOnboardingCreateInput, UserOnboardingUncheckedCreateInput>
    /**
     * In case the UserOnboarding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOnboardingUpdateInput, UserOnboardingUncheckedUpdateInput>
  }

  /**
   * UserOnboarding delete
   */
  export type UserOnboardingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter which UserOnboarding to delete.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding deleteMany
   */
  export type UserOnboardingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOnboardings to delete
     */
    where?: UserOnboardingWhereInput
  }

  /**
   * UserOnboarding without action
   */
  export type UserOnboardingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
  }


  /**
   * Model WebhookSubscription
   */

  export type AggregateWebhookSubscription = {
    _count: WebhookSubscriptionCountAggregateOutputType | null
    _avg: WebhookSubscriptionAvgAggregateOutputType | null
    _sum: WebhookSubscriptionSumAggregateOutputType | null
    _min: WebhookSubscriptionMinAggregateOutputType | null
    _max: WebhookSubscriptionMaxAggregateOutputType | null
  }

  export type WebhookSubscriptionAvgAggregateOutputType = {
    retryCount: number | null
    timeout: number | null
  }

  export type WebhookSubscriptionSumAggregateOutputType = {
    retryCount: number | null
    timeout: number | null
  }

  export type WebhookSubscriptionMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    retryCount: number | null
    timeout: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookSubscriptionMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    retryCount: number | null
    timeout: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookSubscriptionCountAggregateOutputType = {
    id: number
    companyId: number
    url: number
    secret: number
    isActive: number
    events: number
    retryCount: number
    timeout: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookSubscriptionAvgAggregateInputType = {
    retryCount?: true
    timeout?: true
  }

  export type WebhookSubscriptionSumAggregateInputType = {
    retryCount?: true
    timeout?: true
  }

  export type WebhookSubscriptionMinAggregateInputType = {
    id?: true
    companyId?: true
    url?: true
    secret?: true
    isActive?: true
    retryCount?: true
    timeout?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookSubscriptionMaxAggregateInputType = {
    id?: true
    companyId?: true
    url?: true
    secret?: true
    isActive?: true
    retryCount?: true
    timeout?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookSubscriptionCountAggregateInputType = {
    id?: true
    companyId?: true
    url?: true
    secret?: true
    isActive?: true
    events?: true
    retryCount?: true
    timeout?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookSubscription to aggregate.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookSubscriptions
    **/
    _count?: true | WebhookSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookSubscriptionMaxAggregateInputType
  }

  export type GetWebhookSubscriptionAggregateType<T extends WebhookSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookSubscription[P]>
      : GetScalarType<T[P], AggregateWebhookSubscription[P]>
  }




  export type WebhookSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookSubscriptionWhereInput
    orderBy?: WebhookSubscriptionOrderByWithAggregationInput | WebhookSubscriptionOrderByWithAggregationInput[]
    by: WebhookSubscriptionScalarFieldEnum[] | WebhookSubscriptionScalarFieldEnum
    having?: WebhookSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookSubscriptionCountAggregateInputType | true
    _avg?: WebhookSubscriptionAvgAggregateInputType
    _sum?: WebhookSubscriptionSumAggregateInputType
    _min?: WebhookSubscriptionMinAggregateInputType
    _max?: WebhookSubscriptionMaxAggregateInputType
  }

  export type WebhookSubscriptionGroupByOutputType = {
    id: string
    companyId: string
    url: string
    secret: string
    isActive: boolean
    events: JsonValue
    retryCount: number
    timeout: number
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: WebhookSubscriptionCountAggregateOutputType | null
    _avg: WebhookSubscriptionAvgAggregateOutputType | null
    _sum: WebhookSubscriptionSumAggregateOutputType | null
    _min: WebhookSubscriptionMinAggregateOutputType | null
    _max: WebhookSubscriptionMaxAggregateOutputType | null
  }

  type GetWebhookSubscriptionGroupByPayload<T extends WebhookSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    events?: boolean
    retryCount?: boolean
    timeout?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    deliveries?: boolean | WebhookSubscription$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookSubscription"]>

  export type WebhookSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    events?: boolean
    retryCount?: boolean
    timeout?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookSubscription"]>

  export type WebhookSubscriptionSelectScalar = {
    id?: boolean
    companyId?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    events?: boolean
    retryCount?: boolean
    timeout?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    deliveries?: boolean | WebhookSubscription$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $WebhookSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookSubscription"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      url: string
      secret: string
      isActive: boolean
      events: Prisma.JsonValue
      retryCount: number
      timeout: number
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhookSubscription"]>
    composites: {}
  }

  type WebhookSubscriptionGetPayload<S extends boolean | null | undefined | WebhookSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$WebhookSubscriptionPayload, S>

  type WebhookSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookSubscriptionCountAggregateInputType | true
    }

  export interface WebhookSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookSubscription'], meta: { name: 'WebhookSubscription' } }
    /**
     * Find zero or one WebhookSubscription that matches the filter.
     * @param {WebhookSubscriptionFindUniqueArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookSubscriptionFindUniqueArgs>(args: SelectSubset<T, WebhookSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionFindFirstArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookSubscriptionFindFirstArgs>(args?: SelectSubset<T, WebhookSubscriptionFindFirstArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionFindFirstOrThrowArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookSubscriptions
     * const webhookSubscriptions = await prisma.webhookSubscription.findMany()
     * 
     * // Get first 10 WebhookSubscriptions
     * const webhookSubscriptions = await prisma.webhookSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookSubscriptionWithIdOnly = await prisma.webhookSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookSubscriptionFindManyArgs>(args?: SelectSubset<T, WebhookSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookSubscription.
     * @param {WebhookSubscriptionCreateArgs} args - Arguments to create a WebhookSubscription.
     * @example
     * // Create one WebhookSubscription
     * const WebhookSubscription = await prisma.webhookSubscription.create({
     *   data: {
     *     // ... data to create a WebhookSubscription
     *   }
     * })
     * 
     */
    create<T extends WebhookSubscriptionCreateArgs>(args: SelectSubset<T, WebhookSubscriptionCreateArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookSubscriptions.
     * @param {WebhookSubscriptionCreateManyArgs} args - Arguments to create many WebhookSubscriptions.
     * @example
     * // Create many WebhookSubscriptions
     * const webhookSubscription = await prisma.webhookSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookSubscriptionCreateManyArgs>(args?: SelectSubset<T, WebhookSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookSubscriptions and returns the data saved in the database.
     * @param {WebhookSubscriptionCreateManyAndReturnArgs} args - Arguments to create many WebhookSubscriptions.
     * @example
     * // Create many WebhookSubscriptions
     * const webhookSubscription = await prisma.webhookSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookSubscriptions and only return the `id`
     * const webhookSubscriptionWithIdOnly = await prisma.webhookSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookSubscription.
     * @param {WebhookSubscriptionDeleteArgs} args - Arguments to delete one WebhookSubscription.
     * @example
     * // Delete one WebhookSubscription
     * const WebhookSubscription = await prisma.webhookSubscription.delete({
     *   where: {
     *     // ... filter to delete one WebhookSubscription
     *   }
     * })
     * 
     */
    delete<T extends WebhookSubscriptionDeleteArgs>(args: SelectSubset<T, WebhookSubscriptionDeleteArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookSubscription.
     * @param {WebhookSubscriptionUpdateArgs} args - Arguments to update one WebhookSubscription.
     * @example
     * // Update one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookSubscriptionUpdateArgs>(args: SelectSubset<T, WebhookSubscriptionUpdateArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookSubscriptions.
     * @param {WebhookSubscriptionDeleteManyArgs} args - Arguments to filter WebhookSubscriptions to delete.
     * @example
     * // Delete a few WebhookSubscriptions
     * const { count } = await prisma.webhookSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookSubscriptionDeleteManyArgs>(args?: SelectSubset<T, WebhookSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookSubscriptions
     * const webhookSubscription = await prisma.webhookSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookSubscriptionUpdateManyArgs>(args: SelectSubset<T, WebhookSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookSubscription.
     * @param {WebhookSubscriptionUpsertArgs} args - Arguments to update or create a WebhookSubscription.
     * @example
     * // Update or create a WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.upsert({
     *   create: {
     *     // ... data to create a WebhookSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookSubscription we want to update
     *   }
     * })
     */
    upsert<T extends WebhookSubscriptionUpsertArgs>(args: SelectSubset<T, WebhookSubscriptionUpsertArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionCountArgs} args - Arguments to filter WebhookSubscriptions to count.
     * @example
     * // Count the number of WebhookSubscriptions
     * const count = await prisma.webhookSubscription.count({
     *   where: {
     *     // ... the filter for the WebhookSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends WebhookSubscriptionCountArgs>(
      args?: Subset<T, WebhookSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookSubscriptionAggregateArgs>(args: Subset<T, WebhookSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetWebhookSubscriptionAggregateType<T>>

    /**
     * Group by WebhookSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: WebhookSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookSubscription model
   */
  readonly fields: WebhookSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deliveries<T extends WebhookSubscription$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, WebhookSubscription$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookSubscription model
   */ 
  interface WebhookSubscriptionFieldRefs {
    readonly id: FieldRef<"WebhookSubscription", 'String'>
    readonly companyId: FieldRef<"WebhookSubscription", 'String'>
    readonly url: FieldRef<"WebhookSubscription", 'String'>
    readonly secret: FieldRef<"WebhookSubscription", 'String'>
    readonly isActive: FieldRef<"WebhookSubscription", 'Boolean'>
    readonly events: FieldRef<"WebhookSubscription", 'Json'>
    readonly retryCount: FieldRef<"WebhookSubscription", 'Int'>
    readonly timeout: FieldRef<"WebhookSubscription", 'Int'>
    readonly description: FieldRef<"WebhookSubscription", 'String'>
    readonly metadata: FieldRef<"WebhookSubscription", 'Json'>
    readonly createdAt: FieldRef<"WebhookSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"WebhookSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookSubscription findUnique
   */
  export type WebhookSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription findUniqueOrThrow
   */
  export type WebhookSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription findFirst
   */
  export type WebhookSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookSubscriptions.
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookSubscriptions.
     */
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * WebhookSubscription findFirstOrThrow
   */
  export type WebhookSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookSubscriptions.
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookSubscriptions.
     */
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * WebhookSubscription findMany
   */
  export type WebhookSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscriptions to fetch.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookSubscriptions.
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * WebhookSubscription create
   */
  export type WebhookSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookSubscription.
     */
    data: XOR<WebhookSubscriptionCreateInput, WebhookSubscriptionUncheckedCreateInput>
  }

  /**
   * WebhookSubscription createMany
   */
  export type WebhookSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookSubscriptions.
     */
    data: WebhookSubscriptionCreateManyInput | WebhookSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookSubscription createManyAndReturn
   */
  export type WebhookSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookSubscriptions.
     */
    data: WebhookSubscriptionCreateManyInput | WebhookSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookSubscription update
   */
  export type WebhookSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookSubscription.
     */
    data: XOR<WebhookSubscriptionUpdateInput, WebhookSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which WebhookSubscription to update.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription updateMany
   */
  export type WebhookSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookSubscriptions.
     */
    data: XOR<WebhookSubscriptionUpdateManyMutationInput, WebhookSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which WebhookSubscriptions to update
     */
    where?: WebhookSubscriptionWhereInput
  }

  /**
   * WebhookSubscription upsert
   */
  export type WebhookSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookSubscription to update in case it exists.
     */
    where: WebhookSubscriptionWhereUniqueInput
    /**
     * In case the WebhookSubscription found by the `where` argument doesn't exist, create a new WebhookSubscription with this data.
     */
    create: XOR<WebhookSubscriptionCreateInput, WebhookSubscriptionUncheckedCreateInput>
    /**
     * In case the WebhookSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookSubscriptionUpdateInput, WebhookSubscriptionUncheckedUpdateInput>
  }

  /**
   * WebhookSubscription delete
   */
  export type WebhookSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which WebhookSubscription to delete.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription deleteMany
   */
  export type WebhookSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookSubscriptions to delete
     */
    where?: WebhookSubscriptionWhereInput
  }

  /**
   * WebhookSubscription.deliveries
   */
  export type WebhookSubscription$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookSubscription without action
   */
  export type WebhookSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    attemptCount: number | null
    maxAttempts: number | null
    responseStatus: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    attemptCount: number | null
    maxAttempts: number | null
    responseStatus: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    event: string | null
    payloadHash: string | null
    status: $Enums.WebhookDeliveryStatus | null
    attemptCount: number | null
    maxAttempts: number | null
    responseStatus: number | null
    responseBody: string | null
    errorMessage: string | null
    scheduledFor: Date | null
    lastAttemptAt: Date | null
    nextAttemptAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    event: string | null
    payloadHash: string | null
    status: $Enums.WebhookDeliveryStatus | null
    attemptCount: number | null
    maxAttempts: number | null
    responseStatus: number | null
    responseBody: string | null
    errorMessage: string | null
    scheduledFor: Date | null
    lastAttemptAt: Date | null
    nextAttemptAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    subscriptionId: number
    event: number
    payload: number
    payloadHash: number
    status: number
    attemptCount: number
    maxAttempts: number
    responseStatus: number
    responseBody: number
    responseHeaders: number
    errorMessage: number
    scheduledFor: number
    lastAttemptAt: number
    nextAttemptAt: number
    deliveredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    attemptCount?: true
    maxAttempts?: true
    responseStatus?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    attemptCount?: true
    maxAttempts?: true
    responseStatus?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    event?: true
    payloadHash?: true
    status?: true
    attemptCount?: true
    maxAttempts?: true
    responseStatus?: true
    responseBody?: true
    errorMessage?: true
    scheduledFor?: true
    lastAttemptAt?: true
    nextAttemptAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    event?: true
    payloadHash?: true
    status?: true
    attemptCount?: true
    maxAttempts?: true
    responseStatus?: true
    responseBody?: true
    errorMessage?: true
    scheduledFor?: true
    lastAttemptAt?: true
    nextAttemptAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    event?: true
    payload?: true
    payloadHash?: true
    status?: true
    attemptCount?: true
    maxAttempts?: true
    responseStatus?: true
    responseBody?: true
    responseHeaders?: true
    errorMessage?: true
    scheduledFor?: true
    lastAttemptAt?: true
    nextAttemptAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    subscriptionId: string
    event: string
    payload: JsonValue
    payloadHash: string
    status: $Enums.WebhookDeliveryStatus
    attemptCount: number
    maxAttempts: number
    responseStatus: number | null
    responseBody: string | null
    responseHeaders: JsonValue | null
    errorMessage: string | null
    scheduledFor: Date
    lastAttemptAt: Date | null
    nextAttemptAt: Date | null
    deliveredAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    event?: boolean
    payload?: boolean
    payloadHash?: boolean
    status?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    responseStatus?: boolean
    responseBody?: boolean
    responseHeaders?: boolean
    errorMessage?: boolean
    scheduledFor?: boolean
    lastAttemptAt?: boolean
    nextAttemptAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | WebhookSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    event?: boolean
    payload?: boolean
    payloadHash?: boolean
    status?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    responseStatus?: boolean
    responseBody?: boolean
    responseHeaders?: boolean
    errorMessage?: boolean
    scheduledFor?: boolean
    lastAttemptAt?: boolean
    nextAttemptAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | WebhookSubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    event?: boolean
    payload?: boolean
    payloadHash?: boolean
    status?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    responseStatus?: boolean
    responseBody?: boolean
    responseHeaders?: boolean
    errorMessage?: boolean
    scheduledFor?: boolean
    lastAttemptAt?: boolean
    nextAttemptAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WebhookSubscriptionDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | WebhookSubscriptionDefaultArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      subscription: Prisma.$WebhookSubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      event: string
      payload: Prisma.JsonValue
      payloadHash: string
      status: $Enums.WebhookDeliveryStatus
      attemptCount: number
      maxAttempts: number
      responseStatus: number | null
      responseBody: string | null
      responseHeaders: Prisma.JsonValue | null
      errorMessage: string | null
      scheduledFor: Date
      lastAttemptAt: Date | null
      nextAttemptAt: Date | null
      deliveredAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends WebhookSubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookSubscriptionDefaultArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */ 
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly subscriptionId: FieldRef<"WebhookDelivery", 'String'>
    readonly event: FieldRef<"WebhookDelivery", 'String'>
    readonly payload: FieldRef<"WebhookDelivery", 'Json'>
    readonly payloadHash: FieldRef<"WebhookDelivery", 'String'>
    readonly status: FieldRef<"WebhookDelivery", 'WebhookDeliveryStatus'>
    readonly attemptCount: FieldRef<"WebhookDelivery", 'Int'>
    readonly maxAttempts: FieldRef<"WebhookDelivery", 'Int'>
    readonly responseStatus: FieldRef<"WebhookDelivery", 'Int'>
    readonly responseBody: FieldRef<"WebhookDelivery", 'String'>
    readonly responseHeaders: FieldRef<"WebhookDelivery", 'Json'>
    readonly errorMessage: FieldRef<"WebhookDelivery", 'String'>
    readonly scheduledFor: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly lastAttemptAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly nextAttemptAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly deliveredAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly createdAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly updatedAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    event: string | null
    entityType: string | null
    entityId: string | null
    emittedAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    event: string | null
    entityType: string | null
    entityId: string | null
    emittedAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    companyId: number
    event: number
    entityType: number
    entityId: number
    payload: number
    emittedAt: number
    _all: number
  }


  export type WebhookEventMinAggregateInputType = {
    id?: true
    companyId?: true
    event?: true
    entityType?: true
    entityId?: true
    emittedAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    companyId?: true
    event?: true
    entityType?: true
    entityId?: true
    emittedAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    companyId?: true
    event?: true
    entityType?: true
    entityId?: true
    payload?: true
    emittedAt?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    companyId: string
    event: string
    entityType: string
    entityId: string
    payload: JsonValue
    emittedAt: Date
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    event?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    emittedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    event?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    emittedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    companyId?: boolean
    event?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    emittedAt?: boolean
  }


  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      event: string
      entityType: string
      entityId: string
      payload: Prisma.JsonValue
      emittedAt: Date
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */ 
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly companyId: FieldRef<"WebhookEvent", 'String'>
    readonly event: FieldRef<"WebhookEvent", 'String'>
    readonly entityType: FieldRef<"WebhookEvent", 'String'>
    readonly entityId: FieldRef<"WebhookEvent", 'String'>
    readonly payload: FieldRef<"WebhookEvent", 'Json'>
    readonly emittedAt: FieldRef<"WebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorBackupCodes: 'twoFactorBackupCodes',
    ssoProvider: 'ssoProvider',
    ssoId: 'ssoId',
    ssoMetadata: 'ssoMetadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    legalName: 'legalName',
    taxId: 'taxId',
    taxIdType: 'taxIdType',
    address: 'address',
    city: 'city',
    province: 'province',
    postalCode: 'postalCode',
    country: 'country',
    region: 'region',
    phone: 'phone',
    email: 'email',
    website: 'website',
    currency: 'currency',
    fiscalYearStart: 'fiscalYearStart',
    logo: 'logo',
    verifactuEnabled: 'verifactuEnabled',
    verifactuId: 'verifactuId',
    verifactuLastHash: 'verifactuLastHash',
    defaultCryptoClassification: 'defaultCryptoClassification',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    role: 'role',
    isDefault: 'isDefault',
    createdAt: 'createdAt'
  };

  export type CompanyUserScalarFieldEnum = (typeof CompanyUserScalarFieldEnum)[keyof typeof CompanyUserScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    type: 'type',
    name: 'name',
    legalName: 'legalName',
    taxId: 'taxId',
    taxIdType: 'taxIdType',
    address: 'address',
    city: 'city',
    postalCode: 'postalCode',
    country: 'country',
    phone: 'phone',
    email: 'email',
    website: 'website',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const FiscalYearScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    isClosed: 'isClosed',
    closedAt: 'closedAt',
    closedBy: 'closedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FiscalYearScalarFieldEnum = (typeof FiscalYearScalarFieldEnum)[keyof typeof FiscalYearScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    code: 'code',
    name: 'name',
    type: 'type',
    parentCode: 'parentCode',
    description: 'description',
    isCrypto: 'isCrypto',
    cryptoAssetId: 'cryptoAssetId',
    isActive: 'isActive',
    isSystem: 'isSystem',
    allowDirectPosting: 'allowDirectPosting',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    fiscalYearId: 'fiscalYearId',
    number: 'number',
    date: 'date',
    description: 'description',
    reference: 'reference',
    referenceType: 'referenceType',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    status: 'status',
    isPosted: 'isPosted',
    postedAt: 'postedAt',
    postedBy: 'postedBy',
    isReversal: 'isReversal',
    reversalOf: 'reversalOf',
    reversedBy: 'reversedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const JournalLineScalarFieldEnum: {
    id: 'id',
    journalEntryId: 'journalEntryId',
    accountId: 'accountId',
    lineNumber: 'lineNumber',
    description: 'description',
    debit: 'debit',
    credit: 'credit',
    cryptoAmount: 'cryptoAmount',
    cryptoAsset: 'cryptoAsset',
    cryptoPrice: 'cryptoPrice',
    costCenter: 'costCenter',
    project: 'project',
    createdAt: 'createdAt'
  };

  export type JournalLineScalarFieldEnum = (typeof JournalLineScalarFieldEnum)[keyof typeof JournalLineScalarFieldEnum]


  export const InvoiceSeriesScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    code: 'code',
    name: 'name',
    type: 'type',
    prefix: 'prefix',
    suffix: 'suffix',
    nextNumber: 'nextNumber',
    digitCount: 'digitCount',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceSeriesScalarFieldEnum = (typeof InvoiceSeriesScalarFieldEnum)[keyof typeof InvoiceSeriesScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    seriesId: 'seriesId',
    contactId: 'contactId',
    number: 'number',
    fullNumber: 'fullNumber',
    type: 'type',
    status: 'status',
    direction: 'direction',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    operationDate: 'operationDate',
    paidAt: 'paidAt',
    counterpartyName: 'counterpartyName',
    counterpartyTaxId: 'counterpartyTaxId',
    counterpartyAddress: 'counterpartyAddress',
    counterpartyCity: 'counterpartyCity',
    counterpartyCountry: 'counterpartyCountry',
    subtotal: 'subtotal',
    discountAmount: 'discountAmount',
    taxableBase: 'taxableBase',
    totalTax: 'totalTax',
    total: 'total',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    cryptoPayment: 'cryptoPayment',
    cryptoAsset: 'cryptoAsset',
    cryptoAmount: 'cryptoAmount',
    cryptoRate: 'cryptoRate',
    cryptoTxHash: 'cryptoTxHash',
    verifactuHash: 'verifactuHash',
    verifactuPrevHash: 'verifactuPrevHash',
    verifactuQrData: 'verifactuQrData',
    verifactuSentAt: 'verifactuSentAt',
    verifactuResponse: 'verifactuResponse',
    verifactuStatus: 'verifactuStatus',
    notes: 'notes',
    internalNotes: 'internalNotes',
    paymentTerms: 'paymentTerms',
    paymentMethod: 'paymentMethod',
    journalEntryId: 'journalEntryId',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    lineNumber: 'lineNumber',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discount: 'discount',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    accountCode: 'accountCode'
  };

  export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


  export const InvoiceTaxScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    taxRate: 'taxRate',
    taxableBase: 'taxableBase',
    taxAmount: 'taxAmount',
    taxType: 'taxType'
  };

  export type InvoiceTaxScalarFieldEnum = (typeof InvoiceTaxScalarFieldEnum)[keyof typeof InvoiceTaxScalarFieldEnum]


  export const CryptoAssetScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    symbol: 'symbol',
    name: 'name',
    decimals: 'decimals',
    contractAddress: 'contractAddress',
    classification: 'classification',
    coingeckoId: 'coingeckoId',
    lastPrice: 'lastPrice',
    lastPriceAt: 'lastPriceAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoAssetScalarFieldEnum = (typeof CryptoAssetScalarFieldEnum)[keyof typeof CryptoAssetScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    address: 'address',
    chain: 'chain',
    label: 'label',
    type: 'type',
    lastSyncAt: 'lastSyncAt',
    lastSyncBlock: 'lastSyncBlock',
    syncStatus: 'syncStatus',
    syncError: 'syncError',
    accountCode: 'accountCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const ExchangeAccountScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    exchange: 'exchange',
    label: 'label',
    apiKey: 'apiKey',
    apiSecret: 'apiSecret',
    isReadOnly: 'isReadOnly',
    lastSyncAt: 'lastSyncAt',
    syncStatus: 'syncStatus',
    syncError: 'syncError',
    country: 'country',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExchangeAccountScalarFieldEnum = (typeof ExchangeAccountScalarFieldEnum)[keyof typeof ExchangeAccountScalarFieldEnum]


  export const CryptoTransactionScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    txHash: 'txHash',
    blockNumber: 'blockNumber',
    blockTimestamp: 'blockTimestamp',
    chain: 'chain',
    type: 'type',
    subtype: 'subtype',
    assetIn: 'assetIn',
    amountIn: 'amountIn',
    assetOut: 'assetOut',
    amountOut: 'amountOut',
    feeAsset: 'feeAsset',
    feeAmount: 'feeAmount',
    priceInEur: 'priceInEur',
    priceOutEur: 'priceOutEur',
    feeEur: 'feeEur',
    costBasis: 'costBasis',
    realizedGain: 'realizedGain',
    aiCategorized: 'aiCategorized',
    aiConfidence: 'aiConfidence',
    aiReasoning: 'aiReasoning',
    manualType: 'manualType',
    manualNotes: 'manualNotes',
    journalEntryId: 'journalEntryId',
    status: 'status',
    rawData: 'rawData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoTransactionScalarFieldEnum = (typeof CryptoTransactionScalarFieldEnum)[keyof typeof CryptoTransactionScalarFieldEnum]


  export const CryptoLotScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    cryptoAssetId: 'cryptoAssetId',
    acquiredAt: 'acquiredAt',
    acquiredAmount: 'acquiredAmount',
    costBasisEur: 'costBasisEur',
    costPerUnit: 'costPerUnit',
    remainingAmount: 'remainingAmount',
    sourceTxId: 'sourceTxId',
    sourceType: 'sourceType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoLotScalarFieldEnum = (typeof CryptoLotScalarFieldEnum)[keyof typeof CryptoLotScalarFieldEnum]


  export const PriceHistoryScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    priceEur: 'priceEur',
    source: 'source',
    timestamp: 'timestamp'
  };

  export type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]


  export const VerifactuRecordScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    hash: 'hash',
    prevHash: 'prevHash',
    xmlContent: 'xmlContent',
    state: 'state',
    csv: 'csv',
    sentAt: 'sentAt',
    retryCount: 'retryCount',
    aeatResponse: 'aeatResponse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerifactuRecordScalarFieldEnum = (typeof VerifactuRecordScalarFieldEnum)[keyof typeof VerifactuRecordScalarFieldEnum]


  export const AiConversationScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    title: 'title',
    context: 'context',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiConversationScalarFieldEnum = (typeof AiConversationScalarFieldEnum)[keyof typeof AiConversationScalarFieldEnum]


  export const AiMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    provider: 'provider',
    model: 'model',
    latencyMs: 'latencyMs',
    createdAt: 'createdAt'
  };

  export type AiMessageScalarFieldEnum = (typeof AiMessageScalarFieldEnum)[keyof typeof AiMessageScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    title: 'title',
    content: 'content',
    type: 'type',
    sourceUrl: 'sourceUrl',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CompanyInvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    role: 'role',
    token: 'token',
    status: 'status',
    companyId: 'companyId',
    inviterId: 'inviterId',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt',
    acceptedBy: 'acceptedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyInvitationScalarFieldEnum = (typeof CompanyInvitationScalarFieldEnum)[keyof typeof CompanyInvitationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    changes: 'changes',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    eventType: 'eventType',
    category: 'category',
    value: 'value',
    currency: 'currency',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const OAuthAppScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    createdById: 'createdById',
    name: 'name',
    description: 'description',
    logoUrl: 'logoUrl',
    website: 'website',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    redirectUris: 'redirectUris',
    scopes: 'scopes',
    rateLimit: 'rateLimit',
    dailyQuota: 'dailyQuota',
    isActive: 'isActive',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OAuthAppScalarFieldEnum = (typeof OAuthAppScalarFieldEnum)[keyof typeof OAuthAppScalarFieldEnum]


  export const OAuthTokenScalarFieldEnum: {
    id: 'id',
    appId: 'appId',
    userId: 'userId',
    companyId: 'companyId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    scopes: 'scopes',
    expiresAt: 'expiresAt',
    refreshExpiresAt: 'refreshExpiresAt',
    authorizationCode: 'authorizationCode',
    codeExpiresAt: 'codeExpiresAt',
    isRevoked: 'isRevoked',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type OAuthTokenScalarFieldEnum = (typeof OAuthTokenScalarFieldEnum)[keyof typeof OAuthTokenScalarFieldEnum]


  export const ApiUsageScalarFieldEnum: {
    id: 'id',
    appId: 'appId',
    companyId: 'companyId',
    userId: 'userId',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    responseTime: 'responseTime',
    requestCount: 'requestCount',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type ApiUsageScalarFieldEnum = (typeof ApiUsageScalarFieldEnum)[keyof typeof ApiUsageScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    stripePriceId: 'stripePriceId',
    monthlyPrice: 'monthlyPrice',
    yearlyPrice: 'yearlyPrice',
    currency: 'currency',
    maxCompanies: 'maxCompanies',
    maxUsers: 'maxUsers',
    maxInvoicesPerMonth: 'maxInvoicesPerMonth',
    maxWallets: 'maxWallets',
    maxAiMessagesPerMonth: 'maxAiMessagesPerMonth',
    verifactuEnabled: 'verifactuEnabled',
    siiEnabled: 'siiEnabled',
    aiChatEnabled: 'aiChatEnabled',
    aiOcrEnabled: 'aiOcrEnabled',
    cryptoEnabled: 'cryptoEnabled',
    multiUserEnabled: 'multiUserEnabled',
    prioritySupport: 'prioritySupport',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    planId: 'planId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    trialEndsAt: 'trialEndsAt',
    invoicesThisMonth: 'invoicesThisMonth',
    aiMessagesThisMonth: 'aiMessagesThisMonth',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    stripePaymentIntentId: 'stripePaymentIntentId',
    stripeInvoiceId: 'stripeInvoiceId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    description: 'description',
    failureReason: 'failureReason',
    paidAt: 'paidAt',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const UserOnboardingScalarFieldEnum: {
    userId: 'userId',
    status: 'status',
    currentStep: 'currentStep',
    completedSteps: 'completedSteps',
    skippedSteps: 'skippedSteps',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    lastActivityAt: 'lastActivityAt'
  };

  export type UserOnboardingScalarFieldEnum = (typeof UserOnboardingScalarFieldEnum)[keyof typeof UserOnboardingScalarFieldEnum]


  export const WebhookSubscriptionScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    url: 'url',
    secret: 'secret',
    isActive: 'isActive',
    events: 'events',
    retryCount: 'retryCount',
    timeout: 'timeout',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookSubscriptionScalarFieldEnum = (typeof WebhookSubscriptionScalarFieldEnum)[keyof typeof WebhookSubscriptionScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    event: 'event',
    payload: 'payload',
    payloadHash: 'payloadHash',
    status: 'status',
    attemptCount: 'attemptCount',
    maxAttempts: 'maxAttempts',
    responseStatus: 'responseStatus',
    responseBody: 'responseBody',
    responseHeaders: 'responseHeaders',
    errorMessage: 'errorMessage',
    scheduledFor: 'scheduledFor',
    lastAttemptAt: 'lastAttemptAt',
    nextAttemptAt: 'nextAttemptAt',
    deliveredAt: 'deliveredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    event: 'event',
    entityType: 'entityType',
    entityId: 'entityId',
    payload: 'payload',
    emittedAt: 'emittedAt'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorBackupCodes: 'twoFactorBackupCodes',
    ssoProvider: 'ssoProvider',
    ssoId: 'ssoId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const CompanyOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    legalName: 'legalName',
    taxId: 'taxId',
    address: 'address',
    city: 'city',
    province: 'province',
    postalCode: 'postalCode',
    country: 'country',
    region: 'region',
    phone: 'phone',
    email: 'email',
    website: 'website',
    currency: 'currency',
    logo: 'logo',
    verifactuId: 'verifactuId',
    verifactuLastHash: 'verifactuLastHash'
  };

  export type CompanyOrderByRelevanceFieldEnum = (typeof CompanyOrderByRelevanceFieldEnum)[keyof typeof CompanyOrderByRelevanceFieldEnum]


  export const CompanyUserOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId'
  };

  export type CompanyUserOrderByRelevanceFieldEnum = (typeof CompanyUserOrderByRelevanceFieldEnum)[keyof typeof CompanyUserOrderByRelevanceFieldEnum]


  export const ContactOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    legalName: 'legalName',
    taxId: 'taxId',
    address: 'address',
    city: 'city',
    postalCode: 'postalCode',
    country: 'country',
    phone: 'phone',
    email: 'email',
    website: 'website',
    notes: 'notes'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const FiscalYearOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    closedBy: 'closedBy',
    notes: 'notes'
  };

  export type FiscalYearOrderByRelevanceFieldEnum = (typeof FiscalYearOrderByRelevanceFieldEnum)[keyof typeof FiscalYearOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    code: 'code',
    name: 'name',
    parentCode: 'parentCode',
    description: 'description',
    cryptoAssetId: 'cryptoAssetId'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const JournalEntryOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    fiscalYearId: 'fiscalYearId',
    description: 'description',
    reference: 'reference',
    sourceId: 'sourceId',
    postedBy: 'postedBy',
    reversalOf: 'reversalOf',
    reversedBy: 'reversedBy'
  };

  export type JournalEntryOrderByRelevanceFieldEnum = (typeof JournalEntryOrderByRelevanceFieldEnum)[keyof typeof JournalEntryOrderByRelevanceFieldEnum]


  export const JournalLineOrderByRelevanceFieldEnum: {
    id: 'id',
    journalEntryId: 'journalEntryId',
    accountId: 'accountId',
    description: 'description',
    cryptoAsset: 'cryptoAsset',
    costCenter: 'costCenter',
    project: 'project'
  };

  export type JournalLineOrderByRelevanceFieldEnum = (typeof JournalLineOrderByRelevanceFieldEnum)[keyof typeof JournalLineOrderByRelevanceFieldEnum]


  export const InvoiceSeriesOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    code: 'code',
    name: 'name',
    prefix: 'prefix',
    suffix: 'suffix'
  };

  export type InvoiceSeriesOrderByRelevanceFieldEnum = (typeof InvoiceSeriesOrderByRelevanceFieldEnum)[keyof typeof InvoiceSeriesOrderByRelevanceFieldEnum]


  export const InvoiceOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    seriesId: 'seriesId',
    contactId: 'contactId',
    fullNumber: 'fullNumber',
    counterpartyName: 'counterpartyName',
    counterpartyTaxId: 'counterpartyTaxId',
    counterpartyAddress: 'counterpartyAddress',
    counterpartyCity: 'counterpartyCity',
    counterpartyCountry: 'counterpartyCountry',
    currency: 'currency',
    cryptoAsset: 'cryptoAsset',
    cryptoTxHash: 'cryptoTxHash',
    verifactuHash: 'verifactuHash',
    verifactuPrevHash: 'verifactuPrevHash',
    verifactuQrData: 'verifactuQrData',
    notes: 'notes',
    internalNotes: 'internalNotes',
    paymentTerms: 'paymentTerms',
    paymentMethod: 'paymentMethod',
    journalEntryId: 'journalEntryId',
    pdfUrl: 'pdfUrl'
  };

  export type InvoiceOrderByRelevanceFieldEnum = (typeof InvoiceOrderByRelevanceFieldEnum)[keyof typeof InvoiceOrderByRelevanceFieldEnum]


  export const InvoiceLineOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    accountCode: 'accountCode'
  };

  export type InvoiceLineOrderByRelevanceFieldEnum = (typeof InvoiceLineOrderByRelevanceFieldEnum)[keyof typeof InvoiceLineOrderByRelevanceFieldEnum]


  export const InvoiceTaxOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId'
  };

  export type InvoiceTaxOrderByRelevanceFieldEnum = (typeof InvoiceTaxOrderByRelevanceFieldEnum)[keyof typeof InvoiceTaxOrderByRelevanceFieldEnum]


  export const CryptoAssetOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    symbol: 'symbol',
    name: 'name',
    contractAddress: 'contractAddress',
    coingeckoId: 'coingeckoId'
  };

  export type CryptoAssetOrderByRelevanceFieldEnum = (typeof CryptoAssetOrderByRelevanceFieldEnum)[keyof typeof CryptoAssetOrderByRelevanceFieldEnum]


  export const WalletOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    address: 'address',
    chain: 'chain',
    label: 'label',
    syncError: 'syncError',
    accountCode: 'accountCode'
  };

  export type WalletOrderByRelevanceFieldEnum = (typeof WalletOrderByRelevanceFieldEnum)[keyof typeof WalletOrderByRelevanceFieldEnum]


  export const ExchangeAccountOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    exchange: 'exchange',
    label: 'label',
    apiKey: 'apiKey',
    apiSecret: 'apiSecret',
    syncError: 'syncError',
    country: 'country'
  };

  export type ExchangeAccountOrderByRelevanceFieldEnum = (typeof ExchangeAccountOrderByRelevanceFieldEnum)[keyof typeof ExchangeAccountOrderByRelevanceFieldEnum]


  export const CryptoTransactionOrderByRelevanceFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    txHash: 'txHash',
    chain: 'chain',
    subtype: 'subtype',
    assetIn: 'assetIn',
    assetOut: 'assetOut',
    feeAsset: 'feeAsset',
    aiReasoning: 'aiReasoning',
    manualNotes: 'manualNotes',
    journalEntryId: 'journalEntryId'
  };

  export type CryptoTransactionOrderByRelevanceFieldEnum = (typeof CryptoTransactionOrderByRelevanceFieldEnum)[keyof typeof CryptoTransactionOrderByRelevanceFieldEnum]


  export const CryptoLotOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    cryptoAssetId: 'cryptoAssetId',
    sourceTxId: 'sourceTxId',
    sourceType: 'sourceType'
  };

  export type CryptoLotOrderByRelevanceFieldEnum = (typeof CryptoLotOrderByRelevanceFieldEnum)[keyof typeof CryptoLotOrderByRelevanceFieldEnum]


  export const PriceHistoryOrderByRelevanceFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    source: 'source'
  };

  export type PriceHistoryOrderByRelevanceFieldEnum = (typeof PriceHistoryOrderByRelevanceFieldEnum)[keyof typeof PriceHistoryOrderByRelevanceFieldEnum]


  export const VerifactuRecordOrderByRelevanceFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    hash: 'hash',
    prevHash: 'prevHash',
    xmlContent: 'xmlContent',
    csv: 'csv'
  };

  export type VerifactuRecordOrderByRelevanceFieldEnum = (typeof VerifactuRecordOrderByRelevanceFieldEnum)[keyof typeof VerifactuRecordOrderByRelevanceFieldEnum]


  export const AiConversationOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    title: 'title'
  };

  export type AiConversationOrderByRelevanceFieldEnum = (typeof AiConversationOrderByRelevanceFieldEnum)[keyof typeof AiConversationOrderByRelevanceFieldEnum]


  export const AiMessageOrderByRelevanceFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    content: 'content',
    provider: 'provider',
    model: 'model'
  };

  export type AiMessageOrderByRelevanceFieldEnum = (typeof AiMessageOrderByRelevanceFieldEnum)[keyof typeof AiMessageOrderByRelevanceFieldEnum]


  export const DocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    title: 'title',
    content: 'content',
    sourceUrl: 'sourceUrl'
  };

  export type DocumentOrderByRelevanceFieldEnum = (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum]


  export const CompanyInvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    companyId: 'companyId',
    inviterId: 'inviterId',
    acceptedBy: 'acceptedBy'
  };

  export type CompanyInvitationOrderByRelevanceFieldEnum = (typeof CompanyInvitationOrderByRelevanceFieldEnum)[keyof typeof CompanyInvitationOrderByRelevanceFieldEnum]


  export const AuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    entity: 'entity',
    entityId: 'entityId'
  };

  export type AuditLogOrderByRelevanceFieldEnum = (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum]


  export const AnalyticsEventOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    eventType: 'eventType',
    category: 'category',
    currency: 'currency'
  };

  export type AnalyticsEventOrderByRelevanceFieldEnum = (typeof AnalyticsEventOrderByRelevanceFieldEnum)[keyof typeof AnalyticsEventOrderByRelevanceFieldEnum]


  export const OAuthAppOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    createdById: 'createdById',
    name: 'name',
    description: 'description',
    logoUrl: 'logoUrl',
    website: 'website',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    redirectUris: 'redirectUris',
    scopes: 'scopes'
  };

  export type OAuthAppOrderByRelevanceFieldEnum = (typeof OAuthAppOrderByRelevanceFieldEnum)[keyof typeof OAuthAppOrderByRelevanceFieldEnum]


  export const OAuthTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    appId: 'appId',
    userId: 'userId',
    companyId: 'companyId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    scopes: 'scopes',
    authorizationCode: 'authorizationCode'
  };

  export type OAuthTokenOrderByRelevanceFieldEnum = (typeof OAuthTokenOrderByRelevanceFieldEnum)[keyof typeof OAuthTokenOrderByRelevanceFieldEnum]


  export const ApiUsageOrderByRelevanceFieldEnum: {
    id: 'id',
    appId: 'appId',
    companyId: 'companyId',
    userId: 'userId',
    endpoint: 'endpoint',
    method: 'method',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type ApiUsageOrderByRelevanceFieldEnum = (typeof ApiUsageOrderByRelevanceFieldEnum)[keyof typeof ApiUsageOrderByRelevanceFieldEnum]


  export const SubscriptionPlanOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    stripePriceId: 'stripePriceId',
    currency: 'currency'
  };

  export type SubscriptionPlanOrderByRelevanceFieldEnum = (typeof SubscriptionPlanOrderByRelevanceFieldEnum)[keyof typeof SubscriptionPlanOrderByRelevanceFieldEnum]


  export const SubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    planId: 'planId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId'
  };

  export type SubscriptionOrderByRelevanceFieldEnum = (typeof SubscriptionOrderByRelevanceFieldEnum)[keyof typeof SubscriptionOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    stripePaymentIntentId: 'stripePaymentIntentId',
    stripeInvoiceId: 'stripeInvoiceId',
    currency: 'currency',
    description: 'description',
    failureReason: 'failureReason'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const UserOnboardingOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type UserOnboardingOrderByRelevanceFieldEnum = (typeof UserOnboardingOrderByRelevanceFieldEnum)[keyof typeof UserOnboardingOrderByRelevanceFieldEnum]


  export const WebhookSubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    url: 'url',
    secret: 'secret',
    description: 'description'
  };

  export type WebhookSubscriptionOrderByRelevanceFieldEnum = (typeof WebhookSubscriptionOrderByRelevanceFieldEnum)[keyof typeof WebhookSubscriptionOrderByRelevanceFieldEnum]


  export const WebhookDeliveryOrderByRelevanceFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    event: 'event',
    payloadHash: 'payloadHash',
    responseBody: 'responseBody',
    errorMessage: 'errorMessage'
  };

  export type WebhookDeliveryOrderByRelevanceFieldEnum = (typeof WebhookDeliveryOrderByRelevanceFieldEnum)[keyof typeof WebhookDeliveryOrderByRelevanceFieldEnum]


  export const WebhookEventOrderByRelevanceFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    event: 'event',
    entityType: 'entityType',
    entityId: 'entityId'
  };

  export type WebhookEventOrderByRelevanceFieldEnum = (typeof WebhookEventOrderByRelevanceFieldEnum)[keyof typeof WebhookEventOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'TaxIdType'
   */
  export type EnumTaxIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxIdType'>
    


  /**
   * Reference to a field of type 'TaxIdType[]'
   */
  export type ListEnumTaxIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxIdType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CryptoClassification'
   */
  export type EnumCryptoClassificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CryptoClassification'>
    


  /**
   * Reference to a field of type 'CryptoClassification[]'
   */
  export type ListEnumCryptoClassificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CryptoClassification[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'ReferenceType'
   */
  export type EnumReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferenceType'>
    


  /**
   * Reference to a field of type 'ReferenceType[]'
   */
  export type ListEnumReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferenceType[]'>
    


  /**
   * Reference to a field of type 'SourceType'
   */
  export type EnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType'>
    


  /**
   * Reference to a field of type 'SourceType[]'
   */
  export type ListEnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType[]'>
    


  /**
   * Reference to a field of type 'JournalStatus'
   */
  export type EnumJournalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalStatus'>
    


  /**
   * Reference to a field of type 'JournalStatus[]'
   */
  export type ListEnumJournalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceDirection'
   */
  export type EnumInvoiceDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceDirection'>
    


  /**
   * Reference to a field of type 'InvoiceDirection[]'
   */
  export type ListEnumInvoiceDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceDirection[]'>
    


  /**
   * Reference to a field of type 'VerifactuStatus'
   */
  export type EnumVerifactuStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerifactuStatus'>
    


  /**
   * Reference to a field of type 'VerifactuStatus[]'
   */
  export type ListEnumVerifactuStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerifactuStatus[]'>
    


  /**
   * Reference to a field of type 'TaxType'
   */
  export type EnumTaxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxType'>
    


  /**
   * Reference to a field of type 'TaxType[]'
   */
  export type ListEnumTaxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxType[]'>
    


  /**
   * Reference to a field of type 'WalletType'
   */
  export type EnumWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletType'>
    


  /**
   * Reference to a field of type 'WalletType[]'
   */
  export type ListEnumWalletTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'SyncStatus'
   */
  export type EnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus'>
    


  /**
   * Reference to a field of type 'SyncStatus[]'
   */
  export type ListEnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus[]'>
    


  /**
   * Reference to a field of type 'CryptoTxType'
   */
  export type EnumCryptoTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CryptoTxType'>
    


  /**
   * Reference to a field of type 'CryptoTxType[]'
   */
  export type ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CryptoTxType[]'>
    


  /**
   * Reference to a field of type 'TxStatus'
   */
  export type EnumTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxStatus'>
    


  /**
   * Reference to a field of type 'TxStatus[]'
   */
  export type ListEnumTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxStatus[]'>
    


  /**
   * Reference to a field of type 'VerifactuRecordState'
   */
  export type EnumVerifactuRecordStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerifactuRecordState'>
    


  /**
   * Reference to a field of type 'VerifactuRecordState[]'
   */
  export type ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerifactuRecordState[]'>
    


  /**
   * Reference to a field of type 'AiRole'
   */
  export type EnumAiRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiRole'>
    


  /**
   * Reference to a field of type 'AiRole[]'
   */
  export type ListEnumAiRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiRole[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'UserOnboardingStatus'
   */
  export type EnumUserOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserOnboardingStatus'>
    


  /**
   * Reference to a field of type 'UserOnboardingStatus[]'
   */
  export type ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserOnboardingStatus[]'>
    


  /**
   * Reference to a field of type 'WebhookDeliveryStatus'
   */
  export type EnumWebhookDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookDeliveryStatus'>
    


  /**
   * Reference to a field of type 'WebhookDeliveryStatus[]'
   */
  export type ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookDeliveryStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoId?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companyUsers?: CompanyUserListRelationFilter
    aiConversations?: AiConversationListRelationFilter
    invitationsSent?: CompanyInvitationListRelationFilter
    invitationsAccepted?: CompanyInvitationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    onboarding?: XOR<UserOnboardingNullableRelationFilter, UserOnboardingWhereInput> | null
    analyticsEvents?: AnalyticsEventListRelationFilter
    oauthAppsCreated?: OAuthAppListRelationFilter
    oauthTokens?: OAuthTokenListRelationFilter
    apiUsage?: ApiUsageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoId?: SortOrderInput | SortOrder
    ssoMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyUsers?: CompanyUserOrderByRelationAggregateInput
    aiConversations?: AiConversationOrderByRelationAggregateInput
    invitationsSent?: CompanyInvitationOrderByRelationAggregateInput
    invitationsAccepted?: CompanyInvitationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    onboarding?: UserOnboardingOrderByWithRelationInput
    analyticsEvents?: AnalyticsEventOrderByRelationAggregateInput
    oauthAppsCreated?: OAuthAppOrderByRelationAggregateInput
    oauthTokens?: OAuthTokenOrderByRelationAggregateInput
    apiUsage?: ApiUsageOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    ssoProvider_ssoId?: UserSsoProviderSsoIdCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoId?: StringNullableFilter<"User"> | string | null
    ssoMetadata?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companyUsers?: CompanyUserListRelationFilter
    aiConversations?: AiConversationListRelationFilter
    invitationsSent?: CompanyInvitationListRelationFilter
    invitationsAccepted?: CompanyInvitationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    onboarding?: XOR<UserOnboardingNullableRelationFilter, UserOnboardingWhereInput> | null
    analyticsEvents?: AnalyticsEventListRelationFilter
    oauthAppsCreated?: OAuthAppListRelationFilter
    oauthTokens?: OAuthTokenListRelationFilter
    apiUsage?: ApiUsageListRelationFilter
  }, "id" | "email" | "ssoProvider_ssoId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoId?: SortOrderInput | SortOrder
    ssoMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoId?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoMetadata?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: UuidFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    legalName?: StringNullableFilter<"Company"> | string | null
    taxId?: StringFilter<"Company"> | string
    taxIdType?: EnumTaxIdTypeFilter<"Company"> | $Enums.TaxIdType
    address?: StringNullableFilter<"Company"> | string | null
    city?: StringNullableFilter<"Company"> | string | null
    province?: StringNullableFilter<"Company"> | string | null
    postalCode?: StringNullableFilter<"Company"> | string | null
    country?: StringFilter<"Company"> | string
    region?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    currency?: StringFilter<"Company"> | string
    fiscalYearStart?: IntFilter<"Company"> | number
    logo?: StringNullableFilter<"Company"> | string | null
    verifactuEnabled?: BoolFilter<"Company"> | boolean
    verifactuId?: StringNullableFilter<"Company"> | string | null
    verifactuLastHash?: StringNullableFilter<"Company"> | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFilter<"Company"> | $Enums.CryptoClassification
    settings?: JsonNullableFilter<"Company">
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    companyUsers?: CompanyUserListRelationFilter
    fiscalYears?: FiscalYearListRelationFilter
    accounts?: AccountListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    invoices?: InvoiceListRelationFilter
    invoiceSeries?: InvoiceSeriesListRelationFilter
    contacts?: ContactListRelationFilter
    wallets?: WalletListRelationFilter
    cryptoAssets?: CryptoAssetListRelationFilter
    cryptoLots?: CryptoLotListRelationFilter
    exchangeAccounts?: ExchangeAccountListRelationFilter
    aiConversations?: AiConversationListRelationFilter
    documents?: DocumentListRelationFilter
    invitations?: CompanyInvitationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    webhookSubscriptions?: WebhookSubscriptionListRelationFilter
    analyticsEvents?: AnalyticsEventListRelationFilter
    oauthApps?: OAuthAppListRelationFilter
    oauthTokens?: OAuthTokenListRelationFilter
    apiUsage?: ApiUsageListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    region?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    currency?: SortOrder
    fiscalYearStart?: SortOrder
    logo?: SortOrderInput | SortOrder
    verifactuEnabled?: SortOrder
    verifactuId?: SortOrderInput | SortOrder
    verifactuLastHash?: SortOrderInput | SortOrder
    defaultCryptoClassification?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    companyUsers?: CompanyUserOrderByRelationAggregateInput
    fiscalYears?: FiscalYearOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    invoiceSeries?: InvoiceSeriesOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    wallets?: WalletOrderByRelationAggregateInput
    cryptoAssets?: CryptoAssetOrderByRelationAggregateInput
    cryptoLots?: CryptoLotOrderByRelationAggregateInput
    exchangeAccounts?: ExchangeAccountOrderByRelationAggregateInput
    aiConversations?: AiConversationOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    invitations?: CompanyInvitationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    webhookSubscriptions?: WebhookSubscriptionOrderByRelationAggregateInput
    analyticsEvents?: AnalyticsEventOrderByRelationAggregateInput
    oauthApps?: OAuthAppOrderByRelationAggregateInput
    oauthTokens?: OAuthTokenOrderByRelationAggregateInput
    apiUsage?: ApiUsageOrderByRelationAggregateInput
    _relevance?: CompanyOrderByRelevanceInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    legalName?: StringNullableFilter<"Company"> | string | null
    taxId?: StringFilter<"Company"> | string
    taxIdType?: EnumTaxIdTypeFilter<"Company"> | $Enums.TaxIdType
    address?: StringNullableFilter<"Company"> | string | null
    city?: StringNullableFilter<"Company"> | string | null
    province?: StringNullableFilter<"Company"> | string | null
    postalCode?: StringNullableFilter<"Company"> | string | null
    country?: StringFilter<"Company"> | string
    region?: StringFilter<"Company"> | string
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    currency?: StringFilter<"Company"> | string
    fiscalYearStart?: IntFilter<"Company"> | number
    logo?: StringNullableFilter<"Company"> | string | null
    verifactuEnabled?: BoolFilter<"Company"> | boolean
    verifactuId?: StringNullableFilter<"Company"> | string | null
    verifactuLastHash?: StringNullableFilter<"Company"> | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFilter<"Company"> | $Enums.CryptoClassification
    settings?: JsonNullableFilter<"Company">
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    companyUsers?: CompanyUserListRelationFilter
    fiscalYears?: FiscalYearListRelationFilter
    accounts?: AccountListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    invoices?: InvoiceListRelationFilter
    invoiceSeries?: InvoiceSeriesListRelationFilter
    contacts?: ContactListRelationFilter
    wallets?: WalletListRelationFilter
    cryptoAssets?: CryptoAssetListRelationFilter
    cryptoLots?: CryptoLotListRelationFilter
    exchangeAccounts?: ExchangeAccountListRelationFilter
    aiConversations?: AiConversationListRelationFilter
    documents?: DocumentListRelationFilter
    invitations?: CompanyInvitationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    webhookSubscriptions?: WebhookSubscriptionListRelationFilter
    analyticsEvents?: AnalyticsEventListRelationFilter
    oauthApps?: OAuthAppListRelationFilter
    oauthTokens?: OAuthTokenListRelationFilter
    apiUsage?: ApiUsageListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    region?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    currency?: SortOrder
    fiscalYearStart?: SortOrder
    logo?: SortOrderInput | SortOrder
    verifactuEnabled?: SortOrder
    verifactuId?: SortOrderInput | SortOrder
    verifactuLastHash?: SortOrderInput | SortOrder
    defaultCryptoClassification?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    legalName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    taxId?: StringWithAggregatesFilter<"Company"> | string
    taxIdType?: EnumTaxIdTypeWithAggregatesFilter<"Company"> | $Enums.TaxIdType
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    city?: StringNullableWithAggregatesFilter<"Company"> | string | null
    province?: StringNullableWithAggregatesFilter<"Company"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Company"> | string | null
    country?: StringWithAggregatesFilter<"Company"> | string
    region?: StringWithAggregatesFilter<"Company"> | string
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    currency?: StringWithAggregatesFilter<"Company"> | string
    fiscalYearStart?: IntWithAggregatesFilter<"Company"> | number
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    verifactuEnabled?: BoolWithAggregatesFilter<"Company"> | boolean
    verifactuId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    verifactuLastHash?: StringNullableWithAggregatesFilter<"Company"> | string | null
    defaultCryptoClassification?: EnumCryptoClassificationWithAggregatesFilter<"Company"> | $Enums.CryptoClassification
    settings?: JsonNullableWithAggregatesFilter<"Company">
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
  }

  export type CompanyUserWhereInput = {
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    id?: UuidFilter<"CompanyUser"> | string
    userId?: UuidFilter<"CompanyUser"> | string
    companyId?: UuidFilter<"CompanyUser"> | string
    role?: EnumUserRoleFilter<"CompanyUser"> | $Enums.UserRole
    isDefault?: BoolFilter<"CompanyUser"> | boolean
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type CompanyUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    _relevance?: CompanyUserOrderByRelevanceInput
  }

  export type CompanyUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_companyId?: CompanyUserUserIdCompanyIdCompoundUniqueInput
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    userId?: UuidFilter<"CompanyUser"> | string
    companyId?: UuidFilter<"CompanyUser"> | string
    role?: EnumUserRoleFilter<"CompanyUser"> | $Enums.UserRole
    isDefault?: BoolFilter<"CompanyUser"> | boolean
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "userId_companyId">

  export type CompanyUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    _count?: CompanyUserCountOrderByAggregateInput
    _max?: CompanyUserMaxOrderByAggregateInput
    _min?: CompanyUserMinOrderByAggregateInput
  }

  export type CompanyUserScalarWhereWithAggregatesInput = {
    AND?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    OR?: CompanyUserScalarWhereWithAggregatesInput[]
    NOT?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CompanyUser"> | string
    userId?: UuidWithAggregatesFilter<"CompanyUser"> | string
    companyId?: UuidWithAggregatesFilter<"CompanyUser"> | string
    role?: EnumUserRoleWithAggregatesFilter<"CompanyUser"> | $Enums.UserRole
    isDefault?: BoolWithAggregatesFilter<"CompanyUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CompanyUser"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: UuidFilter<"Contact"> | string
    companyId?: UuidFilter<"Contact"> | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    name?: StringFilter<"Contact"> | string
    legalName?: StringNullableFilter<"Contact"> | string | null
    taxId?: StringNullableFilter<"Contact"> | string | null
    taxIdType?: EnumTaxIdTypeNullableFilter<"Contact"> | $Enums.TaxIdType | null
    address?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    country?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    taxIdType?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    companyId?: UuidFilter<"Contact"> | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    name?: StringFilter<"Contact"> | string
    legalName?: StringNullableFilter<"Contact"> | string | null
    taxId?: StringNullableFilter<"Contact"> | string | null
    taxIdType?: EnumTaxIdTypeNullableFilter<"Contact"> | $Enums.TaxIdType | null
    address?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    country?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    taxIdType?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Contact"> | string
    companyId?: UuidWithAggregatesFilter<"Contact"> | string
    type?: EnumContactTypeWithAggregatesFilter<"Contact"> | $Enums.ContactType
    name?: StringWithAggregatesFilter<"Contact"> | string
    legalName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    taxIdType?: EnumTaxIdTypeNullableWithAggregatesFilter<"Contact"> | $Enums.TaxIdType | null
    address?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    city?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    country?: StringWithAggregatesFilter<"Contact"> | string
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    website?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isActive?: BoolWithAggregatesFilter<"Contact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type FiscalYearWhereInput = {
    AND?: FiscalYearWhereInput | FiscalYearWhereInput[]
    OR?: FiscalYearWhereInput[]
    NOT?: FiscalYearWhereInput | FiscalYearWhereInput[]
    id?: UuidFilter<"FiscalYear"> | string
    companyId?: UuidFilter<"FiscalYear"> | string
    name?: StringFilter<"FiscalYear"> | string
    startDate?: DateTimeFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeFilter<"FiscalYear"> | Date | string
    isClosed?: BoolFilter<"FiscalYear"> | boolean
    closedAt?: DateTimeNullableFilter<"FiscalYear"> | Date | string | null
    closedBy?: UuidNullableFilter<"FiscalYear"> | string | null
    notes?: StringNullableFilter<"FiscalYear"> | string | null
    createdAt?: DateTimeFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalYear"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    journalEntries?: JournalEntryListRelationFilter
  }

  export type FiscalYearOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    _relevance?: FiscalYearOrderByRelevanceInput
  }

  export type FiscalYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_name?: FiscalYearCompanyIdNameCompoundUniqueInput
    AND?: FiscalYearWhereInput | FiscalYearWhereInput[]
    OR?: FiscalYearWhereInput[]
    NOT?: FiscalYearWhereInput | FiscalYearWhereInput[]
    companyId?: UuidFilter<"FiscalYear"> | string
    name?: StringFilter<"FiscalYear"> | string
    startDate?: DateTimeFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeFilter<"FiscalYear"> | Date | string
    isClosed?: BoolFilter<"FiscalYear"> | boolean
    closedAt?: DateTimeNullableFilter<"FiscalYear"> | Date | string | null
    closedBy?: UuidNullableFilter<"FiscalYear"> | string | null
    notes?: StringNullableFilter<"FiscalYear"> | string | null
    createdAt?: DateTimeFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalYear"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    journalEntries?: JournalEntryListRelationFilter
  }, "id" | "companyId_name">

  export type FiscalYearOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FiscalYearCountOrderByAggregateInput
    _max?: FiscalYearMaxOrderByAggregateInput
    _min?: FiscalYearMinOrderByAggregateInput
  }

  export type FiscalYearScalarWhereWithAggregatesInput = {
    AND?: FiscalYearScalarWhereWithAggregatesInput | FiscalYearScalarWhereWithAggregatesInput[]
    OR?: FiscalYearScalarWhereWithAggregatesInput[]
    NOT?: FiscalYearScalarWhereWithAggregatesInput | FiscalYearScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FiscalYear"> | string
    companyId?: UuidWithAggregatesFilter<"FiscalYear"> | string
    name?: StringWithAggregatesFilter<"FiscalYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    isClosed?: BoolWithAggregatesFilter<"FiscalYear"> | boolean
    closedAt?: DateTimeNullableWithAggregatesFilter<"FiscalYear"> | Date | string | null
    closedBy?: UuidNullableWithAggregatesFilter<"FiscalYear"> | string | null
    notes?: StringNullableWithAggregatesFilter<"FiscalYear"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: UuidFilter<"Account"> | string
    companyId?: UuidFilter<"Account"> | string
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    parentCode?: StringNullableFilter<"Account"> | string | null
    description?: StringNullableFilter<"Account"> | string | null
    isCrypto?: BoolFilter<"Account"> | boolean
    cryptoAssetId?: UuidNullableFilter<"Account"> | string | null
    isActive?: BoolFilter<"Account"> | boolean
    isSystem?: BoolFilter<"Account"> | boolean
    allowDirectPosting?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    cryptoAsset?: XOR<CryptoAssetNullableRelationFilter, CryptoAssetWhereInput> | null
    journalLines?: JournalLineListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentCode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isCrypto?: SortOrder
    cryptoAssetId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    allowDirectPosting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    cryptoAsset?: CryptoAssetOrderByWithRelationInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: AccountCompanyIdCodeCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    companyId?: UuidFilter<"Account"> | string
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    parentCode?: StringNullableFilter<"Account"> | string | null
    description?: StringNullableFilter<"Account"> | string | null
    isCrypto?: BoolFilter<"Account"> | boolean
    cryptoAssetId?: UuidNullableFilter<"Account"> | string | null
    isActive?: BoolFilter<"Account"> | boolean
    isSystem?: BoolFilter<"Account"> | boolean
    allowDirectPosting?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    cryptoAsset?: XOR<CryptoAssetNullableRelationFilter, CryptoAssetWhereInput> | null
    journalLines?: JournalLineListRelationFilter
  }, "id" | "companyId_code">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentCode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isCrypto?: SortOrder
    cryptoAssetId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    allowDirectPosting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Account"> | string
    companyId?: UuidWithAggregatesFilter<"Account"> | string
    code?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    parentCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    description?: StringNullableWithAggregatesFilter<"Account"> | string | null
    isCrypto?: BoolWithAggregatesFilter<"Account"> | boolean
    cryptoAssetId?: UuidNullableWithAggregatesFilter<"Account"> | string | null
    isActive?: BoolWithAggregatesFilter<"Account"> | boolean
    isSystem?: BoolWithAggregatesFilter<"Account"> | boolean
    allowDirectPosting?: BoolWithAggregatesFilter<"Account"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: UuidFilter<"JournalEntry"> | string
    companyId?: UuidFilter<"JournalEntry"> | string
    fiscalYearId?: UuidFilter<"JournalEntry"> | string
    number?: IntFilter<"JournalEntry"> | number
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringFilter<"JournalEntry"> | string
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    referenceType?: EnumReferenceTypeNullableFilter<"JournalEntry"> | $Enums.ReferenceType | null
    sourceType?: EnumSourceTypeNullableFilter<"JournalEntry"> | $Enums.SourceType | null
    sourceId?: StringNullableFilter<"JournalEntry"> | string | null
    status?: EnumJournalStatusFilter<"JournalEntry"> | $Enums.JournalStatus
    isPosted?: BoolFilter<"JournalEntry"> | boolean
    postedAt?: DateTimeNullableFilter<"JournalEntry"> | Date | string | null
    postedBy?: UuidNullableFilter<"JournalEntry"> | string | null
    isReversal?: BoolFilter<"JournalEntry"> | boolean
    reversalOf?: UuidNullableFilter<"JournalEntry"> | string | null
    reversedBy?: UuidNullableFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    fiscalYear?: XOR<FiscalYearRelationFilter, FiscalYearWhereInput>
    lines?: JournalLineListRelationFilter
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    fiscalYearId?: SortOrder
    number?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    status?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    postedBy?: SortOrderInput | SortOrder
    isReversal?: SortOrder
    reversalOf?: SortOrderInput | SortOrder
    reversedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    fiscalYear?: FiscalYearOrderByWithRelationInput
    lines?: JournalLineOrderByRelationAggregateInput
    _relevance?: JournalEntryOrderByRelevanceInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_fiscalYearId_number?: JournalEntryCompanyIdFiscalYearIdNumberCompoundUniqueInput
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    companyId?: UuidFilter<"JournalEntry"> | string
    fiscalYearId?: UuidFilter<"JournalEntry"> | string
    number?: IntFilter<"JournalEntry"> | number
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringFilter<"JournalEntry"> | string
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    referenceType?: EnumReferenceTypeNullableFilter<"JournalEntry"> | $Enums.ReferenceType | null
    sourceType?: EnumSourceTypeNullableFilter<"JournalEntry"> | $Enums.SourceType | null
    sourceId?: StringNullableFilter<"JournalEntry"> | string | null
    status?: EnumJournalStatusFilter<"JournalEntry"> | $Enums.JournalStatus
    isPosted?: BoolFilter<"JournalEntry"> | boolean
    postedAt?: DateTimeNullableFilter<"JournalEntry"> | Date | string | null
    postedBy?: UuidNullableFilter<"JournalEntry"> | string | null
    isReversal?: BoolFilter<"JournalEntry"> | boolean
    reversalOf?: UuidNullableFilter<"JournalEntry"> | string | null
    reversedBy?: UuidNullableFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    fiscalYear?: XOR<FiscalYearRelationFilter, FiscalYearWhereInput>
    lines?: JournalLineListRelationFilter
  }, "id" | "companyId_fiscalYearId_number">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    fiscalYearId?: SortOrder
    number?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    status?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    postedBy?: SortOrderInput | SortOrder
    isReversal?: SortOrder
    reversalOf?: SortOrderInput | SortOrder
    reversedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _avg?: JournalEntryAvgOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
    _sum?: JournalEntrySumOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"JournalEntry"> | string
    companyId?: UuidWithAggregatesFilter<"JournalEntry"> | string
    fiscalYearId?: UuidWithAggregatesFilter<"JournalEntry"> | string
    number?: IntWithAggregatesFilter<"JournalEntry"> | number
    date?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    description?: StringWithAggregatesFilter<"JournalEntry"> | string
    reference?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    referenceType?: EnumReferenceTypeNullableWithAggregatesFilter<"JournalEntry"> | $Enums.ReferenceType | null
    sourceType?: EnumSourceTypeNullableWithAggregatesFilter<"JournalEntry"> | $Enums.SourceType | null
    sourceId?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    status?: EnumJournalStatusWithAggregatesFilter<"JournalEntry"> | $Enums.JournalStatus
    isPosted?: BoolWithAggregatesFilter<"JournalEntry"> | boolean
    postedAt?: DateTimeNullableWithAggregatesFilter<"JournalEntry"> | Date | string | null
    postedBy?: UuidNullableWithAggregatesFilter<"JournalEntry"> | string | null
    isReversal?: BoolWithAggregatesFilter<"JournalEntry"> | boolean
    reversalOf?: UuidNullableWithAggregatesFilter<"JournalEntry"> | string | null
    reversedBy?: UuidNullableWithAggregatesFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
  }

  export type JournalLineWhereInput = {
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    id?: UuidFilter<"JournalLine"> | string
    journalEntryId?: UuidFilter<"JournalLine"> | string
    accountId?: UuidFilter<"JournalLine"> | string
    lineNumber?: IntFilter<"JournalLine"> | number
    description?: StringNullableFilter<"JournalLine"> | string | null
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    cryptoAmount?: DecimalNullableFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: StringNullableFilter<"JournalLine"> | string | null
    cryptoPrice?: DecimalNullableFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    costCenter?: StringNullableFilter<"JournalLine"> | string | null
    project?: StringNullableFilter<"JournalLine"> | string | null
    createdAt?: DateTimeFilter<"JournalLine"> | Date | string
    journalEntry?: XOR<JournalEntryRelationFilter, JournalEntryWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type JournalLineOrderByWithRelationInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrderInput | SortOrder
    debit?: SortOrder
    credit?: SortOrder
    cryptoAmount?: SortOrderInput | SortOrder
    cryptoAsset?: SortOrderInput | SortOrder
    cryptoPrice?: SortOrderInput | SortOrder
    costCenter?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    journalEntry?: JournalEntryOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    _relevance?: JournalLineOrderByRelevanceInput
  }

  export type JournalLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    journalEntryId_lineNumber?: JournalLineJournalEntryIdLineNumberCompoundUniqueInput
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    journalEntryId?: UuidFilter<"JournalLine"> | string
    accountId?: UuidFilter<"JournalLine"> | string
    lineNumber?: IntFilter<"JournalLine"> | number
    description?: StringNullableFilter<"JournalLine"> | string | null
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    cryptoAmount?: DecimalNullableFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: StringNullableFilter<"JournalLine"> | string | null
    cryptoPrice?: DecimalNullableFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    costCenter?: StringNullableFilter<"JournalLine"> | string | null
    project?: StringNullableFilter<"JournalLine"> | string | null
    createdAt?: DateTimeFilter<"JournalLine"> | Date | string
    journalEntry?: XOR<JournalEntryRelationFilter, JournalEntryWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id" | "journalEntryId_lineNumber">

  export type JournalLineOrderByWithAggregationInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrderInput | SortOrder
    debit?: SortOrder
    credit?: SortOrder
    cryptoAmount?: SortOrderInput | SortOrder
    cryptoAsset?: SortOrderInput | SortOrder
    cryptoPrice?: SortOrderInput | SortOrder
    costCenter?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: JournalLineCountOrderByAggregateInput
    _avg?: JournalLineAvgOrderByAggregateInput
    _max?: JournalLineMaxOrderByAggregateInput
    _min?: JournalLineMinOrderByAggregateInput
    _sum?: JournalLineSumOrderByAggregateInput
  }

  export type JournalLineScalarWhereWithAggregatesInput = {
    AND?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    OR?: JournalLineScalarWhereWithAggregatesInput[]
    NOT?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"JournalLine"> | string
    journalEntryId?: UuidWithAggregatesFilter<"JournalLine"> | string
    accountId?: UuidWithAggregatesFilter<"JournalLine"> | string
    lineNumber?: IntWithAggregatesFilter<"JournalLine"> | number
    description?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
    debit?: DecimalWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    cryptoAmount?: DecimalNullableWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
    cryptoPrice?: DecimalNullableWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    costCenter?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
    project?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JournalLine"> | Date | string
  }

  export type InvoiceSeriesWhereInput = {
    AND?: InvoiceSeriesWhereInput | InvoiceSeriesWhereInput[]
    OR?: InvoiceSeriesWhereInput[]
    NOT?: InvoiceSeriesWhereInput | InvoiceSeriesWhereInput[]
    id?: UuidFilter<"InvoiceSeries"> | string
    companyId?: UuidFilter<"InvoiceSeries"> | string
    code?: StringFilter<"InvoiceSeries"> | string
    name?: StringFilter<"InvoiceSeries"> | string
    type?: EnumInvoiceTypeFilter<"InvoiceSeries"> | $Enums.InvoiceType
    prefix?: StringNullableFilter<"InvoiceSeries"> | string | null
    suffix?: StringNullableFilter<"InvoiceSeries"> | string | null
    nextNumber?: IntFilter<"InvoiceSeries"> | number
    digitCount?: IntFilter<"InvoiceSeries"> | number
    isDefault?: BoolFilter<"InvoiceSeries"> | boolean
    isActive?: BoolFilter<"InvoiceSeries"> | boolean
    createdAt?: DateTimeFilter<"InvoiceSeries"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceSeries"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type InvoiceSeriesOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prefix?: SortOrderInput | SortOrder
    suffix?: SortOrderInput | SortOrder
    nextNumber?: SortOrder
    digitCount?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    _relevance?: InvoiceSeriesOrderByRelevanceInput
  }

  export type InvoiceSeriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: InvoiceSeriesCompanyIdCodeCompoundUniqueInput
    AND?: InvoiceSeriesWhereInput | InvoiceSeriesWhereInput[]
    OR?: InvoiceSeriesWhereInput[]
    NOT?: InvoiceSeriesWhereInput | InvoiceSeriesWhereInput[]
    companyId?: UuidFilter<"InvoiceSeries"> | string
    code?: StringFilter<"InvoiceSeries"> | string
    name?: StringFilter<"InvoiceSeries"> | string
    type?: EnumInvoiceTypeFilter<"InvoiceSeries"> | $Enums.InvoiceType
    prefix?: StringNullableFilter<"InvoiceSeries"> | string | null
    suffix?: StringNullableFilter<"InvoiceSeries"> | string | null
    nextNumber?: IntFilter<"InvoiceSeries"> | number
    digitCount?: IntFilter<"InvoiceSeries"> | number
    isDefault?: BoolFilter<"InvoiceSeries"> | boolean
    isActive?: BoolFilter<"InvoiceSeries"> | boolean
    createdAt?: DateTimeFilter<"InvoiceSeries"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceSeries"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id" | "companyId_code">

  export type InvoiceSeriesOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prefix?: SortOrderInput | SortOrder
    suffix?: SortOrderInput | SortOrder
    nextNumber?: SortOrder
    digitCount?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceSeriesCountOrderByAggregateInput
    _avg?: InvoiceSeriesAvgOrderByAggregateInput
    _max?: InvoiceSeriesMaxOrderByAggregateInput
    _min?: InvoiceSeriesMinOrderByAggregateInput
    _sum?: InvoiceSeriesSumOrderByAggregateInput
  }

  export type InvoiceSeriesScalarWhereWithAggregatesInput = {
    AND?: InvoiceSeriesScalarWhereWithAggregatesInput | InvoiceSeriesScalarWhereWithAggregatesInput[]
    OR?: InvoiceSeriesScalarWhereWithAggregatesInput[]
    NOT?: InvoiceSeriesScalarWhereWithAggregatesInput | InvoiceSeriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InvoiceSeries"> | string
    companyId?: UuidWithAggregatesFilter<"InvoiceSeries"> | string
    code?: StringWithAggregatesFilter<"InvoiceSeries"> | string
    name?: StringWithAggregatesFilter<"InvoiceSeries"> | string
    type?: EnumInvoiceTypeWithAggregatesFilter<"InvoiceSeries"> | $Enums.InvoiceType
    prefix?: StringNullableWithAggregatesFilter<"InvoiceSeries"> | string | null
    suffix?: StringNullableWithAggregatesFilter<"InvoiceSeries"> | string | null
    nextNumber?: IntWithAggregatesFilter<"InvoiceSeries"> | number
    digitCount?: IntWithAggregatesFilter<"InvoiceSeries"> | number
    isDefault?: BoolWithAggregatesFilter<"InvoiceSeries"> | boolean
    isActive?: BoolWithAggregatesFilter<"InvoiceSeries"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceSeries"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceSeries"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    companyId?: UuidFilter<"Invoice"> | string
    seriesId?: UuidFilter<"Invoice"> | string
    contactId?: UuidNullableFilter<"Invoice"> | string | null
    number?: IntFilter<"Invoice"> | number
    fullNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFilter<"Invoice"> | $Enums.InvoiceDirection
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    operationDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    counterpartyName?: StringFilter<"Invoice"> | string
    counterpartyTaxId?: StringNullableFilter<"Invoice"> | string | null
    counterpartyAddress?: StringNullableFilter<"Invoice"> | string | null
    counterpartyCity?: StringNullableFilter<"Invoice"> | string | null
    counterpartyCountry?: StringFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    exchangeRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFilter<"Invoice"> | boolean
    cryptoAsset?: StringNullableFilter<"Invoice"> | string | null
    cryptoAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuPrevHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuQrData?: StringNullableFilter<"Invoice"> | string | null
    verifactuSentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    verifactuResponse?: JsonNullableFilter<"Invoice">
    verifactuStatus?: EnumVerifactuStatusNullableFilter<"Invoice"> | $Enums.VerifactuStatus | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    internalNotes?: StringNullableFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    journalEntryId?: UuidNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    series?: XOR<InvoiceSeriesRelationFilter, InvoiceSeriesWhereInput>
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    lines?: InvoiceLineListRelationFilter
    taxes?: InvoiceTaxListRelationFilter
    verifactuRecords?: VerifactuRecordListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    seriesId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    number?: SortOrder
    fullNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    operationDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    counterpartyName?: SortOrder
    counterpartyTaxId?: SortOrderInput | SortOrder
    counterpartyAddress?: SortOrderInput | SortOrder
    counterpartyCity?: SortOrderInput | SortOrder
    counterpartyCountry?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    taxableBase?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    cryptoPayment?: SortOrder
    cryptoAsset?: SortOrderInput | SortOrder
    cryptoAmount?: SortOrderInput | SortOrder
    cryptoRate?: SortOrderInput | SortOrder
    cryptoTxHash?: SortOrderInput | SortOrder
    verifactuHash?: SortOrderInput | SortOrder
    verifactuPrevHash?: SortOrderInput | SortOrder
    verifactuQrData?: SortOrderInput | SortOrder
    verifactuSentAt?: SortOrderInput | SortOrder
    verifactuResponse?: SortOrderInput | SortOrder
    verifactuStatus?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    journalEntryId?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    series?: InvoiceSeriesOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    lines?: InvoiceLineOrderByRelationAggregateInput
    taxes?: InvoiceTaxOrderByRelationAggregateInput
    verifactuRecords?: VerifactuRecordOrderByRelationAggregateInput
    _relevance?: InvoiceOrderByRelevanceInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_seriesId_number?: InvoiceCompanyIdSeriesIdNumberCompoundUniqueInput
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    companyId?: UuidFilter<"Invoice"> | string
    seriesId?: UuidFilter<"Invoice"> | string
    contactId?: UuidNullableFilter<"Invoice"> | string | null
    number?: IntFilter<"Invoice"> | number
    fullNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFilter<"Invoice"> | $Enums.InvoiceDirection
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    operationDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    counterpartyName?: StringFilter<"Invoice"> | string
    counterpartyTaxId?: StringNullableFilter<"Invoice"> | string | null
    counterpartyAddress?: StringNullableFilter<"Invoice"> | string | null
    counterpartyCity?: StringNullableFilter<"Invoice"> | string | null
    counterpartyCountry?: StringFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    exchangeRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFilter<"Invoice"> | boolean
    cryptoAsset?: StringNullableFilter<"Invoice"> | string | null
    cryptoAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuPrevHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuQrData?: StringNullableFilter<"Invoice"> | string | null
    verifactuSentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    verifactuResponse?: JsonNullableFilter<"Invoice">
    verifactuStatus?: EnumVerifactuStatusNullableFilter<"Invoice"> | $Enums.VerifactuStatus | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    internalNotes?: StringNullableFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    journalEntryId?: UuidNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    series?: XOR<InvoiceSeriesRelationFilter, InvoiceSeriesWhereInput>
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    lines?: InvoiceLineListRelationFilter
    taxes?: InvoiceTaxListRelationFilter
    verifactuRecords?: VerifactuRecordListRelationFilter
  }, "id" | "companyId_seriesId_number">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    seriesId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    number?: SortOrder
    fullNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    operationDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    counterpartyName?: SortOrder
    counterpartyTaxId?: SortOrderInput | SortOrder
    counterpartyAddress?: SortOrderInput | SortOrder
    counterpartyCity?: SortOrderInput | SortOrder
    counterpartyCountry?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    taxableBase?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    cryptoPayment?: SortOrder
    cryptoAsset?: SortOrderInput | SortOrder
    cryptoAmount?: SortOrderInput | SortOrder
    cryptoRate?: SortOrderInput | SortOrder
    cryptoTxHash?: SortOrderInput | SortOrder
    verifactuHash?: SortOrderInput | SortOrder
    verifactuPrevHash?: SortOrderInput | SortOrder
    verifactuQrData?: SortOrderInput | SortOrder
    verifactuSentAt?: SortOrderInput | SortOrder
    verifactuResponse?: SortOrderInput | SortOrder
    verifactuStatus?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    journalEntryId?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    companyId?: UuidWithAggregatesFilter<"Invoice"> | string
    seriesId?: UuidWithAggregatesFilter<"Invoice"> | string
    contactId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    number?: IntWithAggregatesFilter<"Invoice"> | number
    fullNumber?: StringWithAggregatesFilter<"Invoice"> | string
    type?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionWithAggregatesFilter<"Invoice"> | $Enums.InvoiceDirection
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    operationDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    counterpartyName?: StringWithAggregatesFilter<"Invoice"> | string
    counterpartyTaxId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    counterpartyAddress?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    counterpartyCity?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    counterpartyCountry?: StringWithAggregatesFilter<"Invoice"> | string
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    exchangeRate?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolWithAggregatesFilter<"Invoice"> | boolean
    cryptoAsset?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    cryptoAmount?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    verifactuHash?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    verifactuPrevHash?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    verifactuQrData?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    verifactuSentAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    verifactuResponse?: JsonNullableWithAggregatesFilter<"Invoice">
    verifactuStatus?: EnumVerifactuStatusNullableWithAggregatesFilter<"Invoice"> | $Enums.VerifactuStatus | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    internalNotes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    journalEntryId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceLineWhereInput = {
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    id?: UuidFilter<"InvoiceLine"> | string
    invoiceId?: UuidFilter<"InvoiceLine"> | string
    lineNumber?: IntFilter<"InvoiceLine"> | number
    description?: StringFilter<"InvoiceLine"> | string
    quantity?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    accountCode?: StringNullableFilter<"InvoiceLine"> | string | null
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    accountCode?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    _relevance?: InvoiceLineOrderByRelevanceInput
  }

  export type InvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceId_lineNumber?: InvoiceLineInvoiceIdLineNumberCompoundUniqueInput
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceId?: UuidFilter<"InvoiceLine"> | string
    lineNumber?: IntFilter<"InvoiceLine"> | number
    description?: StringFilter<"InvoiceLine"> | string
    quantity?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    accountCode?: StringNullableFilter<"InvoiceLine"> | string | null
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id" | "invoiceId_lineNumber">

  export type InvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    accountCode?: SortOrderInput | SortOrder
    _count?: InvoiceLineCountOrderByAggregateInput
    _avg?: InvoiceLineAvgOrderByAggregateInput
    _max?: InvoiceLineMaxOrderByAggregateInput
    _min?: InvoiceLineMinOrderByAggregateInput
    _sum?: InvoiceLineSumOrderByAggregateInput
  }

  export type InvoiceLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InvoiceLine"> | string
    invoiceId?: UuidWithAggregatesFilter<"InvoiceLine"> | string
    lineNumber?: IntWithAggregatesFilter<"InvoiceLine"> | number
    description?: StringWithAggregatesFilter<"InvoiceLine"> | string
    quantity?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    accountCode?: StringNullableWithAggregatesFilter<"InvoiceLine"> | string | null
  }

  export type InvoiceTaxWhereInput = {
    AND?: InvoiceTaxWhereInput | InvoiceTaxWhereInput[]
    OR?: InvoiceTaxWhereInput[]
    NOT?: InvoiceTaxWhereInput | InvoiceTaxWhereInput[]
    id?: UuidFilter<"InvoiceTax"> | string
    invoiceId?: UuidFilter<"InvoiceTax"> | string
    taxRate?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFilter<"InvoiceTax"> | $Enums.TaxType
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceTaxOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    taxRate?: SortOrder
    taxableBase?: SortOrder
    taxAmount?: SortOrder
    taxType?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    _relevance?: InvoiceTaxOrderByRelevanceInput
  }

  export type InvoiceTaxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceId_taxRate_taxType?: InvoiceTaxInvoiceIdTaxRateTaxTypeCompoundUniqueInput
    AND?: InvoiceTaxWhereInput | InvoiceTaxWhereInput[]
    OR?: InvoiceTaxWhereInput[]
    NOT?: InvoiceTaxWhereInput | InvoiceTaxWhereInput[]
    invoiceId?: UuidFilter<"InvoiceTax"> | string
    taxRate?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFilter<"InvoiceTax"> | $Enums.TaxType
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id" | "invoiceId_taxRate_taxType">

  export type InvoiceTaxOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    taxRate?: SortOrder
    taxableBase?: SortOrder
    taxAmount?: SortOrder
    taxType?: SortOrder
    _count?: InvoiceTaxCountOrderByAggregateInput
    _avg?: InvoiceTaxAvgOrderByAggregateInput
    _max?: InvoiceTaxMaxOrderByAggregateInput
    _min?: InvoiceTaxMinOrderByAggregateInput
    _sum?: InvoiceTaxSumOrderByAggregateInput
  }

  export type InvoiceTaxScalarWhereWithAggregatesInput = {
    AND?: InvoiceTaxScalarWhereWithAggregatesInput | InvoiceTaxScalarWhereWithAggregatesInput[]
    OR?: InvoiceTaxScalarWhereWithAggregatesInput[]
    NOT?: InvoiceTaxScalarWhereWithAggregatesInput | InvoiceTaxScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InvoiceTax"> | string
    invoiceId?: UuidWithAggregatesFilter<"InvoiceTax"> | string
    taxRate?: DecimalWithAggregatesFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalWithAggregatesFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeWithAggregatesFilter<"InvoiceTax"> | $Enums.TaxType
  }

  export type CryptoAssetWhereInput = {
    AND?: CryptoAssetWhereInput | CryptoAssetWhereInput[]
    OR?: CryptoAssetWhereInput[]
    NOT?: CryptoAssetWhereInput | CryptoAssetWhereInput[]
    id?: UuidFilter<"CryptoAsset"> | string
    companyId?: UuidFilter<"CryptoAsset"> | string
    symbol?: StringFilter<"CryptoAsset"> | string
    name?: StringFilter<"CryptoAsset"> | string
    decimals?: IntFilter<"CryptoAsset"> | number
    contractAddress?: StringNullableFilter<"CryptoAsset"> | string | null
    classification?: EnumCryptoClassificationFilter<"CryptoAsset"> | $Enums.CryptoClassification
    coingeckoId?: StringNullableFilter<"CryptoAsset"> | string | null
    lastPrice?: DecimalNullableFilter<"CryptoAsset"> | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: DateTimeNullableFilter<"CryptoAsset"> | Date | string | null
    isActive?: BoolFilter<"CryptoAsset"> | boolean
    createdAt?: DateTimeFilter<"CryptoAsset"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoAsset"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    accounts?: AccountListRelationFilter
    lots?: CryptoLotListRelationFilter
  }

  export type CryptoAssetOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    decimals?: SortOrder
    contractAddress?: SortOrderInput | SortOrder
    classification?: SortOrder
    coingeckoId?: SortOrderInput | SortOrder
    lastPrice?: SortOrderInput | SortOrder
    lastPriceAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    lots?: CryptoLotOrderByRelationAggregateInput
    _relevance?: CryptoAssetOrderByRelevanceInput
  }

  export type CryptoAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_symbol?: CryptoAssetCompanyIdSymbolCompoundUniqueInput
    AND?: CryptoAssetWhereInput | CryptoAssetWhereInput[]
    OR?: CryptoAssetWhereInput[]
    NOT?: CryptoAssetWhereInput | CryptoAssetWhereInput[]
    companyId?: UuidFilter<"CryptoAsset"> | string
    symbol?: StringFilter<"CryptoAsset"> | string
    name?: StringFilter<"CryptoAsset"> | string
    decimals?: IntFilter<"CryptoAsset"> | number
    contractAddress?: StringNullableFilter<"CryptoAsset"> | string | null
    classification?: EnumCryptoClassificationFilter<"CryptoAsset"> | $Enums.CryptoClassification
    coingeckoId?: StringNullableFilter<"CryptoAsset"> | string | null
    lastPrice?: DecimalNullableFilter<"CryptoAsset"> | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: DateTimeNullableFilter<"CryptoAsset"> | Date | string | null
    isActive?: BoolFilter<"CryptoAsset"> | boolean
    createdAt?: DateTimeFilter<"CryptoAsset"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoAsset"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    accounts?: AccountListRelationFilter
    lots?: CryptoLotListRelationFilter
  }, "id" | "companyId_symbol">

  export type CryptoAssetOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    decimals?: SortOrder
    contractAddress?: SortOrderInput | SortOrder
    classification?: SortOrder
    coingeckoId?: SortOrderInput | SortOrder
    lastPrice?: SortOrderInput | SortOrder
    lastPriceAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoAssetCountOrderByAggregateInput
    _avg?: CryptoAssetAvgOrderByAggregateInput
    _max?: CryptoAssetMaxOrderByAggregateInput
    _min?: CryptoAssetMinOrderByAggregateInput
    _sum?: CryptoAssetSumOrderByAggregateInput
  }

  export type CryptoAssetScalarWhereWithAggregatesInput = {
    AND?: CryptoAssetScalarWhereWithAggregatesInput | CryptoAssetScalarWhereWithAggregatesInput[]
    OR?: CryptoAssetScalarWhereWithAggregatesInput[]
    NOT?: CryptoAssetScalarWhereWithAggregatesInput | CryptoAssetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CryptoAsset"> | string
    companyId?: UuidWithAggregatesFilter<"CryptoAsset"> | string
    symbol?: StringWithAggregatesFilter<"CryptoAsset"> | string
    name?: StringWithAggregatesFilter<"CryptoAsset"> | string
    decimals?: IntWithAggregatesFilter<"CryptoAsset"> | number
    contractAddress?: StringNullableWithAggregatesFilter<"CryptoAsset"> | string | null
    classification?: EnumCryptoClassificationWithAggregatesFilter<"CryptoAsset"> | $Enums.CryptoClassification
    coingeckoId?: StringNullableWithAggregatesFilter<"CryptoAsset"> | string | null
    lastPrice?: DecimalNullableWithAggregatesFilter<"CryptoAsset"> | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: DateTimeNullableWithAggregatesFilter<"CryptoAsset"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"CryptoAsset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CryptoAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoAsset"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: UuidFilter<"Wallet"> | string
    companyId?: UuidFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    chain?: StringFilter<"Wallet"> | string
    label?: StringNullableFilter<"Wallet"> | string | null
    type?: EnumWalletTypeFilter<"Wallet"> | $Enums.WalletType
    lastSyncAt?: DateTimeNullableFilter<"Wallet"> | Date | string | null
    lastSyncBlock?: BigIntNullableFilter<"Wallet"> | bigint | number | null
    syncStatus?: EnumSyncStatusFilter<"Wallet"> | $Enums.SyncStatus
    syncError?: StringNullableFilter<"Wallet"> | string | null
    accountCode?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: CryptoTransactionListRelationFilter
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    label?: SortOrderInput | SortOrder
    type?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncBlock?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrderInput | SortOrder
    accountCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    transactions?: CryptoTransactionOrderByRelationAggregateInput
    _relevance?: WalletOrderByRelevanceInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_chain_address?: WalletCompanyIdChainAddressCompoundUniqueInput
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    companyId?: UuidFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    chain?: StringFilter<"Wallet"> | string
    label?: StringNullableFilter<"Wallet"> | string | null
    type?: EnumWalletTypeFilter<"Wallet"> | $Enums.WalletType
    lastSyncAt?: DateTimeNullableFilter<"Wallet"> | Date | string | null
    lastSyncBlock?: BigIntNullableFilter<"Wallet"> | bigint | number | null
    syncStatus?: EnumSyncStatusFilter<"Wallet"> | $Enums.SyncStatus
    syncError?: StringNullableFilter<"Wallet"> | string | null
    accountCode?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: CryptoTransactionListRelationFilter
  }, "id" | "companyId_chain_address">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    label?: SortOrderInput | SortOrder
    type?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncBlock?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrderInput | SortOrder
    accountCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Wallet"> | string
    companyId?: UuidWithAggregatesFilter<"Wallet"> | string
    address?: StringWithAggregatesFilter<"Wallet"> | string
    chain?: StringWithAggregatesFilter<"Wallet"> | string
    label?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    type?: EnumWalletTypeWithAggregatesFilter<"Wallet"> | $Enums.WalletType
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"Wallet"> | Date | string | null
    lastSyncBlock?: BigIntNullableWithAggregatesFilter<"Wallet"> | bigint | number | null
    syncStatus?: EnumSyncStatusWithAggregatesFilter<"Wallet"> | $Enums.SyncStatus
    syncError?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    accountCode?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    isActive?: BoolWithAggregatesFilter<"Wallet"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type ExchangeAccountWhereInput = {
    AND?: ExchangeAccountWhereInput | ExchangeAccountWhereInput[]
    OR?: ExchangeAccountWhereInput[]
    NOT?: ExchangeAccountWhereInput | ExchangeAccountWhereInput[]
    id?: UuidFilter<"ExchangeAccount"> | string
    companyId?: UuidFilter<"ExchangeAccount"> | string
    exchange?: StringFilter<"ExchangeAccount"> | string
    label?: StringNullableFilter<"ExchangeAccount"> | string | null
    apiKey?: StringNullableFilter<"ExchangeAccount"> | string | null
    apiSecret?: StringNullableFilter<"ExchangeAccount"> | string | null
    isReadOnly?: BoolFilter<"ExchangeAccount"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"ExchangeAccount"> | Date | string | null
    syncStatus?: EnumSyncStatusFilter<"ExchangeAccount"> | $Enums.SyncStatus
    syncError?: StringNullableFilter<"ExchangeAccount"> | string | null
    country?: StringFilter<"ExchangeAccount"> | string
    isActive?: BoolFilter<"ExchangeAccount"> | boolean
    createdAt?: DateTimeFilter<"ExchangeAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ExchangeAccount"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ExchangeAccountOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    exchange?: SortOrder
    label?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    apiSecret?: SortOrderInput | SortOrder
    isReadOnly?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrderInput | SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    _relevance?: ExchangeAccountOrderByRelevanceInput
  }

  export type ExchangeAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_exchange_apiKey?: ExchangeAccountCompanyIdExchangeApiKeyCompoundUniqueInput
    AND?: ExchangeAccountWhereInput | ExchangeAccountWhereInput[]
    OR?: ExchangeAccountWhereInput[]
    NOT?: ExchangeAccountWhereInput | ExchangeAccountWhereInput[]
    companyId?: UuidFilter<"ExchangeAccount"> | string
    exchange?: StringFilter<"ExchangeAccount"> | string
    label?: StringNullableFilter<"ExchangeAccount"> | string | null
    apiKey?: StringNullableFilter<"ExchangeAccount"> | string | null
    apiSecret?: StringNullableFilter<"ExchangeAccount"> | string | null
    isReadOnly?: BoolFilter<"ExchangeAccount"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"ExchangeAccount"> | Date | string | null
    syncStatus?: EnumSyncStatusFilter<"ExchangeAccount"> | $Enums.SyncStatus
    syncError?: StringNullableFilter<"ExchangeAccount"> | string | null
    country?: StringFilter<"ExchangeAccount"> | string
    isActive?: BoolFilter<"ExchangeAccount"> | boolean
    createdAt?: DateTimeFilter<"ExchangeAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ExchangeAccount"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_exchange_apiKey">

  export type ExchangeAccountOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    exchange?: SortOrder
    label?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    apiSecret?: SortOrderInput | SortOrder
    isReadOnly?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrderInput | SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExchangeAccountCountOrderByAggregateInput
    _max?: ExchangeAccountMaxOrderByAggregateInput
    _min?: ExchangeAccountMinOrderByAggregateInput
  }

  export type ExchangeAccountScalarWhereWithAggregatesInput = {
    AND?: ExchangeAccountScalarWhereWithAggregatesInput | ExchangeAccountScalarWhereWithAggregatesInput[]
    OR?: ExchangeAccountScalarWhereWithAggregatesInput[]
    NOT?: ExchangeAccountScalarWhereWithAggregatesInput | ExchangeAccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ExchangeAccount"> | string
    companyId?: UuidWithAggregatesFilter<"ExchangeAccount"> | string
    exchange?: StringWithAggregatesFilter<"ExchangeAccount"> | string
    label?: StringNullableWithAggregatesFilter<"ExchangeAccount"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"ExchangeAccount"> | string | null
    apiSecret?: StringNullableWithAggregatesFilter<"ExchangeAccount"> | string | null
    isReadOnly?: BoolWithAggregatesFilter<"ExchangeAccount"> | boolean
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"ExchangeAccount"> | Date | string | null
    syncStatus?: EnumSyncStatusWithAggregatesFilter<"ExchangeAccount"> | $Enums.SyncStatus
    syncError?: StringNullableWithAggregatesFilter<"ExchangeAccount"> | string | null
    country?: StringWithAggregatesFilter<"ExchangeAccount"> | string
    isActive?: BoolWithAggregatesFilter<"ExchangeAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExchangeAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExchangeAccount"> | Date | string
  }

  export type CryptoTransactionWhereInput = {
    AND?: CryptoTransactionWhereInput | CryptoTransactionWhereInput[]
    OR?: CryptoTransactionWhereInput[]
    NOT?: CryptoTransactionWhereInput | CryptoTransactionWhereInput[]
    id?: UuidFilter<"CryptoTransaction"> | string
    walletId?: UuidFilter<"CryptoTransaction"> | string
    txHash?: StringFilter<"CryptoTransaction"> | string
    blockNumber?: BigIntFilter<"CryptoTransaction"> | bigint | number
    blockTimestamp?: DateTimeFilter<"CryptoTransaction"> | Date | string
    chain?: StringFilter<"CryptoTransaction"> | string
    type?: EnumCryptoTxTypeFilter<"CryptoTransaction"> | $Enums.CryptoTxType
    subtype?: StringNullableFilter<"CryptoTransaction"> | string | null
    assetIn?: StringNullableFilter<"CryptoTransaction"> | string | null
    amountIn?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    assetOut?: StringNullableFilter<"CryptoTransaction"> | string | null
    amountOut?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeAsset?: StringNullableFilter<"CryptoTransaction"> | string | null
    feeAmount?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceInEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    costBasis?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    realizedGain?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFilter<"CryptoTransaction"> | boolean
    aiConfidence?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: StringNullableFilter<"CryptoTransaction"> | string | null
    manualType?: EnumCryptoTxTypeNullableFilter<"CryptoTransaction"> | $Enums.CryptoTxType | null
    manualNotes?: StringNullableFilter<"CryptoTransaction"> | string | null
    journalEntryId?: UuidNullableFilter<"CryptoTransaction"> | string | null
    status?: EnumTxStatusFilter<"CryptoTransaction"> | $Enums.TxStatus
    rawData?: JsonNullableFilter<"CryptoTransaction">
    createdAt?: DateTimeFilter<"CryptoTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoTransaction"> | Date | string
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type CryptoTransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    blockTimestamp?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    subtype?: SortOrderInput | SortOrder
    assetIn?: SortOrderInput | SortOrder
    amountIn?: SortOrderInput | SortOrder
    assetOut?: SortOrderInput | SortOrder
    amountOut?: SortOrderInput | SortOrder
    feeAsset?: SortOrderInput | SortOrder
    feeAmount?: SortOrderInput | SortOrder
    priceInEur?: SortOrderInput | SortOrder
    priceOutEur?: SortOrderInput | SortOrder
    feeEur?: SortOrderInput | SortOrder
    costBasis?: SortOrderInput | SortOrder
    realizedGain?: SortOrderInput | SortOrder
    aiCategorized?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    manualType?: SortOrderInput | SortOrder
    manualNotes?: SortOrderInput | SortOrder
    journalEntryId?: SortOrderInput | SortOrder
    status?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    _relevance?: CryptoTransactionOrderByRelevanceInput
  }

  export type CryptoTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    walletId_txHash?: CryptoTransactionWalletIdTxHashCompoundUniqueInput
    AND?: CryptoTransactionWhereInput | CryptoTransactionWhereInput[]
    OR?: CryptoTransactionWhereInput[]
    NOT?: CryptoTransactionWhereInput | CryptoTransactionWhereInput[]
    walletId?: UuidFilter<"CryptoTransaction"> | string
    txHash?: StringFilter<"CryptoTransaction"> | string
    blockNumber?: BigIntFilter<"CryptoTransaction"> | bigint | number
    blockTimestamp?: DateTimeFilter<"CryptoTransaction"> | Date | string
    chain?: StringFilter<"CryptoTransaction"> | string
    type?: EnumCryptoTxTypeFilter<"CryptoTransaction"> | $Enums.CryptoTxType
    subtype?: StringNullableFilter<"CryptoTransaction"> | string | null
    assetIn?: StringNullableFilter<"CryptoTransaction"> | string | null
    amountIn?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    assetOut?: StringNullableFilter<"CryptoTransaction"> | string | null
    amountOut?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeAsset?: StringNullableFilter<"CryptoTransaction"> | string | null
    feeAmount?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceInEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    costBasis?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    realizedGain?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFilter<"CryptoTransaction"> | boolean
    aiConfidence?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: StringNullableFilter<"CryptoTransaction"> | string | null
    manualType?: EnumCryptoTxTypeNullableFilter<"CryptoTransaction"> | $Enums.CryptoTxType | null
    manualNotes?: StringNullableFilter<"CryptoTransaction"> | string | null
    journalEntryId?: UuidNullableFilter<"CryptoTransaction"> | string | null
    status?: EnumTxStatusFilter<"CryptoTransaction"> | $Enums.TxStatus
    rawData?: JsonNullableFilter<"CryptoTransaction">
    createdAt?: DateTimeFilter<"CryptoTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoTransaction"> | Date | string
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }, "id" | "walletId_txHash">

  export type CryptoTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    blockTimestamp?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    subtype?: SortOrderInput | SortOrder
    assetIn?: SortOrderInput | SortOrder
    amountIn?: SortOrderInput | SortOrder
    assetOut?: SortOrderInput | SortOrder
    amountOut?: SortOrderInput | SortOrder
    feeAsset?: SortOrderInput | SortOrder
    feeAmount?: SortOrderInput | SortOrder
    priceInEur?: SortOrderInput | SortOrder
    priceOutEur?: SortOrderInput | SortOrder
    feeEur?: SortOrderInput | SortOrder
    costBasis?: SortOrderInput | SortOrder
    realizedGain?: SortOrderInput | SortOrder
    aiCategorized?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    manualType?: SortOrderInput | SortOrder
    manualNotes?: SortOrderInput | SortOrder
    journalEntryId?: SortOrderInput | SortOrder
    status?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoTransactionCountOrderByAggregateInput
    _avg?: CryptoTransactionAvgOrderByAggregateInput
    _max?: CryptoTransactionMaxOrderByAggregateInput
    _min?: CryptoTransactionMinOrderByAggregateInput
    _sum?: CryptoTransactionSumOrderByAggregateInput
  }

  export type CryptoTransactionScalarWhereWithAggregatesInput = {
    AND?: CryptoTransactionScalarWhereWithAggregatesInput | CryptoTransactionScalarWhereWithAggregatesInput[]
    OR?: CryptoTransactionScalarWhereWithAggregatesInput[]
    NOT?: CryptoTransactionScalarWhereWithAggregatesInput | CryptoTransactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CryptoTransaction"> | string
    walletId?: UuidWithAggregatesFilter<"CryptoTransaction"> | string
    txHash?: StringWithAggregatesFilter<"CryptoTransaction"> | string
    blockNumber?: BigIntWithAggregatesFilter<"CryptoTransaction"> | bigint | number
    blockTimestamp?: DateTimeWithAggregatesFilter<"CryptoTransaction"> | Date | string
    chain?: StringWithAggregatesFilter<"CryptoTransaction"> | string
    type?: EnumCryptoTxTypeWithAggregatesFilter<"CryptoTransaction"> | $Enums.CryptoTxType
    subtype?: StringNullableWithAggregatesFilter<"CryptoTransaction"> | string | null
    assetIn?: StringNullableWithAggregatesFilter<"CryptoTransaction"> | string | null
    amountIn?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    assetOut?: StringNullableWithAggregatesFilter<"CryptoTransaction"> | string | null
    amountOut?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeAsset?: StringNullableWithAggregatesFilter<"CryptoTransaction"> | string | null
    feeAmount?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceInEur?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeEur?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    costBasis?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    realizedGain?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolWithAggregatesFilter<"CryptoTransaction"> | boolean
    aiConfidence?: DecimalNullableWithAggregatesFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: StringNullableWithAggregatesFilter<"CryptoTransaction"> | string | null
    manualType?: EnumCryptoTxTypeNullableWithAggregatesFilter<"CryptoTransaction"> | $Enums.CryptoTxType | null
    manualNotes?: StringNullableWithAggregatesFilter<"CryptoTransaction"> | string | null
    journalEntryId?: UuidNullableWithAggregatesFilter<"CryptoTransaction"> | string | null
    status?: EnumTxStatusWithAggregatesFilter<"CryptoTransaction"> | $Enums.TxStatus
    rawData?: JsonNullableWithAggregatesFilter<"CryptoTransaction">
    createdAt?: DateTimeWithAggregatesFilter<"CryptoTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoTransaction"> | Date | string
  }

  export type CryptoLotWhereInput = {
    AND?: CryptoLotWhereInput | CryptoLotWhereInput[]
    OR?: CryptoLotWhereInput[]
    NOT?: CryptoLotWhereInput | CryptoLotWhereInput[]
    id?: UuidFilter<"CryptoLot"> | string
    companyId?: UuidFilter<"CryptoLot"> | string
    cryptoAssetId?: UuidFilter<"CryptoLot"> | string
    acquiredAt?: DateTimeFilter<"CryptoLot"> | Date | string
    acquiredAmount?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    sourceTxId?: StringNullableFilter<"CryptoLot"> | string | null
    sourceType?: StringNullableFilter<"CryptoLot"> | string | null
    createdAt?: DateTimeFilter<"CryptoLot"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoLot"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    cryptoAsset?: XOR<CryptoAssetRelationFilter, CryptoAssetWhereInput>
  }

  export type CryptoLotOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    cryptoAssetId?: SortOrder
    acquiredAt?: SortOrder
    acquiredAmount?: SortOrder
    costBasisEur?: SortOrder
    costPerUnit?: SortOrder
    remainingAmount?: SortOrder
    sourceTxId?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    cryptoAsset?: CryptoAssetOrderByWithRelationInput
    _relevance?: CryptoLotOrderByRelevanceInput
  }

  export type CryptoLotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CryptoLotWhereInput | CryptoLotWhereInput[]
    OR?: CryptoLotWhereInput[]
    NOT?: CryptoLotWhereInput | CryptoLotWhereInput[]
    companyId?: UuidFilter<"CryptoLot"> | string
    cryptoAssetId?: UuidFilter<"CryptoLot"> | string
    acquiredAt?: DateTimeFilter<"CryptoLot"> | Date | string
    acquiredAmount?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    sourceTxId?: StringNullableFilter<"CryptoLot"> | string | null
    sourceType?: StringNullableFilter<"CryptoLot"> | string | null
    createdAt?: DateTimeFilter<"CryptoLot"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoLot"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    cryptoAsset?: XOR<CryptoAssetRelationFilter, CryptoAssetWhereInput>
  }, "id">

  export type CryptoLotOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    cryptoAssetId?: SortOrder
    acquiredAt?: SortOrder
    acquiredAmount?: SortOrder
    costBasisEur?: SortOrder
    costPerUnit?: SortOrder
    remainingAmount?: SortOrder
    sourceTxId?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoLotCountOrderByAggregateInput
    _avg?: CryptoLotAvgOrderByAggregateInput
    _max?: CryptoLotMaxOrderByAggregateInput
    _min?: CryptoLotMinOrderByAggregateInput
    _sum?: CryptoLotSumOrderByAggregateInput
  }

  export type CryptoLotScalarWhereWithAggregatesInput = {
    AND?: CryptoLotScalarWhereWithAggregatesInput | CryptoLotScalarWhereWithAggregatesInput[]
    OR?: CryptoLotScalarWhereWithAggregatesInput[]
    NOT?: CryptoLotScalarWhereWithAggregatesInput | CryptoLotScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CryptoLot"> | string
    companyId?: UuidWithAggregatesFilter<"CryptoLot"> | string
    cryptoAssetId?: UuidWithAggregatesFilter<"CryptoLot"> | string
    acquiredAt?: DateTimeWithAggregatesFilter<"CryptoLot"> | Date | string
    acquiredAmount?: DecimalWithAggregatesFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalWithAggregatesFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalWithAggregatesFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalWithAggregatesFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    sourceTxId?: StringNullableWithAggregatesFilter<"CryptoLot"> | string | null
    sourceType?: StringNullableWithAggregatesFilter<"CryptoLot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CryptoLot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoLot"> | Date | string
  }

  export type PriceHistoryWhereInput = {
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    id?: UuidFilter<"PriceHistory"> | string
    symbol?: StringFilter<"PriceHistory"> | string
    priceEur?: DecimalFilter<"PriceHistory"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"PriceHistory"> | string
    timestamp?: DateTimeFilter<"PriceHistory"> | Date | string
  }

  export type PriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    priceEur?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
    _relevance?: PriceHistoryOrderByRelevanceInput
  }

  export type PriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    symbol?: StringFilter<"PriceHistory"> | string
    priceEur?: DecimalFilter<"PriceHistory"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"PriceHistory"> | string
    timestamp?: DateTimeFilter<"PriceHistory"> | Date | string
  }, "id">

  export type PriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    priceEur?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
    _count?: PriceHistoryCountOrderByAggregateInput
    _avg?: PriceHistoryAvgOrderByAggregateInput
    _max?: PriceHistoryMaxOrderByAggregateInput
    _min?: PriceHistoryMinOrderByAggregateInput
    _sum?: PriceHistorySumOrderByAggregateInput
  }

  export type PriceHistoryScalarWhereWithAggregatesInput = {
    AND?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    OR?: PriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PriceHistory"> | string
    symbol?: StringWithAggregatesFilter<"PriceHistory"> | string
    priceEur?: DecimalWithAggregatesFilter<"PriceHistory"> | Decimal | DecimalJsLike | number | string
    source?: StringWithAggregatesFilter<"PriceHistory"> | string
    timestamp?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
  }

  export type VerifactuRecordWhereInput = {
    AND?: VerifactuRecordWhereInput | VerifactuRecordWhereInput[]
    OR?: VerifactuRecordWhereInput[]
    NOT?: VerifactuRecordWhereInput | VerifactuRecordWhereInput[]
    id?: UuidFilter<"VerifactuRecord"> | string
    invoiceId?: UuidFilter<"VerifactuRecord"> | string
    hash?: StringFilter<"VerifactuRecord"> | string
    prevHash?: StringNullableFilter<"VerifactuRecord"> | string | null
    xmlContent?: StringFilter<"VerifactuRecord"> | string
    state?: EnumVerifactuRecordStateFilter<"VerifactuRecord"> | $Enums.VerifactuRecordState
    csv?: StringNullableFilter<"VerifactuRecord"> | string | null
    sentAt?: DateTimeNullableFilter<"VerifactuRecord"> | Date | string | null
    retryCount?: IntFilter<"VerifactuRecord"> | number
    aeatResponse?: JsonNullableFilter<"VerifactuRecord">
    createdAt?: DateTimeFilter<"VerifactuRecord"> | Date | string
    updatedAt?: DateTimeFilter<"VerifactuRecord"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type VerifactuRecordOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    hash?: SortOrder
    prevHash?: SortOrderInput | SortOrder
    xmlContent?: SortOrder
    state?: SortOrder
    csv?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    aeatResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    _relevance?: VerifactuRecordOrderByRelevanceInput
  }

  export type VerifactuRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerifactuRecordWhereInput | VerifactuRecordWhereInput[]
    OR?: VerifactuRecordWhereInput[]
    NOT?: VerifactuRecordWhereInput | VerifactuRecordWhereInput[]
    invoiceId?: UuidFilter<"VerifactuRecord"> | string
    hash?: StringFilter<"VerifactuRecord"> | string
    prevHash?: StringNullableFilter<"VerifactuRecord"> | string | null
    xmlContent?: StringFilter<"VerifactuRecord"> | string
    state?: EnumVerifactuRecordStateFilter<"VerifactuRecord"> | $Enums.VerifactuRecordState
    csv?: StringNullableFilter<"VerifactuRecord"> | string | null
    sentAt?: DateTimeNullableFilter<"VerifactuRecord"> | Date | string | null
    retryCount?: IntFilter<"VerifactuRecord"> | number
    aeatResponse?: JsonNullableFilter<"VerifactuRecord">
    createdAt?: DateTimeFilter<"VerifactuRecord"> | Date | string
    updatedAt?: DateTimeFilter<"VerifactuRecord"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type VerifactuRecordOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    hash?: SortOrder
    prevHash?: SortOrderInput | SortOrder
    xmlContent?: SortOrder
    state?: SortOrder
    csv?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    aeatResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerifactuRecordCountOrderByAggregateInput
    _avg?: VerifactuRecordAvgOrderByAggregateInput
    _max?: VerifactuRecordMaxOrderByAggregateInput
    _min?: VerifactuRecordMinOrderByAggregateInput
    _sum?: VerifactuRecordSumOrderByAggregateInput
  }

  export type VerifactuRecordScalarWhereWithAggregatesInput = {
    AND?: VerifactuRecordScalarWhereWithAggregatesInput | VerifactuRecordScalarWhereWithAggregatesInput[]
    OR?: VerifactuRecordScalarWhereWithAggregatesInput[]
    NOT?: VerifactuRecordScalarWhereWithAggregatesInput | VerifactuRecordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VerifactuRecord"> | string
    invoiceId?: UuidWithAggregatesFilter<"VerifactuRecord"> | string
    hash?: StringWithAggregatesFilter<"VerifactuRecord"> | string
    prevHash?: StringNullableWithAggregatesFilter<"VerifactuRecord"> | string | null
    xmlContent?: StringWithAggregatesFilter<"VerifactuRecord"> | string
    state?: EnumVerifactuRecordStateWithAggregatesFilter<"VerifactuRecord"> | $Enums.VerifactuRecordState
    csv?: StringNullableWithAggregatesFilter<"VerifactuRecord"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"VerifactuRecord"> | Date | string | null
    retryCount?: IntWithAggregatesFilter<"VerifactuRecord"> | number
    aeatResponse?: JsonNullableWithAggregatesFilter<"VerifactuRecord">
    createdAt?: DateTimeWithAggregatesFilter<"VerifactuRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerifactuRecord"> | Date | string
  }

  export type AiConversationWhereInput = {
    AND?: AiConversationWhereInput | AiConversationWhereInput[]
    OR?: AiConversationWhereInput[]
    NOT?: AiConversationWhereInput | AiConversationWhereInput[]
    id?: UuidFilter<"AiConversation"> | string
    companyId?: UuidFilter<"AiConversation"> | string
    userId?: UuidFilter<"AiConversation"> | string
    title?: StringNullableFilter<"AiConversation"> | string | null
    context?: JsonNullableFilter<"AiConversation">
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: AiMessageListRelationFilter
  }

  export type AiConversationOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    messages?: AiMessageOrderByRelationAggregateInput
    _relevance?: AiConversationOrderByRelevanceInput
  }

  export type AiConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiConversationWhereInput | AiConversationWhereInput[]
    OR?: AiConversationWhereInput[]
    NOT?: AiConversationWhereInput | AiConversationWhereInput[]
    companyId?: UuidFilter<"AiConversation"> | string
    userId?: UuidFilter<"AiConversation"> | string
    title?: StringNullableFilter<"AiConversation"> | string | null
    context?: JsonNullableFilter<"AiConversation">
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: AiMessageListRelationFilter
  }, "id">

  export type AiConversationOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiConversationCountOrderByAggregateInput
    _max?: AiConversationMaxOrderByAggregateInput
    _min?: AiConversationMinOrderByAggregateInput
  }

  export type AiConversationScalarWhereWithAggregatesInput = {
    AND?: AiConversationScalarWhereWithAggregatesInput | AiConversationScalarWhereWithAggregatesInput[]
    OR?: AiConversationScalarWhereWithAggregatesInput[]
    NOT?: AiConversationScalarWhereWithAggregatesInput | AiConversationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AiConversation"> | string
    companyId?: UuidWithAggregatesFilter<"AiConversation"> | string
    userId?: UuidWithAggregatesFilter<"AiConversation"> | string
    title?: StringNullableWithAggregatesFilter<"AiConversation"> | string | null
    context?: JsonNullableWithAggregatesFilter<"AiConversation">
    createdAt?: DateTimeWithAggregatesFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiConversation"> | Date | string
  }

  export type AiMessageWhereInput = {
    AND?: AiMessageWhereInput | AiMessageWhereInput[]
    OR?: AiMessageWhereInput[]
    NOT?: AiMessageWhereInput | AiMessageWhereInput[]
    id?: UuidFilter<"AiMessage"> | string
    conversationId?: UuidFilter<"AiMessage"> | string
    role?: EnumAiRoleFilter<"AiMessage"> | $Enums.AiRole
    content?: StringFilter<"AiMessage"> | string
    inputTokens?: IntNullableFilter<"AiMessage"> | number | null
    outputTokens?: IntNullableFilter<"AiMessage"> | number | null
    provider?: StringNullableFilter<"AiMessage"> | string | null
    model?: StringNullableFilter<"AiMessage"> | string | null
    latencyMs?: IntNullableFilter<"AiMessage"> | number | null
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
    conversation?: XOR<AiConversationRelationFilter, AiConversationWhereInput>
  }

  export type AiMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    inputTokens?: SortOrderInput | SortOrder
    outputTokens?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: AiConversationOrderByWithRelationInput
    _relevance?: AiMessageOrderByRelevanceInput
  }

  export type AiMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiMessageWhereInput | AiMessageWhereInput[]
    OR?: AiMessageWhereInput[]
    NOT?: AiMessageWhereInput | AiMessageWhereInput[]
    conversationId?: UuidFilter<"AiMessage"> | string
    role?: EnumAiRoleFilter<"AiMessage"> | $Enums.AiRole
    content?: StringFilter<"AiMessage"> | string
    inputTokens?: IntNullableFilter<"AiMessage"> | number | null
    outputTokens?: IntNullableFilter<"AiMessage"> | number | null
    provider?: StringNullableFilter<"AiMessage"> | string | null
    model?: StringNullableFilter<"AiMessage"> | string | null
    latencyMs?: IntNullableFilter<"AiMessage"> | number | null
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
    conversation?: XOR<AiConversationRelationFilter, AiConversationWhereInput>
  }, "id">

  export type AiMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    inputTokens?: SortOrderInput | SortOrder
    outputTokens?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiMessageCountOrderByAggregateInput
    _avg?: AiMessageAvgOrderByAggregateInput
    _max?: AiMessageMaxOrderByAggregateInput
    _min?: AiMessageMinOrderByAggregateInput
    _sum?: AiMessageSumOrderByAggregateInput
  }

  export type AiMessageScalarWhereWithAggregatesInput = {
    AND?: AiMessageScalarWhereWithAggregatesInput | AiMessageScalarWhereWithAggregatesInput[]
    OR?: AiMessageScalarWhereWithAggregatesInput[]
    NOT?: AiMessageScalarWhereWithAggregatesInput | AiMessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AiMessage"> | string
    conversationId?: UuidWithAggregatesFilter<"AiMessage"> | string
    role?: EnumAiRoleWithAggregatesFilter<"AiMessage"> | $Enums.AiRole
    content?: StringWithAggregatesFilter<"AiMessage"> | string
    inputTokens?: IntNullableWithAggregatesFilter<"AiMessage"> | number | null
    outputTokens?: IntNullableWithAggregatesFilter<"AiMessage"> | number | null
    provider?: StringNullableWithAggregatesFilter<"AiMessage"> | string | null
    model?: StringNullableWithAggregatesFilter<"AiMessage"> | string | null
    latencyMs?: IntNullableWithAggregatesFilter<"AiMessage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AiMessage"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: UuidFilter<"Document"> | string
    companyId?: UuidFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    content?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    sourceUrl?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    _relevance?: DocumentOrderByRelevanceInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    companyId?: UuidFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    content?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    sourceUrl?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Document"> | string
    companyId?: UuidWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    content?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    sourceUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Document">
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type CompanyInvitationWhereInput = {
    AND?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    OR?: CompanyInvitationWhereInput[]
    NOT?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    id?: UuidFilter<"CompanyInvitation"> | string
    email?: StringFilter<"CompanyInvitation"> | string
    role?: EnumUserRoleFilter<"CompanyInvitation"> | $Enums.UserRole
    token?: UuidFilter<"CompanyInvitation"> | string
    status?: EnumInvitationStatusFilter<"CompanyInvitation"> | $Enums.InvitationStatus
    companyId?: UuidFilter<"CompanyInvitation"> | string
    inviterId?: UuidFilter<"CompanyInvitation"> | string
    expiresAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CompanyInvitation"> | Date | string | null
    acceptedBy?: UuidNullableFilter<"CompanyInvitation"> | string | null
    createdAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    inviter?: XOR<UserRelationFilter, UserWhereInput>
    acceptedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CompanyInvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    inviterId?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    acceptedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    acceptedUser?: UserOrderByWithRelationInput
    _relevance?: CompanyInvitationOrderByRelevanceInput
  }

  export type CompanyInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_companyId?: CompanyInvitationEmailCompanyIdCompoundUniqueInput
    AND?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    OR?: CompanyInvitationWhereInput[]
    NOT?: CompanyInvitationWhereInput | CompanyInvitationWhereInput[]
    email?: StringFilter<"CompanyInvitation"> | string
    role?: EnumUserRoleFilter<"CompanyInvitation"> | $Enums.UserRole
    status?: EnumInvitationStatusFilter<"CompanyInvitation"> | $Enums.InvitationStatus
    companyId?: UuidFilter<"CompanyInvitation"> | string
    inviterId?: UuidFilter<"CompanyInvitation"> | string
    expiresAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CompanyInvitation"> | Date | string | null
    acceptedBy?: UuidNullableFilter<"CompanyInvitation"> | string | null
    createdAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    inviter?: XOR<UserRelationFilter, UserWhereInput>
    acceptedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "token" | "email_companyId">

  export type CompanyInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    inviterId?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    acceptedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyInvitationCountOrderByAggregateInput
    _max?: CompanyInvitationMaxOrderByAggregateInput
    _min?: CompanyInvitationMinOrderByAggregateInput
  }

  export type CompanyInvitationScalarWhereWithAggregatesInput = {
    AND?: CompanyInvitationScalarWhereWithAggregatesInput | CompanyInvitationScalarWhereWithAggregatesInput[]
    OR?: CompanyInvitationScalarWhereWithAggregatesInput[]
    NOT?: CompanyInvitationScalarWhereWithAggregatesInput | CompanyInvitationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CompanyInvitation"> | string
    email?: StringWithAggregatesFilter<"CompanyInvitation"> | string
    role?: EnumUserRoleWithAggregatesFilter<"CompanyInvitation"> | $Enums.UserRole
    token?: UuidWithAggregatesFilter<"CompanyInvitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"CompanyInvitation"> | $Enums.InvitationStatus
    companyId?: UuidWithAggregatesFilter<"CompanyInvitation"> | string
    inviterId?: UuidWithAggregatesFilter<"CompanyInvitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"CompanyInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"CompanyInvitation"> | Date | string | null
    acceptedBy?: UuidNullableWithAggregatesFilter<"CompanyInvitation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyInvitation"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidFilter<"AuditLog"> | string
    companyId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    _relevance?: AuditLogOrderByRelevanceInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: UuidFilter<"AuditLog"> | string
    companyId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    userId?: UuidWithAggregatesFilter<"AuditLog"> | string
    companyId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: UuidFilter<"AnalyticsEvent"> | string
    companyId?: UuidNullableFilter<"AnalyticsEvent"> | string | null
    userId?: UuidNullableFilter<"AnalyticsEvent"> | string | null
    eventType?: StringFilter<"AnalyticsEvent"> | string
    category?: StringFilter<"AnalyticsEvent"> | string
    value?: DecimalNullableFilter<"AnalyticsEvent"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"AnalyticsEvent"> | string | null
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    category?: SortOrder
    value?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: AnalyticsEventOrderByRelevanceInput
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    companyId?: UuidNullableFilter<"AnalyticsEvent"> | string | null
    userId?: UuidNullableFilter<"AnalyticsEvent"> | string | null
    eventType?: StringFilter<"AnalyticsEvent"> | string
    category?: StringFilter<"AnalyticsEvent"> | string
    value?: DecimalNullableFilter<"AnalyticsEvent"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"AnalyticsEvent"> | string | null
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    category?: SortOrder
    value?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _avg?: AnalyticsEventAvgOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
    _sum?: AnalyticsEventSumOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AnalyticsEvent"> | string
    companyId?: UuidNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    userId?: UuidNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    category?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    value?: DecimalNullableWithAggregatesFilter<"AnalyticsEvent"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AnalyticsEvent">
    timestamp?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
  }

  export type OAuthAppWhereInput = {
    AND?: OAuthAppWhereInput | OAuthAppWhereInput[]
    OR?: OAuthAppWhereInput[]
    NOT?: OAuthAppWhereInput | OAuthAppWhereInput[]
    id?: UuidFilter<"OAuthApp"> | string
    companyId?: UuidFilter<"OAuthApp"> | string
    createdById?: UuidFilter<"OAuthApp"> | string
    name?: StringFilter<"OAuthApp"> | string
    description?: StringNullableFilter<"OAuthApp"> | string | null
    logoUrl?: StringNullableFilter<"OAuthApp"> | string | null
    website?: StringNullableFilter<"OAuthApp"> | string | null
    clientId?: StringFilter<"OAuthApp"> | string
    clientSecret?: StringFilter<"OAuthApp"> | string
    redirectUris?: StringNullableListFilter<"OAuthApp">
    scopes?: StringNullableListFilter<"OAuthApp">
    rateLimit?: IntFilter<"OAuthApp"> | number
    dailyQuota?: IntFilter<"OAuthApp"> | number
    isActive?: BoolFilter<"OAuthApp"> | boolean
    isPublic?: BoolFilter<"OAuthApp"> | boolean
    createdAt?: DateTimeFilter<"OAuthApp"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthApp"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    tokens?: OAuthTokenListRelationFilter
    apiUsage?: ApiUsageListRelationFilter
  }

  export type OAuthAppOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    dailyQuota?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    tokens?: OAuthTokenOrderByRelationAggregateInput
    apiUsage?: ApiUsageOrderByRelationAggregateInput
    _relevance?: OAuthAppOrderByRelevanceInput
  }

  export type OAuthAppWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId?: string
    AND?: OAuthAppWhereInput | OAuthAppWhereInput[]
    OR?: OAuthAppWhereInput[]
    NOT?: OAuthAppWhereInput | OAuthAppWhereInput[]
    companyId?: UuidFilter<"OAuthApp"> | string
    createdById?: UuidFilter<"OAuthApp"> | string
    name?: StringFilter<"OAuthApp"> | string
    description?: StringNullableFilter<"OAuthApp"> | string | null
    logoUrl?: StringNullableFilter<"OAuthApp"> | string | null
    website?: StringNullableFilter<"OAuthApp"> | string | null
    clientSecret?: StringFilter<"OAuthApp"> | string
    redirectUris?: StringNullableListFilter<"OAuthApp">
    scopes?: StringNullableListFilter<"OAuthApp">
    rateLimit?: IntFilter<"OAuthApp"> | number
    dailyQuota?: IntFilter<"OAuthApp"> | number
    isActive?: BoolFilter<"OAuthApp"> | boolean
    isPublic?: BoolFilter<"OAuthApp"> | boolean
    createdAt?: DateTimeFilter<"OAuthApp"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthApp"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    tokens?: OAuthTokenListRelationFilter
    apiUsage?: ApiUsageListRelationFilter
  }, "id" | "clientId">

  export type OAuthAppOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    dailyQuota?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OAuthAppCountOrderByAggregateInput
    _avg?: OAuthAppAvgOrderByAggregateInput
    _max?: OAuthAppMaxOrderByAggregateInput
    _min?: OAuthAppMinOrderByAggregateInput
    _sum?: OAuthAppSumOrderByAggregateInput
  }

  export type OAuthAppScalarWhereWithAggregatesInput = {
    AND?: OAuthAppScalarWhereWithAggregatesInput | OAuthAppScalarWhereWithAggregatesInput[]
    OR?: OAuthAppScalarWhereWithAggregatesInput[]
    NOT?: OAuthAppScalarWhereWithAggregatesInput | OAuthAppScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OAuthApp"> | string
    companyId?: UuidWithAggregatesFilter<"OAuthApp"> | string
    createdById?: UuidWithAggregatesFilter<"OAuthApp"> | string
    name?: StringWithAggregatesFilter<"OAuthApp"> | string
    description?: StringNullableWithAggregatesFilter<"OAuthApp"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"OAuthApp"> | string | null
    website?: StringNullableWithAggregatesFilter<"OAuthApp"> | string | null
    clientId?: StringWithAggregatesFilter<"OAuthApp"> | string
    clientSecret?: StringWithAggregatesFilter<"OAuthApp"> | string
    redirectUris?: StringNullableListFilter<"OAuthApp">
    scopes?: StringNullableListFilter<"OAuthApp">
    rateLimit?: IntWithAggregatesFilter<"OAuthApp"> | number
    dailyQuota?: IntWithAggregatesFilter<"OAuthApp"> | number
    isActive?: BoolWithAggregatesFilter<"OAuthApp"> | boolean
    isPublic?: BoolWithAggregatesFilter<"OAuthApp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OAuthApp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OAuthApp"> | Date | string
  }

  export type OAuthTokenWhereInput = {
    AND?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    OR?: OAuthTokenWhereInput[]
    NOT?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    id?: UuidFilter<"OAuthToken"> | string
    appId?: UuidFilter<"OAuthToken"> | string
    userId?: UuidFilter<"OAuthToken"> | string
    companyId?: UuidFilter<"OAuthToken"> | string
    accessToken?: StringFilter<"OAuthToken"> | string
    refreshToken?: StringNullableFilter<"OAuthToken"> | string | null
    scopes?: StringNullableListFilter<"OAuthToken">
    expiresAt?: DateTimeFilter<"OAuthToken"> | Date | string
    refreshExpiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    authorizationCode?: StringNullableFilter<"OAuthToken"> | string | null
    codeExpiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    isRevoked?: BoolFilter<"OAuthToken"> | boolean
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    app?: XOR<OAuthAppRelationFilter, OAuthAppWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type OAuthTokenOrderByWithRelationInput = {
    id?: SortOrder
    appId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    refreshExpiresAt?: SortOrderInput | SortOrder
    authorizationCode?: SortOrderInput | SortOrder
    codeExpiresAt?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    app?: OAuthAppOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    _relevance?: OAuthTokenOrderByRelevanceInput
  }

  export type OAuthTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessToken?: string
    refreshToken?: string
    authorizationCode?: string
    AND?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    OR?: OAuthTokenWhereInput[]
    NOT?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    appId?: UuidFilter<"OAuthToken"> | string
    userId?: UuidFilter<"OAuthToken"> | string
    companyId?: UuidFilter<"OAuthToken"> | string
    scopes?: StringNullableListFilter<"OAuthToken">
    expiresAt?: DateTimeFilter<"OAuthToken"> | Date | string
    refreshExpiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    codeExpiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    isRevoked?: BoolFilter<"OAuthToken"> | boolean
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    app?: XOR<OAuthAppRelationFilter, OAuthAppWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "accessToken" | "refreshToken" | "authorizationCode">

  export type OAuthTokenOrderByWithAggregationInput = {
    id?: SortOrder
    appId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    refreshExpiresAt?: SortOrderInput | SortOrder
    authorizationCode?: SortOrderInput | SortOrder
    codeExpiresAt?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: OAuthTokenCountOrderByAggregateInput
    _max?: OAuthTokenMaxOrderByAggregateInput
    _min?: OAuthTokenMinOrderByAggregateInput
  }

  export type OAuthTokenScalarWhereWithAggregatesInput = {
    AND?: OAuthTokenScalarWhereWithAggregatesInput | OAuthTokenScalarWhereWithAggregatesInput[]
    OR?: OAuthTokenScalarWhereWithAggregatesInput[]
    NOT?: OAuthTokenScalarWhereWithAggregatesInput | OAuthTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OAuthToken"> | string
    appId?: UuidWithAggregatesFilter<"OAuthToken"> | string
    userId?: UuidWithAggregatesFilter<"OAuthToken"> | string
    companyId?: UuidWithAggregatesFilter<"OAuthToken"> | string
    accessToken?: StringWithAggregatesFilter<"OAuthToken"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"OAuthToken"> | string | null
    scopes?: StringNullableListFilter<"OAuthToken">
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthToken"> | Date | string
    refreshExpiresAt?: DateTimeNullableWithAggregatesFilter<"OAuthToken"> | Date | string | null
    authorizationCode?: StringNullableWithAggregatesFilter<"OAuthToken"> | string | null
    codeExpiresAt?: DateTimeNullableWithAggregatesFilter<"OAuthToken"> | Date | string | null
    isRevoked?: BoolWithAggregatesFilter<"OAuthToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OAuthToken"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"OAuthToken"> | Date | string | null
  }

  export type ApiUsageWhereInput = {
    AND?: ApiUsageWhereInput | ApiUsageWhereInput[]
    OR?: ApiUsageWhereInput[]
    NOT?: ApiUsageWhereInput | ApiUsageWhereInput[]
    id?: UuidFilter<"ApiUsage"> | string
    appId?: UuidNullableFilter<"ApiUsage"> | string | null
    companyId?: UuidFilter<"ApiUsage"> | string
    userId?: UuidNullableFilter<"ApiUsage"> | string | null
    endpoint?: StringFilter<"ApiUsage"> | string
    method?: StringFilter<"ApiUsage"> | string
    statusCode?: IntFilter<"ApiUsage"> | number
    responseTime?: IntFilter<"ApiUsage"> | number
    requestCount?: IntFilter<"ApiUsage"> | number
    timestamp?: DateTimeFilter<"ApiUsage"> | Date | string
    ipAddress?: StringNullableFilter<"ApiUsage"> | string | null
    userAgent?: StringNullableFilter<"ApiUsage"> | string | null
    app?: XOR<OAuthAppNullableRelationFilter, OAuthAppWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ApiUsageOrderByWithRelationInput = {
    id?: SortOrder
    appId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestCount?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    app?: OAuthAppOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: ApiUsageOrderByRelevanceInput
  }

  export type ApiUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiUsageWhereInput | ApiUsageWhereInput[]
    OR?: ApiUsageWhereInput[]
    NOT?: ApiUsageWhereInput | ApiUsageWhereInput[]
    appId?: UuidNullableFilter<"ApiUsage"> | string | null
    companyId?: UuidFilter<"ApiUsage"> | string
    userId?: UuidNullableFilter<"ApiUsage"> | string | null
    endpoint?: StringFilter<"ApiUsage"> | string
    method?: StringFilter<"ApiUsage"> | string
    statusCode?: IntFilter<"ApiUsage"> | number
    responseTime?: IntFilter<"ApiUsage"> | number
    requestCount?: IntFilter<"ApiUsage"> | number
    timestamp?: DateTimeFilter<"ApiUsage"> | Date | string
    ipAddress?: StringNullableFilter<"ApiUsage"> | string | null
    userAgent?: StringNullableFilter<"ApiUsage"> | string | null
    app?: XOR<OAuthAppNullableRelationFilter, OAuthAppWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ApiUsageOrderByWithAggregationInput = {
    id?: SortOrder
    appId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestCount?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: ApiUsageCountOrderByAggregateInput
    _avg?: ApiUsageAvgOrderByAggregateInput
    _max?: ApiUsageMaxOrderByAggregateInput
    _min?: ApiUsageMinOrderByAggregateInput
    _sum?: ApiUsageSumOrderByAggregateInput
  }

  export type ApiUsageScalarWhereWithAggregatesInput = {
    AND?: ApiUsageScalarWhereWithAggregatesInput | ApiUsageScalarWhereWithAggregatesInput[]
    OR?: ApiUsageScalarWhereWithAggregatesInput[]
    NOT?: ApiUsageScalarWhereWithAggregatesInput | ApiUsageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ApiUsage"> | string
    appId?: UuidNullableWithAggregatesFilter<"ApiUsage"> | string | null
    companyId?: UuidWithAggregatesFilter<"ApiUsage"> | string
    userId?: UuidNullableWithAggregatesFilter<"ApiUsage"> | string | null
    endpoint?: StringWithAggregatesFilter<"ApiUsage"> | string
    method?: StringWithAggregatesFilter<"ApiUsage"> | string
    statusCode?: IntWithAggregatesFilter<"ApiUsage"> | number
    responseTime?: IntWithAggregatesFilter<"ApiUsage"> | number
    requestCount?: IntWithAggregatesFilter<"ApiUsage"> | number
    timestamp?: DateTimeWithAggregatesFilter<"ApiUsage"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"ApiUsage"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ApiUsage"> | string | null
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: UuidFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    stripePriceId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    monthlyPrice?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    maxCompanies?: IntFilter<"SubscriptionPlan"> | number
    maxUsers?: IntFilter<"SubscriptionPlan"> | number
    maxInvoicesPerMonth?: IntFilter<"SubscriptionPlan"> | number
    maxWallets?: IntFilter<"SubscriptionPlan"> | number
    maxAiMessagesPerMonth?: IntFilter<"SubscriptionPlan"> | number
    verifactuEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    siiEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    aiChatEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    aiOcrEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    cryptoEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    multiUserEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    prioritySupport?: BoolFilter<"SubscriptionPlan"> | boolean
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    yearlyPrice?: SortOrder
    currency?: SortOrder
    maxCompanies?: SortOrder
    maxUsers?: SortOrder
    maxInvoicesPerMonth?: SortOrder
    maxWallets?: SortOrder
    maxAiMessagesPerMonth?: SortOrder
    verifactuEnabled?: SortOrder
    siiEnabled?: SortOrder
    aiChatEnabled?: SortOrder
    aiOcrEnabled?: SortOrder
    cryptoEnabled?: SortOrder
    multiUserEnabled?: SortOrder
    prioritySupport?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    _relevance?: SubscriptionPlanOrderByRelevanceInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    name?: StringFilter<"SubscriptionPlan"> | string
    stripePriceId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    monthlyPrice?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    maxCompanies?: IntFilter<"SubscriptionPlan"> | number
    maxUsers?: IntFilter<"SubscriptionPlan"> | number
    maxInvoicesPerMonth?: IntFilter<"SubscriptionPlan"> | number
    maxWallets?: IntFilter<"SubscriptionPlan"> | number
    maxAiMessagesPerMonth?: IntFilter<"SubscriptionPlan"> | number
    verifactuEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    siiEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    aiChatEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    aiOcrEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    cryptoEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    multiUserEnabled?: BoolFilter<"SubscriptionPlan"> | boolean
    prioritySupport?: BoolFilter<"SubscriptionPlan"> | boolean
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    yearlyPrice?: SortOrder
    currency?: SortOrder
    maxCompanies?: SortOrder
    maxUsers?: SortOrder
    maxInvoicesPerMonth?: SortOrder
    maxWallets?: SortOrder
    maxAiMessagesPerMonth?: SortOrder
    verifactuEnabled?: SortOrder
    siiEnabled?: SortOrder
    aiChatEnabled?: SortOrder
    aiOcrEnabled?: SortOrder
    cryptoEnabled?: SortOrder
    multiUserEnabled?: SortOrder
    prioritySupport?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    stripePriceId?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    monthlyPrice?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    maxCompanies?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxUsers?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxInvoicesPerMonth?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxWallets?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    maxAiMessagesPerMonth?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    verifactuEnabled?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    siiEnabled?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    aiChatEnabled?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    aiOcrEnabled?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    cryptoEnabled?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    multiUserEnabled?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    prioritySupport?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: UuidFilter<"Subscription"> | string
    companyId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    invoicesThisMonth?: IntFilter<"Subscription"> | number
    aiMessagesThisMonth?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    invoicesThisMonth?: SortOrder
    aiMessagesThisMonth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SubscriptionPlanOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    _relevance?: SubscriptionOrderByRelevanceInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    planId?: UuidFilter<"Subscription"> | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    invoicesThisMonth?: IntFilter<"Subscription"> | number
    aiMessagesThisMonth?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: XOR<SubscriptionPlanRelationFilter, SubscriptionPlanWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "companyId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    invoicesThisMonth?: SortOrder
    aiMessagesThisMonth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Subscription"> | string
    companyId?: UuidWithAggregatesFilter<"Subscription"> | string
    planId?: UuidWithAggregatesFilter<"Subscription"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    invoicesThisMonth?: IntWithAggregatesFilter<"Subscription"> | number
    aiMessagesThisMonth?: IntWithAggregatesFilter<"Subscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    subscriptionId?: UuidFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    subscriptionId?: UuidFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    subscriptionId?: UuidWithAggregatesFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UserOnboardingWhereInput = {
    AND?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    OR?: UserOnboardingWhereInput[]
    NOT?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    userId?: UuidFilter<"UserOnboarding"> | string
    status?: EnumUserOnboardingStatusFilter<"UserOnboarding"> | $Enums.UserOnboardingStatus
    currentStep?: IntFilter<"UserOnboarding"> | number
    completedSteps?: JsonFilter<"UserOnboarding">
    skippedSteps?: JsonFilter<"UserOnboarding">
    startedAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserOnboarding"> | Date | string | null
    lastActivityAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserOnboardingOrderByWithRelationInput = {
    userId?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    completedSteps?: SortOrder
    skippedSteps?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: UserOnboardingOrderByRelevanceInput
  }

  export type UserOnboardingWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    OR?: UserOnboardingWhereInput[]
    NOT?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    status?: EnumUserOnboardingStatusFilter<"UserOnboarding"> | $Enums.UserOnboardingStatus
    currentStep?: IntFilter<"UserOnboarding"> | number
    completedSteps?: JsonFilter<"UserOnboarding">
    skippedSteps?: JsonFilter<"UserOnboarding">
    startedAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserOnboarding"> | Date | string | null
    lastActivityAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type UserOnboardingOrderByWithAggregationInput = {
    userId?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    completedSteps?: SortOrder
    skippedSteps?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    _count?: UserOnboardingCountOrderByAggregateInput
    _avg?: UserOnboardingAvgOrderByAggregateInput
    _max?: UserOnboardingMaxOrderByAggregateInput
    _min?: UserOnboardingMinOrderByAggregateInput
    _sum?: UserOnboardingSumOrderByAggregateInput
  }

  export type UserOnboardingScalarWhereWithAggregatesInput = {
    AND?: UserOnboardingScalarWhereWithAggregatesInput | UserOnboardingScalarWhereWithAggregatesInput[]
    OR?: UserOnboardingScalarWhereWithAggregatesInput[]
    NOT?: UserOnboardingScalarWhereWithAggregatesInput | UserOnboardingScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserOnboarding"> | string
    status?: EnumUserOnboardingStatusWithAggregatesFilter<"UserOnboarding"> | $Enums.UserOnboardingStatus
    currentStep?: IntWithAggregatesFilter<"UserOnboarding"> | number
    completedSteps?: JsonWithAggregatesFilter<"UserOnboarding">
    skippedSteps?: JsonWithAggregatesFilter<"UserOnboarding">
    startedAt?: DateTimeWithAggregatesFilter<"UserOnboarding"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserOnboarding"> | Date | string | null
    lastActivityAt?: DateTimeWithAggregatesFilter<"UserOnboarding"> | Date | string
  }

  export type WebhookSubscriptionWhereInput = {
    AND?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    OR?: WebhookSubscriptionWhereInput[]
    NOT?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    id?: UuidFilter<"WebhookSubscription"> | string
    companyId?: UuidFilter<"WebhookSubscription"> | string
    url?: StringFilter<"WebhookSubscription"> | string
    secret?: StringFilter<"WebhookSubscription"> | string
    isActive?: BoolFilter<"WebhookSubscription"> | boolean
    events?: JsonFilter<"WebhookSubscription">
    retryCount?: IntFilter<"WebhookSubscription"> | number
    timeout?: IntFilter<"WebhookSubscription"> | number
    description?: StringNullableFilter<"WebhookSubscription"> | string | null
    metadata?: JsonNullableFilter<"WebhookSubscription">
    createdAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    events?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
    _relevance?: WebhookSubscriptionOrderByRelevanceInput
  }

  export type WebhookSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    OR?: WebhookSubscriptionWhereInput[]
    NOT?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    companyId?: UuidFilter<"WebhookSubscription"> | string
    url?: StringFilter<"WebhookSubscription"> | string
    secret?: StringFilter<"WebhookSubscription"> | string
    isActive?: BoolFilter<"WebhookSubscription"> | boolean
    events?: JsonFilter<"WebhookSubscription">
    retryCount?: IntFilter<"WebhookSubscription"> | number
    timeout?: IntFilter<"WebhookSubscription"> | number
    description?: StringNullableFilter<"WebhookSubscription"> | string | null
    metadata?: JsonNullableFilter<"WebhookSubscription">
    createdAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    events?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookSubscriptionCountOrderByAggregateInput
    _avg?: WebhookSubscriptionAvgOrderByAggregateInput
    _max?: WebhookSubscriptionMaxOrderByAggregateInput
    _min?: WebhookSubscriptionMinOrderByAggregateInput
    _sum?: WebhookSubscriptionSumOrderByAggregateInput
  }

  export type WebhookSubscriptionScalarWhereWithAggregatesInput = {
    AND?: WebhookSubscriptionScalarWhereWithAggregatesInput | WebhookSubscriptionScalarWhereWithAggregatesInput[]
    OR?: WebhookSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: WebhookSubscriptionScalarWhereWithAggregatesInput | WebhookSubscriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WebhookSubscription"> | string
    companyId?: UuidWithAggregatesFilter<"WebhookSubscription"> | string
    url?: StringWithAggregatesFilter<"WebhookSubscription"> | string
    secret?: StringWithAggregatesFilter<"WebhookSubscription"> | string
    isActive?: BoolWithAggregatesFilter<"WebhookSubscription"> | boolean
    events?: JsonWithAggregatesFilter<"WebhookSubscription">
    retryCount?: IntWithAggregatesFilter<"WebhookSubscription"> | number
    timeout?: IntWithAggregatesFilter<"WebhookSubscription"> | number
    description?: StringNullableWithAggregatesFilter<"WebhookSubscription"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"WebhookSubscription">
    createdAt?: DateTimeWithAggregatesFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebhookSubscription"> | Date | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: UuidFilter<"WebhookDelivery"> | string
    subscriptionId?: UuidFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    payloadHash?: StringFilter<"WebhookDelivery"> | string
    status?: EnumWebhookDeliveryStatusFilter<"WebhookDelivery"> | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFilter<"WebhookDelivery"> | number
    maxAttempts?: IntFilter<"WebhookDelivery"> | number
    responseStatus?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    responseHeaders?: JsonNullableFilter<"WebhookDelivery">
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    scheduledFor?: DateTimeFilter<"WebhookDelivery"> | Date | string
    lastAttemptAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    nextAttemptAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    subscription?: XOR<WebhookSubscriptionRelationFilter, WebhookSubscriptionWhereInput>
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    payloadHash?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    responseStatus?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    nextAttemptAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: WebhookSubscriptionOrderByWithRelationInput
    _relevance?: WebhookDeliveryOrderByRelevanceInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    subscriptionId?: UuidFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    payloadHash?: StringFilter<"WebhookDelivery"> | string
    status?: EnumWebhookDeliveryStatusFilter<"WebhookDelivery"> | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFilter<"WebhookDelivery"> | number
    maxAttempts?: IntFilter<"WebhookDelivery"> | number
    responseStatus?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    responseHeaders?: JsonNullableFilter<"WebhookDelivery">
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    scheduledFor?: DateTimeFilter<"WebhookDelivery"> | Date | string
    lastAttemptAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    nextAttemptAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    subscription?: XOR<WebhookSubscriptionRelationFilter, WebhookSubscriptionWhereInput>
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    payloadHash?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    responseStatus?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    scheduledFor?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    nextAttemptAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WebhookDelivery"> | string
    subscriptionId?: UuidWithAggregatesFilter<"WebhookDelivery"> | string
    event?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    payload?: JsonWithAggregatesFilter<"WebhookDelivery">
    payloadHash?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    status?: EnumWebhookDeliveryStatusWithAggregatesFilter<"WebhookDelivery"> | $Enums.WebhookDeliveryStatus
    attemptCount?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    maxAttempts?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    responseStatus?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    responseHeaders?: JsonNullableWithAggregatesFilter<"WebhookDelivery">
    errorMessage?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    scheduledFor?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    nextAttemptAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: UuidFilter<"WebhookEvent"> | string
    companyId?: UuidFilter<"WebhookEvent"> | string
    event?: StringFilter<"WebhookEvent"> | string
    entityType?: StringFilter<"WebhookEvent"> | string
    entityId?: UuidFilter<"WebhookEvent"> | string
    payload?: JsonFilter<"WebhookEvent">
    emittedAt?: DateTimeFilter<"WebhookEvent"> | Date | string
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    event?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    emittedAt?: SortOrder
    _relevance?: WebhookEventOrderByRelevanceInput
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    companyId?: UuidFilter<"WebhookEvent"> | string
    event?: StringFilter<"WebhookEvent"> | string
    entityType?: StringFilter<"WebhookEvent"> | string
    entityId?: UuidFilter<"WebhookEvent"> | string
    payload?: JsonFilter<"WebhookEvent">
    emittedAt?: DateTimeFilter<"WebhookEvent"> | Date | string
  }, "id">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    event?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    emittedAt?: SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WebhookEvent"> | string
    companyId?: UuidWithAggregatesFilter<"WebhookEvent"> | string
    event?: StringWithAggregatesFilter<"WebhookEvent"> | string
    entityType?: StringWithAggregatesFilter<"WebhookEvent"> | string
    entityId?: UuidWithAggregatesFilter<"WebhookEvent"> | string
    payload?: JsonWithAggregatesFilter<"WebhookEvent">
    emittedAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUserCreateInput = {
    id?: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompanyUsersInput
    company: CompanyCreateNestedOneWithoutCompanyUsersInput
  }

  export type CompanyUserUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type CompanyUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompanyUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutCompanyUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type CompanyUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    invoices?: InvoiceCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    companyId: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    invoices?: InvoiceUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    companyId: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFiscalYearsInput
    journalEntries?: JournalEntryCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFiscalYearsNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearCreateManyInput = {
    id?: string
    companyId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAccountsInput
    cryptoAsset?: CryptoAssetCreateNestedOneWithoutAccountsInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    cryptoAssetId?: string | null
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    cryptoAsset?: CryptoAssetUpdateOneWithoutAccountsNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    cryptoAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    cryptoAssetId?: string | null
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    cryptoAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateInput = {
    id?: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
    fiscalYear: FiscalYearCreateNestedOneWithoutJournalEntriesInput
    lines?: JournalLineCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    companyId: string
    fiscalYearId: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: JournalLineUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
    fiscalYear?: FiscalYearUpdateOneRequiredWithoutJournalEntriesNestedInput
    lines?: JournalLineUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    fiscalYearId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: JournalLineUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    companyId: string
    fiscalYearId: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    fiscalYearId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateInput = {
    id?: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
    journalEntry: JournalEntryCreateNestedOneWithoutLinesInput
    account: AccountCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateInput = {
    id?: string
    journalEntryId: string
    accountId: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
  }

  export type JournalLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalEntry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
    account?: AccountUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateManyInput = {
    id?: string
    journalEntryId: string
    accountId: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
  }

  export type JournalLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceSeriesCreateInput = {
    id?: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoiceSeriesInput
    invoices?: InvoiceCreateNestedManyWithoutSeriesInput
  }

  export type InvoiceSeriesUncheckedCreateInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type InvoiceSeriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoiceSeriesNestedInput
    invoices?: InvoiceUpdateManyWithoutSeriesNestedInput
  }

  export type InvoiceSeriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type InvoiceSeriesCreateManyInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceSeriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceSeriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
    series: InvoiceSeriesCreateNestedOneWithoutInvoicesInput
    contact?: ContactCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    companyId: string
    seriesId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxUncheckedCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    series?: InvoiceSeriesUpdateOneRequiredWithoutInvoicesNestedInput
    contact?: ContactUpdateOneWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUncheckedUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    companyId: string
    seriesId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateInput = {
    id?: string
    lineNumber: number
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    accountCode?: string | null
    invoice: InvoiceCreateNestedOneWithoutLinesInput
  }

  export type InvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    lineNumber: number
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    accountCode?: string | null
  }

  export type InvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    lineNumber: number
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    accountCode?: string | null
  }

  export type InvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceTaxCreateInput = {
    id?: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxType?: $Enums.TaxType
    invoice: InvoiceCreateNestedOneWithoutTaxesInput
  }

  export type InvoiceTaxUncheckedCreateInput = {
    id?: string
    invoiceId: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxType?: $Enums.TaxType
  }

  export type InvoiceTaxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
    invoice?: InvoiceUpdateOneRequiredWithoutTaxesNestedInput
  }

  export type InvoiceTaxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
  }

  export type InvoiceTaxCreateManyInput = {
    id?: string
    invoiceId: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxType?: $Enums.TaxType
  }

  export type InvoiceTaxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
  }

  export type InvoiceTaxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
  }

  export type CryptoAssetCreateInput = {
    id?: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCryptoAssetsInput
    accounts?: AccountCreateNestedManyWithoutCryptoAssetInput
    lots?: CryptoLotCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetUncheckedCreateInput = {
    id?: string
    companyId: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutCryptoAssetInput
    lots?: CryptoLotUncheckedCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCryptoAssetsNestedInput
    accounts?: AccountUpdateManyWithoutCryptoAssetNestedInput
    lots?: CryptoLotUpdateManyWithoutCryptoAssetNestedInput
  }

  export type CryptoAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutCryptoAssetNestedInput
    lots?: CryptoLotUncheckedUpdateManyWithoutCryptoAssetNestedInput
  }

  export type CryptoAssetCreateManyInput = {
    id?: string
    companyId: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutWalletsInput
    transactions?: CryptoTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    companyId: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: CryptoTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWalletsNestedInput
    transactions?: CryptoTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CryptoTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    companyId: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeAccountCreateInput = {
    id?: string
    exchange: string
    label?: string | null
    apiKey?: string | null
    apiSecret?: string | null
    isReadOnly?: boolean
    lastSyncAt?: Date | string | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutExchangeAccountsInput
  }

  export type ExchangeAccountUncheckedCreateInput = {
    id?: string
    companyId: string
    exchange: string
    label?: string | null
    apiKey?: string | null
    apiSecret?: string | null
    isReadOnly?: boolean
    lastSyncAt?: Date | string | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangeAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isReadOnly?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutExchangeAccountsNestedInput
  }

  export type ExchangeAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isReadOnly?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeAccountCreateManyInput = {
    id?: string
    companyId: string
    exchange: string
    label?: string | null
    apiKey?: string | null
    apiSecret?: string | null
    isReadOnly?: boolean
    lastSyncAt?: Date | string | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangeAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isReadOnly?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isReadOnly?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTransactionCreateInput = {
    id?: string
    txHash: string
    blockNumber: bigint | number
    blockTimestamp: Date | string
    chain: string
    type: $Enums.CryptoTxType
    subtype?: string | null
    assetIn?: string | null
    amountIn?: Decimal | DecimalJsLike | number | string | null
    assetOut?: string | null
    amountOut?: Decimal | DecimalJsLike | number | string | null
    feeAsset?: string | null
    feeAmount?: Decimal | DecimalJsLike | number | string | null
    priceInEur?: Decimal | DecimalJsLike | number | string | null
    priceOutEur?: Decimal | DecimalJsLike | number | string | null
    feeEur?: Decimal | DecimalJsLike | number | string | null
    costBasis?: Decimal | DecimalJsLike | number | string | null
    realizedGain?: Decimal | DecimalJsLike | number | string | null
    aiCategorized?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiReasoning?: string | null
    manualType?: $Enums.CryptoTxType | null
    manualNotes?: string | null
    journalEntryId?: string | null
    status?: $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    wallet: WalletCreateNestedOneWithoutTransactionsInput
  }

  export type CryptoTransactionUncheckedCreateInput = {
    id?: string
    walletId: string
    txHash: string
    blockNumber: bigint | number
    blockTimestamp: Date | string
    chain: string
    type: $Enums.CryptoTxType
    subtype?: string | null
    assetIn?: string | null
    amountIn?: Decimal | DecimalJsLike | number | string | null
    assetOut?: string | null
    amountOut?: Decimal | DecimalJsLike | number | string | null
    feeAsset?: string | null
    feeAmount?: Decimal | DecimalJsLike | number | string | null
    priceInEur?: Decimal | DecimalJsLike | number | string | null
    priceOutEur?: Decimal | DecimalJsLike | number | string | null
    feeEur?: Decimal | DecimalJsLike | number | string | null
    costBasis?: Decimal | DecimalJsLike | number | string | null
    realizedGain?: Decimal | DecimalJsLike | number | string | null
    aiCategorized?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiReasoning?: string | null
    manualType?: $Enums.CryptoTxType | null
    manualNotes?: string | null
    journalEntryId?: string | null
    status?: $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    blockTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: EnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    assetIn?: NullableStringFieldUpdateOperationsInput | string | null
    amountIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    assetOut?: NullableStringFieldUpdateOperationsInput | string | null
    amountOut?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeAsset?: NullableStringFieldUpdateOperationsInput | string | null
    feeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceInEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costBasis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    realizedGain?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    manualType?: NullableEnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType | null
    manualNotes?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type CryptoTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    blockTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: EnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    assetIn?: NullableStringFieldUpdateOperationsInput | string | null
    amountIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    assetOut?: NullableStringFieldUpdateOperationsInput | string | null
    amountOut?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeAsset?: NullableStringFieldUpdateOperationsInput | string | null
    feeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceInEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costBasis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    realizedGain?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    manualType?: NullableEnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType | null
    manualNotes?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTransactionCreateManyInput = {
    id?: string
    walletId: string
    txHash: string
    blockNumber: bigint | number
    blockTimestamp: Date | string
    chain: string
    type: $Enums.CryptoTxType
    subtype?: string | null
    assetIn?: string | null
    amountIn?: Decimal | DecimalJsLike | number | string | null
    assetOut?: string | null
    amountOut?: Decimal | DecimalJsLike | number | string | null
    feeAsset?: string | null
    feeAmount?: Decimal | DecimalJsLike | number | string | null
    priceInEur?: Decimal | DecimalJsLike | number | string | null
    priceOutEur?: Decimal | DecimalJsLike | number | string | null
    feeEur?: Decimal | DecimalJsLike | number | string | null
    costBasis?: Decimal | DecimalJsLike | number | string | null
    realizedGain?: Decimal | DecimalJsLike | number | string | null
    aiCategorized?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiReasoning?: string | null
    manualType?: $Enums.CryptoTxType | null
    manualNotes?: string | null
    journalEntryId?: string | null
    status?: $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    blockTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: EnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    assetIn?: NullableStringFieldUpdateOperationsInput | string | null
    amountIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    assetOut?: NullableStringFieldUpdateOperationsInput | string | null
    amountOut?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeAsset?: NullableStringFieldUpdateOperationsInput | string | null
    feeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceInEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costBasis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    realizedGain?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    manualType?: NullableEnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType | null
    manualNotes?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    blockTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: EnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    assetIn?: NullableStringFieldUpdateOperationsInput | string | null
    amountIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    assetOut?: NullableStringFieldUpdateOperationsInput | string | null
    amountOut?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeAsset?: NullableStringFieldUpdateOperationsInput | string | null
    feeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceInEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costBasis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    realizedGain?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    manualType?: NullableEnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType | null
    manualNotes?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoLotCreateInput = {
    id?: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCryptoLotsInput
    cryptoAsset: CryptoAssetCreateNestedOneWithoutLotsInput
  }

  export type CryptoLotUncheckedCreateInput = {
    id?: string
    companyId: string
    cryptoAssetId: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoLotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCryptoLotsNestedInput
    cryptoAsset?: CryptoAssetUpdateOneRequiredWithoutLotsNestedInput
  }

  export type CryptoLotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cryptoAssetId?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoLotCreateManyInput = {
    id?: string
    companyId: string
    cryptoAssetId: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoLotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoLotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cryptoAssetId?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateInput = {
    id?: string
    symbol: string
    priceEur: Decimal | DecimalJsLike | number | string
    source: string
    timestamp?: Date | string
  }

  export type PriceHistoryUncheckedCreateInput = {
    id?: string
    symbol: string
    priceEur: Decimal | DecimalJsLike | number | string
    source: string
    timestamp?: Date | string
  }

  export type PriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    priceEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    priceEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateManyInput = {
    id?: string
    symbol: string
    priceEur: Decimal | DecimalJsLike | number | string
    source: string
    timestamp?: Date | string
  }

  export type PriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    priceEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    priceEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerifactuRecordCreateInput = {
    id?: string
    hash: string
    prevHash?: string | null
    xmlContent: string
    state?: $Enums.VerifactuRecordState
    csv?: string | null
    sentAt?: Date | string | null
    retryCount?: number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutVerifactuRecordsInput
  }

  export type VerifactuRecordUncheckedCreateInput = {
    id?: string
    invoiceId: string
    hash: string
    prevHash?: string | null
    xmlContent: string
    state?: $Enums.VerifactuRecordState
    csv?: string | null
    sentAt?: Date | string | null
    retryCount?: number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerifactuRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    prevHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlContent?: StringFieldUpdateOperationsInput | string
    state?: EnumVerifactuRecordStateFieldUpdateOperationsInput | $Enums.VerifactuRecordState
    csv?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutVerifactuRecordsNestedInput
  }

  export type VerifactuRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    prevHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlContent?: StringFieldUpdateOperationsInput | string
    state?: EnumVerifactuRecordStateFieldUpdateOperationsInput | $Enums.VerifactuRecordState
    csv?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerifactuRecordCreateManyInput = {
    id?: string
    invoiceId: string
    hash: string
    prevHash?: string | null
    xmlContent: string
    state?: $Enums.VerifactuRecordState
    csv?: string | null
    sentAt?: Date | string | null
    retryCount?: number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerifactuRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    prevHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlContent?: StringFieldUpdateOperationsInput | string
    state?: EnumVerifactuRecordStateFieldUpdateOperationsInput | $Enums.VerifactuRecordState
    csv?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerifactuRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    prevHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlContent?: StringFieldUpdateOperationsInput | string
    state?: EnumVerifactuRecordStateFieldUpdateOperationsInput | $Enums.VerifactuRecordState
    csv?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationCreateInput = {
    id?: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAiConversationsInput
    user: UserCreateNestedOneWithoutAiConversationsInput
    messages?: AiMessageCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUncheckedCreateInput = {
    id?: string
    companyId: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAiConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutAiConversationsNestedInput
    messages?: AiMessageUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationCreateManyInput = {
    id?: string
    companyId: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateInput = {
    id?: string
    role: $Enums.AiRole
    content: string
    inputTokens?: number | null
    outputTokens?: number | null
    provider?: string | null
    model?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
    conversation: AiConversationCreateNestedOneWithoutMessagesInput
  }

  export type AiMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: $Enums.AiRole
    content: string
    inputTokens?: number | null
    outputTokens?: number | null
    provider?: string | null
    model?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type AiMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiRoleFieldUpdateOperationsInput | $Enums.AiRole
    content?: StringFieldUpdateOperationsInput | string
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: AiConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AiMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumAiRoleFieldUpdateOperationsInput | $Enums.AiRole
    content?: StringFieldUpdateOperationsInput | string
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateManyInput = {
    id?: string
    conversationId: string
    role: $Enums.AiRole
    content: string
    inputTokens?: number | null
    outputTokens?: number | null
    provider?: string | null
    model?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type AiMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiRoleFieldUpdateOperationsInput | $Enums.AiRole
    content?: StringFieldUpdateOperationsInput | string
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumAiRoleFieldUpdateOperationsInput | $Enums.AiRole
    content?: StringFieldUpdateOperationsInput | string
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    content: string
    type: $Enums.DocumentType
    sourceUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    companyId: string
    title: string
    content: string
    type: $Enums.DocumentType
    sourceUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    companyId: string
    title: string
    content: string
    type: $Enums.DocumentType
    sourceUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationCreateInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutInvitationsSentInput
    acceptedUser?: UserCreateNestedOneWithoutInvitationsAcceptedInput
  }

  export type CompanyInvitationUncheckedCreateInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    companyId: string
    inviterId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
    acceptedUser?: UserUpdateOneWithoutInvitationsAcceptedNestedInput
  }

  export type CompanyInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    companyId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationCreateManyInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    companyId: string
    inviterId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    companyId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
    company?: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    companyId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    company?: CompanyUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    companyId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    company?: CompanyCreateNestedOneWithoutAnalyticsEventsInput
    user?: UserCreateNestedOneWithoutAnalyticsEventsInput
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    companyId?: string | null
    userId?: string | null
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutAnalyticsEventsNestedInput
    user?: UserUpdateOneWithoutAnalyticsEventsNestedInput
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    companyId?: string | null
    userId?: string | null
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAppCreateInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutOauthAppsInput
    createdBy: UserCreateNestedOneWithoutOauthAppsCreatedInput
    tokens?: OAuthTokenCreateNestedManyWithoutAppInput
    apiUsage?: ApiUsageCreateNestedManyWithoutAppInput
  }

  export type OAuthAppUncheckedCreateInput = {
    id?: string
    companyId: string
    createdById: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: OAuthTokenUncheckedCreateNestedManyWithoutAppInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutAppInput
  }

  export type OAuthAppUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutOauthAppsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOauthAppsCreatedNestedInput
    tokens?: OAuthTokenUpdateManyWithoutAppNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: OAuthTokenUncheckedUpdateManyWithoutAppNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppCreateManyInput = {
    id?: string
    companyId: string
    createdById: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthAppUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAppUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenCreateInput = {
    id?: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    app: OAuthAppCreateNestedOneWithoutTokensInput
    user: UserCreateNestedOneWithoutOauthTokensInput
    company: CompanyCreateNestedOneWithoutOauthTokensInput
  }

  export type OAuthTokenUncheckedCreateInput = {
    id?: string
    appId: string
    userId: string
    companyId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type OAuthTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app?: OAuthAppUpdateOneRequiredWithoutTokensNestedInput
    user?: UserUpdateOneRequiredWithoutOauthTokensNestedInput
    company?: CompanyUpdateOneRequiredWithoutOauthTokensNestedInput
  }

  export type OAuthTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthTokenCreateManyInput = {
    id?: string
    appId: string
    userId: string
    companyId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type OAuthTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiUsageCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    app?: OAuthAppCreateNestedOneWithoutApiUsageInput
    company: CompanyCreateNestedOneWithoutApiUsageInput
    user?: UserCreateNestedOneWithoutApiUsageInput
  }

  export type ApiUsageUncheckedCreateInput = {
    id?: string
    appId?: string | null
    companyId: string
    userId?: string | null
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    app?: OAuthAppUpdateOneWithoutApiUsageNestedInput
    company?: CompanyUpdateOneRequiredWithoutApiUsageNestedInput
    user?: UserUpdateOneWithoutApiUsageNestedInput
  }

  export type ApiUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiUsageCreateManyInput = {
    id?: string
    appId?: string | null
    companyId: string
    userId?: string | null
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    stripePriceId?: string | null
    monthlyPrice?: Decimal | DecimalJsLike | number | string
    yearlyPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxCompanies?: number
    maxUsers?: number
    maxInvoicesPerMonth?: number
    maxWallets?: number
    maxAiMessagesPerMonth?: number
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    stripePriceId?: string | null
    monthlyPrice?: Decimal | DecimalJsLike | number | string
    yearlyPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxCompanies?: number
    maxUsers?: number
    maxInvoicesPerMonth?: number
    maxWallets?: number
    maxAiMessagesPerMonth?: number
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxCompanies?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxInvoicesPerMonth?: IntFieldUpdateOperationsInput | number
    maxWallets?: IntFieldUpdateOperationsInput | number
    maxAiMessagesPerMonth?: IntFieldUpdateOperationsInput | number
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    siiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiChatEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiOcrEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoEnabled?: BoolFieldUpdateOperationsInput | boolean
    multiUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxCompanies?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxInvoicesPerMonth?: IntFieldUpdateOperationsInput | number
    maxWallets?: IntFieldUpdateOperationsInput | number
    maxAiMessagesPerMonth?: IntFieldUpdateOperationsInput | number
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    siiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiChatEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiOcrEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoEnabled?: BoolFieldUpdateOperationsInput | boolean
    multiUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    stripePriceId?: string | null
    monthlyPrice?: Decimal | DecimalJsLike | number | string
    yearlyPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxCompanies?: number
    maxUsers?: number
    maxInvoicesPerMonth?: number
    maxWallets?: number
    maxAiMessagesPerMonth?: number
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxCompanies?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxInvoicesPerMonth?: IntFieldUpdateOperationsInput | number
    maxWallets?: IntFieldUpdateOperationsInput | number
    maxAiMessagesPerMonth?: IntFieldUpdateOperationsInput | number
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    siiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiChatEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiOcrEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoEnabled?: BoolFieldUpdateOperationsInput | boolean
    multiUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxCompanies?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxInvoicesPerMonth?: IntFieldUpdateOperationsInput | number
    maxWallets?: IntFieldUpdateOperationsInput | number
    maxAiMessagesPerMonth?: IntFieldUpdateOperationsInput | number
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    siiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiChatEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiOcrEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoEnabled?: BoolFieldUpdateOperationsInput | boolean
    multiUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    companyId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    companyId: string
    planId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    companyId: string
    planId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    description?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    description?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    subscriptionId: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    description?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingCreateInput = {
    status?: $Enums.UserOnboardingStatus
    currentStep?: number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastActivityAt?: Date | string
    user: UserCreateNestedOneWithoutOnboardingInput
  }

  export type UserOnboardingUncheckedCreateInput = {
    userId: string
    status?: $Enums.UserOnboardingStatus
    currentStep?: number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastActivityAt?: Date | string
  }

  export type UserOnboardingUpdateInput = {
    status?: EnumUserOnboardingStatusFieldUpdateOperationsInput | $Enums.UserOnboardingStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingNestedInput
  }

  export type UserOnboardingUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumUserOnboardingStatusFieldUpdateOperationsInput | $Enums.UserOnboardingStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingCreateManyInput = {
    userId: string
    status?: $Enums.UserOnboardingStatus
    currentStep?: number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastActivityAt?: Date | string
  }

  export type UserOnboardingUpdateManyMutationInput = {
    status?: EnumUserOnboardingStatusFieldUpdateOperationsInput | $Enums.UserOnboardingStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumUserOnboardingStatusFieldUpdateOperationsInput | $Enums.UserOnboardingStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookSubscriptionCreateInput = {
    id?: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutWebhookSubscriptionsInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutSubscriptionInput
  }

  export type WebhookSubscriptionUncheckedCreateInput = {
    id?: string
    companyId: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WebhookSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWebhookSubscriptionsNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutSubscriptionNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WebhookSubscriptionCreateManyInput = {
    id?: string
    companyId: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    payloadHash: string
    status?: $Enums.WebhookDeliveryStatus
    attemptCount?: number
    maxAttempts?: number
    responseStatus?: number | null
    responseBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    scheduledFor?: Date | string
    lastAttemptAt?: Date | string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: WebhookSubscriptionCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    payloadHash: string
    status?: $Enums.WebhookDeliveryStatus
    attemptCount?: number
    maxAttempts?: number
    responseStatus?: number | null
    responseBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    scheduledFor?: Date | string
    lastAttemptAt?: Date | string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    payloadHash?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookDeliveryStatusFieldUpdateOperationsInput | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    responseStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: WebhookSubscriptionUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    payloadHash?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookDeliveryStatusFieldUpdateOperationsInput | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    responseStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    subscriptionId: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    payloadHash: string
    status?: $Enums.WebhookDeliveryStatus
    attemptCount?: number
    maxAttempts?: number
    responseStatus?: number | null
    responseBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    scheduledFor?: Date | string
    lastAttemptAt?: Date | string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    payloadHash?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookDeliveryStatusFieldUpdateOperationsInput | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    responseStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    payloadHash?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookDeliveryStatusFieldUpdateOperationsInput | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    responseStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    companyId: string
    event: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    emittedAt?: Date | string
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    companyId: string
    event: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    emittedAt?: Date | string
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    emittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    emittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    companyId: string
    event: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    emittedAt?: Date | string
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    emittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    emittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompanyUserListRelationFilter = {
    every?: CompanyUserWhereInput
    some?: CompanyUserWhereInput
    none?: CompanyUserWhereInput
  }

  export type AiConversationListRelationFilter = {
    every?: AiConversationWhereInput
    some?: AiConversationWhereInput
    none?: AiConversationWhereInput
  }

  export type CompanyInvitationListRelationFilter = {
    every?: CompanyInvitationWhereInput
    some?: CompanyInvitationWhereInput
    none?: CompanyInvitationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type UserOnboardingNullableRelationFilter = {
    is?: UserOnboardingWhereInput | null
    isNot?: UserOnboardingWhereInput | null
  }

  export type AnalyticsEventListRelationFilter = {
    every?: AnalyticsEventWhereInput
    some?: AnalyticsEventWhereInput
    none?: AnalyticsEventWhereInput
  }

  export type OAuthAppListRelationFilter = {
    every?: OAuthAppWhereInput
    some?: OAuthAppWhereInput
    none?: OAuthAppWhereInput
  }

  export type OAuthTokenListRelationFilter = {
    every?: OAuthTokenWhereInput
    some?: OAuthTokenWhereInput
    none?: OAuthTokenWhereInput
  }

  export type ApiUsageListRelationFilter = {
    every?: ApiUsageWhereInput
    some?: ApiUsageWhereInput
    none?: ApiUsageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CompanyUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthAppOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserSsoProviderSsoIdCompoundUniqueInput = {
    ssoProvider: string
    ssoId: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    ssoMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    ssoProvider?: SortOrder
    ssoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTaxIdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeFilter<$PrismaModel> | $Enums.TaxIdType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCryptoClassificationFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoClassification | EnumCryptoClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoClassificationFilter<$PrismaModel> | $Enums.CryptoClassification
  }

  export type FiscalYearListRelationFilter = {
    every?: FiscalYearWhereInput
    some?: FiscalYearWhereInput
    none?: FiscalYearWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceSeriesListRelationFilter = {
    every?: InvoiceSeriesWhereInput
    some?: InvoiceSeriesWhereInput
    none?: InvoiceSeriesWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type WalletListRelationFilter = {
    every?: WalletWhereInput
    some?: WalletWhereInput
    none?: WalletWhereInput
  }

  export type CryptoAssetListRelationFilter = {
    every?: CryptoAssetWhereInput
    some?: CryptoAssetWhereInput
    none?: CryptoAssetWhereInput
  }

  export type CryptoLotListRelationFilter = {
    every?: CryptoLotWhereInput
    some?: CryptoLotWhereInput
    none?: CryptoLotWhereInput
  }

  export type ExchangeAccountListRelationFilter = {
    every?: ExchangeAccountWhereInput
    some?: ExchangeAccountWhereInput
    none?: ExchangeAccountWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type WebhookSubscriptionListRelationFilter = {
    every?: WebhookSubscriptionWhereInput
    some?: WebhookSubscriptionWhereInput
    none?: WebhookSubscriptionWhereInput
  }

  export type FiscalYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceSeriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoLotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExchangeAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyOrderByRelevanceInput = {
    fields: CompanyOrderByRelevanceFieldEnum | CompanyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    region?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    currency?: SortOrder
    fiscalYearStart?: SortOrder
    logo?: SortOrder
    verifactuEnabled?: SortOrder
    verifactuId?: SortOrder
    verifactuLastHash?: SortOrder
    defaultCryptoClassification?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    fiscalYearStart?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    region?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    currency?: SortOrder
    fiscalYearStart?: SortOrder
    logo?: SortOrder
    verifactuEnabled?: SortOrder
    verifactuId?: SortOrder
    verifactuLastHash?: SortOrder
    defaultCryptoClassification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    region?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    currency?: SortOrder
    fiscalYearStart?: SortOrder
    logo?: SortOrder
    verifactuEnabled?: SortOrder
    verifactuId?: SortOrder
    verifactuLastHash?: SortOrder
    defaultCryptoClassification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    fiscalYearStart?: SortOrder
  }

  export type EnumTaxIdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxIdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxIdTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxIdTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCryptoClassificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoClassification | EnumCryptoClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoClassificationWithAggregatesFilter<$PrismaModel> | $Enums.CryptoClassification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCryptoClassificationFilter<$PrismaModel>
    _max?: NestedEnumCryptoClassificationFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyUserOrderByRelevanceInput = {
    fields: CompanyUserOrderByRelevanceFieldEnum | CompanyUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyUserUserIdCompanyIdCompoundUniqueInput = {
    userId: string
    companyId: string
  }

  export type CompanyUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type EnumTaxIdTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaxIdTypeNullableFilter<$PrismaModel> | $Enums.TaxIdType | null
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    taxIdType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type EnumTaxIdTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaxIdTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaxIdType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaxIdTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTaxIdTypeNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type FiscalYearOrderByRelevanceInput = {
    fields: FiscalYearOrderByRelevanceFieldEnum | FiscalYearOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FiscalYearCompanyIdNameCompoundUniqueInput = {
    companyId: string
    name: string
  }

  export type FiscalYearCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type CryptoAssetNullableRelationFilter = {
    is?: CryptoAssetWhereInput | null
    isNot?: CryptoAssetWhereInput | null
  }

  export type JournalLineListRelationFilter = {
    every?: JournalLineWhereInput
    some?: JournalLineWhereInput
    none?: JournalLineWhereInput
  }

  export type JournalLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentCode?: SortOrder
    description?: SortOrder
    isCrypto?: SortOrder
    cryptoAssetId?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    allowDirectPosting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentCode?: SortOrder
    description?: SortOrder
    isCrypto?: SortOrder
    cryptoAssetId?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    allowDirectPosting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentCode?: SortOrder
    description?: SortOrder
    isCrypto?: SortOrder
    cryptoAssetId?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    allowDirectPosting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumReferenceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReferenceTypeNullableFilter<$PrismaModel> | $Enums.ReferenceType | null
  }

  export type EnumSourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTypeNullableFilter<$PrismaModel> | $Enums.SourceType | null
  }

  export type EnumJournalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusFilter<$PrismaModel> | $Enums.JournalStatus
  }

  export type FiscalYearRelationFilter = {
    is?: FiscalYearWhereInput
    isNot?: FiscalYearWhereInput
  }

  export type JournalEntryOrderByRelevanceInput = {
    fields: JournalEntryOrderByRelevanceFieldEnum | JournalEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JournalEntryCompanyIdFiscalYearIdNumberCompoundUniqueInput = {
    companyId: string
    fiscalYearId: string
    number: number
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    fiscalYearId?: SortOrder
    number?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    postedBy?: SortOrder
    isReversal?: SortOrder
    reversalOf?: SortOrder
    reversedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    fiscalYearId?: SortOrder
    number?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    postedBy?: SortOrder
    isReversal?: SortOrder
    reversalOf?: SortOrder
    reversedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    fiscalYearId?: SortOrder
    number?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    status?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    postedBy?: SortOrder
    isReversal?: SortOrder
    reversalOf?: SortOrder
    reversedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntrySumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type EnumReferenceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReferenceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReferenceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReferenceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReferenceTypeNullableFilter<$PrismaModel>
  }

  export type EnumSourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeNullableFilter<$PrismaModel>
  }

  export type EnumJournalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusWithAggregatesFilter<$PrismaModel> | $Enums.JournalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalStatusFilter<$PrismaModel>
    _max?: NestedEnumJournalStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type JournalEntryRelationFilter = {
    is?: JournalEntryWhereInput
    isNot?: JournalEntryWhereInput
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type JournalLineOrderByRelevanceInput = {
    fields: JournalLineOrderByRelevanceFieldEnum | JournalLineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JournalLineJournalEntryIdLineNumberCompoundUniqueInput = {
    journalEntryId: string
    lineNumber: number
  }

  export type JournalLineCountOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    cryptoAmount?: SortOrder
    cryptoAsset?: SortOrder
    cryptoPrice?: SortOrder
    costCenter?: SortOrder
    project?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalLineAvgOrderByAggregateInput = {
    lineNumber?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    cryptoAmount?: SortOrder
    cryptoPrice?: SortOrder
  }

  export type JournalLineMaxOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    cryptoAmount?: SortOrder
    cryptoAsset?: SortOrder
    cryptoPrice?: SortOrder
    costCenter?: SortOrder
    project?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalLineMinOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    cryptoAmount?: SortOrder
    cryptoAsset?: SortOrder
    cryptoPrice?: SortOrder
    costCenter?: SortOrder
    project?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalLineSumOrderByAggregateInput = {
    lineNumber?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    cryptoAmount?: SortOrder
    cryptoPrice?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type InvoiceSeriesOrderByRelevanceInput = {
    fields: InvoiceSeriesOrderByRelevanceFieldEnum | InvoiceSeriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceSeriesCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type InvoiceSeriesCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    nextNumber?: SortOrder
    digitCount?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSeriesAvgOrderByAggregateInput = {
    nextNumber?: SortOrder
    digitCount?: SortOrder
  }

  export type InvoiceSeriesMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    nextNumber?: SortOrder
    digitCount?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSeriesMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    suffix?: SortOrder
    nextNumber?: SortOrder
    digitCount?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSeriesSumOrderByAggregateInput = {
    nextNumber?: SortOrder
    digitCount?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type EnumInvoiceDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceDirection | EnumInvoiceDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceDirectionFilter<$PrismaModel> | $Enums.InvoiceDirection
  }

  export type EnumVerifactuStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuStatus | EnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerifactuStatusNullableFilter<$PrismaModel> | $Enums.VerifactuStatus | null
  }

  export type InvoiceSeriesRelationFilter = {
    is?: InvoiceSeriesWhereInput
    isNot?: InvoiceSeriesWhereInput
  }

  export type ContactNullableRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type InvoiceLineListRelationFilter = {
    every?: InvoiceLineWhereInput
    some?: InvoiceLineWhereInput
    none?: InvoiceLineWhereInput
  }

  export type InvoiceTaxListRelationFilter = {
    every?: InvoiceTaxWhereInput
    some?: InvoiceTaxWhereInput
    none?: InvoiceTaxWhereInput
  }

  export type VerifactuRecordListRelationFilter = {
    every?: VerifactuRecordWhereInput
    some?: VerifactuRecordWhereInput
    none?: VerifactuRecordWhereInput
  }

  export type InvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceTaxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerifactuRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelevanceInput = {
    fields: InvoiceOrderByRelevanceFieldEnum | InvoiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceCompanyIdSeriesIdNumberCompoundUniqueInput = {
    companyId: string
    seriesId: string
    number: number
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    seriesId?: SortOrder
    contactId?: SortOrder
    number?: SortOrder
    fullNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    operationDate?: SortOrder
    paidAt?: SortOrder
    counterpartyName?: SortOrder
    counterpartyTaxId?: SortOrder
    counterpartyAddress?: SortOrder
    counterpartyCity?: SortOrder
    counterpartyCountry?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    taxableBase?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    cryptoPayment?: SortOrder
    cryptoAsset?: SortOrder
    cryptoAmount?: SortOrder
    cryptoRate?: SortOrder
    cryptoTxHash?: SortOrder
    verifactuHash?: SortOrder
    verifactuPrevHash?: SortOrder
    verifactuQrData?: SortOrder
    verifactuSentAt?: SortOrder
    verifactuResponse?: SortOrder
    verifactuStatus?: SortOrder
    notes?: SortOrder
    internalNotes?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    journalEntryId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    number?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    taxableBase?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    exchangeRate?: SortOrder
    cryptoAmount?: SortOrder
    cryptoRate?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    seriesId?: SortOrder
    contactId?: SortOrder
    number?: SortOrder
    fullNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    operationDate?: SortOrder
    paidAt?: SortOrder
    counterpartyName?: SortOrder
    counterpartyTaxId?: SortOrder
    counterpartyAddress?: SortOrder
    counterpartyCity?: SortOrder
    counterpartyCountry?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    taxableBase?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    cryptoPayment?: SortOrder
    cryptoAsset?: SortOrder
    cryptoAmount?: SortOrder
    cryptoRate?: SortOrder
    cryptoTxHash?: SortOrder
    verifactuHash?: SortOrder
    verifactuPrevHash?: SortOrder
    verifactuQrData?: SortOrder
    verifactuSentAt?: SortOrder
    verifactuStatus?: SortOrder
    notes?: SortOrder
    internalNotes?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    journalEntryId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    seriesId?: SortOrder
    contactId?: SortOrder
    number?: SortOrder
    fullNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    operationDate?: SortOrder
    paidAt?: SortOrder
    counterpartyName?: SortOrder
    counterpartyTaxId?: SortOrder
    counterpartyAddress?: SortOrder
    counterpartyCity?: SortOrder
    counterpartyCountry?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    taxableBase?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    cryptoPayment?: SortOrder
    cryptoAsset?: SortOrder
    cryptoAmount?: SortOrder
    cryptoRate?: SortOrder
    cryptoTxHash?: SortOrder
    verifactuHash?: SortOrder
    verifactuPrevHash?: SortOrder
    verifactuQrData?: SortOrder
    verifactuSentAt?: SortOrder
    verifactuStatus?: SortOrder
    notes?: SortOrder
    internalNotes?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    journalEntryId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    number?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    taxableBase?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    exchangeRate?: SortOrder
    cryptoAmount?: SortOrder
    cryptoRate?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceDirection | EnumInvoiceDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceDirectionWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceDirectionFilter<$PrismaModel>
    _max?: NestedEnumInvoiceDirectionFilter<$PrismaModel>
  }

  export type EnumVerifactuStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuStatus | EnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerifactuStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerifactuStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerifactuStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumVerifactuStatusNullableFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceLineOrderByRelevanceInput = {
    fields: InvoiceLineOrderByRelevanceFieldEnum | InvoiceLineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceLineInvoiceIdLineNumberCompoundUniqueInput = {
    invoiceId: string
    lineNumber: number
  }

  export type InvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    accountCode?: SortOrder
  }

  export type InvoiceLineAvgOrderByAggregateInput = {
    lineNumber?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    accountCode?: SortOrder
  }

  export type InvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    lineNumber?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    accountCode?: SortOrder
  }

  export type InvoiceLineSumOrderByAggregateInput = {
    lineNumber?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumTaxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeFilter<$PrismaModel> | $Enums.TaxType
  }

  export type InvoiceTaxOrderByRelevanceInput = {
    fields: InvoiceTaxOrderByRelevanceFieldEnum | InvoiceTaxOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceTaxInvoiceIdTaxRateTaxTypeCompoundUniqueInput = {
    invoiceId: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxType: $Enums.TaxType
  }

  export type InvoiceTaxCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    taxRate?: SortOrder
    taxableBase?: SortOrder
    taxAmount?: SortOrder
    taxType?: SortOrder
  }

  export type InvoiceTaxAvgOrderByAggregateInput = {
    taxRate?: SortOrder
    taxableBase?: SortOrder
    taxAmount?: SortOrder
  }

  export type InvoiceTaxMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    taxRate?: SortOrder
    taxableBase?: SortOrder
    taxAmount?: SortOrder
    taxType?: SortOrder
  }

  export type InvoiceTaxMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    taxRate?: SortOrder
    taxableBase?: SortOrder
    taxAmount?: SortOrder
    taxType?: SortOrder
  }

  export type InvoiceTaxSumOrderByAggregateInput = {
    taxRate?: SortOrder
    taxableBase?: SortOrder
    taxAmount?: SortOrder
  }

  export type EnumTaxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxTypeFilter<$PrismaModel>
  }

  export type CryptoAssetOrderByRelevanceInput = {
    fields: CryptoAssetOrderByRelevanceFieldEnum | CryptoAssetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CryptoAssetCompanyIdSymbolCompoundUniqueInput = {
    companyId: string
    symbol: string
  }

  export type CryptoAssetCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    decimals?: SortOrder
    contractAddress?: SortOrder
    classification?: SortOrder
    coingeckoId?: SortOrder
    lastPrice?: SortOrder
    lastPriceAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoAssetAvgOrderByAggregateInput = {
    decimals?: SortOrder
    lastPrice?: SortOrder
  }

  export type CryptoAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    decimals?: SortOrder
    contractAddress?: SortOrder
    classification?: SortOrder
    coingeckoId?: SortOrder
    lastPrice?: SortOrder
    lastPriceAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoAssetMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    decimals?: SortOrder
    contractAddress?: SortOrder
    classification?: SortOrder
    coingeckoId?: SortOrder
    lastPrice?: SortOrder
    lastPriceAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoAssetSumOrderByAggregateInput = {
    decimals?: SortOrder
    lastPrice?: SortOrder
  }

  export type EnumWalletTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletType | EnumWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTypeFilter<$PrismaModel> | $Enums.WalletType
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type CryptoTransactionListRelationFilter = {
    every?: CryptoTransactionWhereInput
    some?: CryptoTransactionWhereInput
    none?: CryptoTransactionWhereInput
  }

  export type CryptoTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletOrderByRelevanceInput = {
    fields: WalletOrderByRelevanceFieldEnum | WalletOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WalletCompanyIdChainAddressCompoundUniqueInput = {
    companyId: string
    chain: string
    address: string
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    label?: SortOrder
    type?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncBlock?: SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrder
    accountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    lastSyncBlock?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    label?: SortOrder
    type?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncBlock?: SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrder
    accountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    label?: SortOrder
    type?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncBlock?: SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrder
    accountCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    lastSyncBlock?: SortOrder
  }

  export type EnumWalletTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletType | EnumWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTypeWithAggregatesFilter<$PrismaModel> | $Enums.WalletType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletTypeFilter<$PrismaModel>
    _max?: NestedEnumWalletTypeFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type ExchangeAccountOrderByRelevanceInput = {
    fields: ExchangeAccountOrderByRelevanceFieldEnum | ExchangeAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExchangeAccountCompanyIdExchangeApiKeyCompoundUniqueInput = {
    companyId: string
    exchange: string
    apiKey: string
  }

  export type ExchangeAccountCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    exchange?: SortOrder
    label?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    isReadOnly?: SortOrder
    lastSyncAt?: SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangeAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    exchange?: SortOrder
    label?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    isReadOnly?: SortOrder
    lastSyncAt?: SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangeAccountMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    exchange?: SortOrder
    label?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    isReadOnly?: SortOrder
    lastSyncAt?: SortOrder
    syncStatus?: SortOrder
    syncError?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumCryptoTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoTxTypeFilter<$PrismaModel> | $Enums.CryptoTxType
  }

  export type EnumCryptoTxTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCryptoTxTypeNullableFilter<$PrismaModel> | $Enums.CryptoTxType | null
  }

  export type EnumTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusFilter<$PrismaModel> | $Enums.TxStatus
  }

  export type WalletRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type CryptoTransactionOrderByRelevanceInput = {
    fields: CryptoTransactionOrderByRelevanceFieldEnum | CryptoTransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CryptoTransactionWalletIdTxHashCompoundUniqueInput = {
    walletId: string
    txHash: string
  }

  export type CryptoTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    blockTimestamp?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    assetIn?: SortOrder
    amountIn?: SortOrder
    assetOut?: SortOrder
    amountOut?: SortOrder
    feeAsset?: SortOrder
    feeAmount?: SortOrder
    priceInEur?: SortOrder
    priceOutEur?: SortOrder
    feeEur?: SortOrder
    costBasis?: SortOrder
    realizedGain?: SortOrder
    aiCategorized?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    manualType?: SortOrder
    manualNotes?: SortOrder
    journalEntryId?: SortOrder
    status?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoTransactionAvgOrderByAggregateInput = {
    blockNumber?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    feeAmount?: SortOrder
    priceInEur?: SortOrder
    priceOutEur?: SortOrder
    feeEur?: SortOrder
    costBasis?: SortOrder
    realizedGain?: SortOrder
    aiConfidence?: SortOrder
  }

  export type CryptoTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    blockTimestamp?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    assetIn?: SortOrder
    amountIn?: SortOrder
    assetOut?: SortOrder
    amountOut?: SortOrder
    feeAsset?: SortOrder
    feeAmount?: SortOrder
    priceInEur?: SortOrder
    priceOutEur?: SortOrder
    feeEur?: SortOrder
    costBasis?: SortOrder
    realizedGain?: SortOrder
    aiCategorized?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    manualType?: SortOrder
    manualNotes?: SortOrder
    journalEntryId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    blockTimestamp?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    assetIn?: SortOrder
    amountIn?: SortOrder
    assetOut?: SortOrder
    amountOut?: SortOrder
    feeAsset?: SortOrder
    feeAmount?: SortOrder
    priceInEur?: SortOrder
    priceOutEur?: SortOrder
    feeEur?: SortOrder
    costBasis?: SortOrder
    realizedGain?: SortOrder
    aiCategorized?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    manualType?: SortOrder
    manualNotes?: SortOrder
    journalEntryId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoTransactionSumOrderByAggregateInput = {
    blockNumber?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    feeAmount?: SortOrder
    priceInEur?: SortOrder
    priceOutEur?: SortOrder
    feeEur?: SortOrder
    costBasis?: SortOrder
    realizedGain?: SortOrder
    aiConfidence?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumCryptoTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.CryptoTxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCryptoTxTypeFilter<$PrismaModel>
    _max?: NestedEnumCryptoTxTypeFilter<$PrismaModel>
  }

  export type EnumCryptoTxTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCryptoTxTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CryptoTxType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCryptoTxTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCryptoTxTypeNullableFilter<$PrismaModel>
  }

  export type EnumTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.TxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxStatusFilter<$PrismaModel>
    _max?: NestedEnumTxStatusFilter<$PrismaModel>
  }

  export type CryptoAssetRelationFilter = {
    is?: CryptoAssetWhereInput
    isNot?: CryptoAssetWhereInput
  }

  export type CryptoLotOrderByRelevanceInput = {
    fields: CryptoLotOrderByRelevanceFieldEnum | CryptoLotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CryptoLotCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    cryptoAssetId?: SortOrder
    acquiredAt?: SortOrder
    acquiredAmount?: SortOrder
    costBasisEur?: SortOrder
    costPerUnit?: SortOrder
    remainingAmount?: SortOrder
    sourceTxId?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoLotAvgOrderByAggregateInput = {
    acquiredAmount?: SortOrder
    costBasisEur?: SortOrder
    costPerUnit?: SortOrder
    remainingAmount?: SortOrder
  }

  export type CryptoLotMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    cryptoAssetId?: SortOrder
    acquiredAt?: SortOrder
    acquiredAmount?: SortOrder
    costBasisEur?: SortOrder
    costPerUnit?: SortOrder
    remainingAmount?: SortOrder
    sourceTxId?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoLotMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    cryptoAssetId?: SortOrder
    acquiredAt?: SortOrder
    acquiredAmount?: SortOrder
    costBasisEur?: SortOrder
    costPerUnit?: SortOrder
    remainingAmount?: SortOrder
    sourceTxId?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoLotSumOrderByAggregateInput = {
    acquiredAmount?: SortOrder
    costBasisEur?: SortOrder
    costPerUnit?: SortOrder
    remainingAmount?: SortOrder
  }

  export type PriceHistoryOrderByRelevanceInput = {
    fields: PriceHistoryOrderByRelevanceFieldEnum | PriceHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    priceEur?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type PriceHistoryAvgOrderByAggregateInput = {
    priceEur?: SortOrder
  }

  export type PriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    priceEur?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type PriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    priceEur?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type PriceHistorySumOrderByAggregateInput = {
    priceEur?: SortOrder
  }

  export type EnumVerifactuRecordStateFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuRecordState | EnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    in?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    not?: NestedEnumVerifactuRecordStateFilter<$PrismaModel> | $Enums.VerifactuRecordState
  }

  export type VerifactuRecordOrderByRelevanceInput = {
    fields: VerifactuRecordOrderByRelevanceFieldEnum | VerifactuRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerifactuRecordCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    hash?: SortOrder
    prevHash?: SortOrder
    xmlContent?: SortOrder
    state?: SortOrder
    csv?: SortOrder
    sentAt?: SortOrder
    retryCount?: SortOrder
    aeatResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerifactuRecordAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type VerifactuRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    hash?: SortOrder
    prevHash?: SortOrder
    xmlContent?: SortOrder
    state?: SortOrder
    csv?: SortOrder
    sentAt?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerifactuRecordMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    hash?: SortOrder
    prevHash?: SortOrder
    xmlContent?: SortOrder
    state?: SortOrder
    csv?: SortOrder
    sentAt?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerifactuRecordSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumVerifactuRecordStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuRecordState | EnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    in?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    not?: NestedEnumVerifactuRecordStateWithAggregatesFilter<$PrismaModel> | $Enums.VerifactuRecordState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerifactuRecordStateFilter<$PrismaModel>
    _max?: NestedEnumVerifactuRecordStateFilter<$PrismaModel>
  }

  export type AiMessageListRelationFilter = {
    every?: AiMessageWhereInput
    some?: AiMessageWhereInput
    none?: AiMessageWhereInput
  }

  export type AiMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiConversationOrderByRelevanceInput = {
    fields: AiConversationOrderByRelevanceFieldEnum | AiConversationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiConversationCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiConversationMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAiRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AiRole | EnumAiRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiRoleFilter<$PrismaModel> | $Enums.AiRole
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AiConversationRelationFilter = {
    is?: AiConversationWhereInput
    isNot?: AiConversationWhereInput
  }

  export type AiMessageOrderByRelevanceInput = {
    fields: AiMessageOrderByRelevanceFieldEnum | AiMessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    latencyMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageAvgOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    latencyMs?: SortOrder
  }

  export type AiMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    latencyMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    latencyMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AiMessageSumOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    latencyMs?: SortOrder
  }

  export type EnumAiRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiRole | EnumAiRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiRoleWithAggregatesFilter<$PrismaModel> | $Enums.AiRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiRoleFilter<$PrismaModel>
    _max?: NestedEnumAiRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sourceUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sourceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sourceUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CompanyInvitationOrderByRelevanceInput = {
    fields: CompanyInvitationOrderByRelevanceFieldEnum | CompanyInvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyInvitationEmailCompanyIdCompoundUniqueInput = {
    email: string
    companyId: string
  }

  export type CompanyInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    inviterId?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    acceptedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    inviterId?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    acceptedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    inviterId?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    acceptedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type AnalyticsEventOrderByRelevanceInput = {
    fields: AnalyticsEventOrderByRelevanceFieldEnum | AnalyticsEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    category?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type AnalyticsEventAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    category?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    timestamp?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    category?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    timestamp?: SortOrder
  }

  export type AnalyticsEventSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type OAuthAppOrderByRelevanceInput = {
    fields: OAuthAppOrderByRelevanceFieldEnum | OAuthAppOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OAuthAppCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    scopes?: SortOrder
    rateLimit?: SortOrder
    dailyQuota?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthAppAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
    dailyQuota?: SortOrder
  }

  export type OAuthAppMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    rateLimit?: SortOrder
    dailyQuota?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthAppMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    website?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    rateLimit?: SortOrder
    dailyQuota?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthAppSumOrderByAggregateInput = {
    rateLimit?: SortOrder
    dailyQuota?: SortOrder
  }

  export type OAuthAppRelationFilter = {
    is?: OAuthAppWhereInput
    isNot?: OAuthAppWhereInput
  }

  export type OAuthTokenOrderByRelevanceInput = {
    fields: OAuthTokenOrderByRelevanceFieldEnum | OAuthTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OAuthTokenCountOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    refreshExpiresAt?: SortOrder
    authorizationCode?: SortOrder
    codeExpiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type OAuthTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    refreshExpiresAt?: SortOrder
    authorizationCode?: SortOrder
    codeExpiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type OAuthTokenMinOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    refreshExpiresAt?: SortOrder
    authorizationCode?: SortOrder
    codeExpiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type OAuthAppNullableRelationFilter = {
    is?: OAuthAppWhereInput | null
    isNot?: OAuthAppWhereInput | null
  }

  export type ApiUsageOrderByRelevanceInput = {
    fields: ApiUsageOrderByRelevanceFieldEnum | ApiUsageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ApiUsageCountOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestCount?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type ApiUsageAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestCount?: SortOrder
  }

  export type ApiUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestCount?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type ApiUsageMinOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestCount?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type ApiUsageSumOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestCount?: SortOrder
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPlanOrderByRelevanceInput = {
    fields: SubscriptionPlanOrderByRelevanceFieldEnum | SubscriptionPlanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stripePriceId?: SortOrder
    monthlyPrice?: SortOrder
    yearlyPrice?: SortOrder
    currency?: SortOrder
    maxCompanies?: SortOrder
    maxUsers?: SortOrder
    maxInvoicesPerMonth?: SortOrder
    maxWallets?: SortOrder
    maxAiMessagesPerMonth?: SortOrder
    verifactuEnabled?: SortOrder
    siiEnabled?: SortOrder
    aiChatEnabled?: SortOrder
    aiOcrEnabled?: SortOrder
    cryptoEnabled?: SortOrder
    multiUserEnabled?: SortOrder
    prioritySupport?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    yearlyPrice?: SortOrder
    maxCompanies?: SortOrder
    maxUsers?: SortOrder
    maxInvoicesPerMonth?: SortOrder
    maxWallets?: SortOrder
    maxAiMessagesPerMonth?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stripePriceId?: SortOrder
    monthlyPrice?: SortOrder
    yearlyPrice?: SortOrder
    currency?: SortOrder
    maxCompanies?: SortOrder
    maxUsers?: SortOrder
    maxInvoicesPerMonth?: SortOrder
    maxWallets?: SortOrder
    maxAiMessagesPerMonth?: SortOrder
    verifactuEnabled?: SortOrder
    siiEnabled?: SortOrder
    aiChatEnabled?: SortOrder
    aiOcrEnabled?: SortOrder
    cryptoEnabled?: SortOrder
    multiUserEnabled?: SortOrder
    prioritySupport?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stripePriceId?: SortOrder
    monthlyPrice?: SortOrder
    yearlyPrice?: SortOrder
    currency?: SortOrder
    maxCompanies?: SortOrder
    maxUsers?: SortOrder
    maxInvoicesPerMonth?: SortOrder
    maxWallets?: SortOrder
    maxAiMessagesPerMonth?: SortOrder
    verifactuEnabled?: SortOrder
    siiEnabled?: SortOrder
    aiChatEnabled?: SortOrder
    aiOcrEnabled?: SortOrder
    cryptoEnabled?: SortOrder
    multiUserEnabled?: SortOrder
    prioritySupport?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    yearlyPrice?: SortOrder
    maxCompanies?: SortOrder
    maxUsers?: SortOrder
    maxInvoicesPerMonth?: SortOrder
    maxWallets?: SortOrder
    maxAiMessagesPerMonth?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionPlanRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelevanceInput = {
    fields: SubscriptionOrderByRelevanceFieldEnum | SubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialEndsAt?: SortOrder
    invoicesThisMonth?: SortOrder
    aiMessagesThisMonth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    invoicesThisMonth?: SortOrder
    aiMessagesThisMonth?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialEndsAt?: SortOrder
    invoicesThisMonth?: SortOrder
    aiMessagesThisMonth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    trialEndsAt?: SortOrder
    invoicesThisMonth?: SortOrder
    aiMessagesThisMonth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    invoicesThisMonth?: SortOrder
    aiMessagesThisMonth?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type SubscriptionRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    failureReason?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    failureReason?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    failureReason?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumUserOnboardingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserOnboardingStatus | EnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserOnboardingStatusFilter<$PrismaModel> | $Enums.UserOnboardingStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserOnboardingOrderByRelevanceInput = {
    fields: UserOnboardingOrderByRelevanceFieldEnum | UserOnboardingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserOnboardingCountOrderByAggregateInput = {
    userId?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    completedSteps?: SortOrder
    skippedSteps?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserOnboardingAvgOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type UserOnboardingMaxOrderByAggregateInput = {
    userId?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserOnboardingMinOrderByAggregateInput = {
    userId?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserOnboardingSumOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type EnumUserOnboardingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserOnboardingStatus | EnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserOnboardingStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserOnboardingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserOnboardingStatusFilter<$PrismaModel>
    _max?: NestedEnumUserOnboardingStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookSubscriptionOrderByRelevanceInput = {
    fields: WebhookSubscriptionOrderByRelevanceFieldEnum | WebhookSubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebhookSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    events?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSubscriptionAvgOrderByAggregateInput = {
    retryCount?: SortOrder
    timeout?: SortOrder
  }

  export type WebhookSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSubscriptionSumOrderByAggregateInput = {
    retryCount?: SortOrder
    timeout?: SortOrder
  }

  export type EnumWebhookDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookDeliveryStatus | EnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookDeliveryStatusFilter<$PrismaModel> | $Enums.WebhookDeliveryStatus
  }

  export type WebhookSubscriptionRelationFilter = {
    is?: WebhookSubscriptionWhereInput
    isNot?: WebhookSubscriptionWhereInput
  }

  export type WebhookDeliveryOrderByRelevanceInput = {
    fields: WebhookDeliveryOrderByRelevanceFieldEnum | WebhookDeliveryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    payloadHash?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    responseStatus?: SortOrder
    responseBody?: SortOrder
    responseHeaders?: SortOrder
    errorMessage?: SortOrder
    scheduledFor?: SortOrder
    lastAttemptAt?: SortOrder
    nextAttemptAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    responseStatus?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    event?: SortOrder
    payloadHash?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    responseStatus?: SortOrder
    responseBody?: SortOrder
    errorMessage?: SortOrder
    scheduledFor?: SortOrder
    lastAttemptAt?: SortOrder
    nextAttemptAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    event?: SortOrder
    payloadHash?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    responseStatus?: SortOrder
    responseBody?: SortOrder
    errorMessage?: SortOrder
    scheduledFor?: SortOrder
    lastAttemptAt?: SortOrder
    nextAttemptAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    responseStatus?: SortOrder
  }

  export type EnumWebhookDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookDeliveryStatus | EnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.WebhookDeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumWebhookDeliveryStatusFilter<$PrismaModel>
  }

  export type WebhookEventOrderByRelevanceInput = {
    fields: WebhookEventOrderByRelevanceFieldEnum | WebhookEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    event?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    emittedAt?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    event?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    emittedAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    event?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    emittedAt?: SortOrder
  }

  export type CompanyUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type AiConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<AiConversationCreateWithoutUserInput, AiConversationUncheckedCreateWithoutUserInput> | AiConversationCreateWithoutUserInput[] | AiConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutUserInput | AiConversationCreateOrConnectWithoutUserInput[]
    createMany?: AiConversationCreateManyUserInputEnvelope
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
  }

  export type CompanyInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<CompanyInvitationCreateWithoutInviterInput, CompanyInvitationUncheckedCreateWithoutInviterInput> | CompanyInvitationCreateWithoutInviterInput[] | CompanyInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutInviterInput | CompanyInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: CompanyInvitationCreateManyInviterInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type CompanyInvitationCreateNestedManyWithoutAcceptedUserInput = {
    create?: XOR<CompanyInvitationCreateWithoutAcceptedUserInput, CompanyInvitationUncheckedCreateWithoutAcceptedUserInput> | CompanyInvitationCreateWithoutAcceptedUserInput[] | CompanyInvitationUncheckedCreateWithoutAcceptedUserInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutAcceptedUserInput | CompanyInvitationCreateOrConnectWithoutAcceptedUserInput[]
    createMany?: CompanyInvitationCreateManyAcceptedUserInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserOnboardingCreateNestedOneWithoutUserInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    connect?: UserOnboardingWhereUniqueInput
  }

  export type AnalyticsEventCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type OAuthAppCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OAuthAppCreateWithoutCreatedByInput, OAuthAppUncheckedCreateWithoutCreatedByInput> | OAuthAppCreateWithoutCreatedByInput[] | OAuthAppUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCreatedByInput | OAuthAppCreateOrConnectWithoutCreatedByInput[]
    createMany?: OAuthAppCreateManyCreatedByInputEnvelope
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
  }

  export type OAuthTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ApiUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput> | ApiUsageCreateWithoutUserInput[] | ApiUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutUserInput | ApiUsageCreateOrConnectWithoutUserInput[]
    createMany?: ApiUsageCreateManyUserInputEnvelope
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type AiConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AiConversationCreateWithoutUserInput, AiConversationUncheckedCreateWithoutUserInput> | AiConversationCreateWithoutUserInput[] | AiConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutUserInput | AiConversationCreateOrConnectWithoutUserInput[]
    createMany?: AiConversationCreateManyUserInputEnvelope
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
  }

  export type CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<CompanyInvitationCreateWithoutInviterInput, CompanyInvitationUncheckedCreateWithoutInviterInput> | CompanyInvitationCreateWithoutInviterInput[] | CompanyInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutInviterInput | CompanyInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: CompanyInvitationCreateManyInviterInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput = {
    create?: XOR<CompanyInvitationCreateWithoutAcceptedUserInput, CompanyInvitationUncheckedCreateWithoutAcceptedUserInput> | CompanyInvitationCreateWithoutAcceptedUserInput[] | CompanyInvitationUncheckedCreateWithoutAcceptedUserInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutAcceptedUserInput | CompanyInvitationCreateOrConnectWithoutAcceptedUserInput[]
    createMany?: CompanyInvitationCreateManyAcceptedUserInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserOnboardingUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    connect?: UserOnboardingWhereUniqueInput
  }

  export type AnalyticsEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OAuthAppCreateWithoutCreatedByInput, OAuthAppUncheckedCreateWithoutCreatedByInput> | OAuthAppCreateWithoutCreatedByInput[] | OAuthAppUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCreatedByInput | OAuthAppCreateOrConnectWithoutCreatedByInput[]
    createMany?: OAuthAppCreateManyCreatedByInputEnvelope
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
  }

  export type OAuthTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ApiUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput> | ApiUsageCreateWithoutUserInput[] | ApiUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutUserInput | ApiUsageCreateOrConnectWithoutUserInput[]
    createMany?: ApiUsageCreateManyUserInputEnvelope
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompanyUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type AiConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiConversationCreateWithoutUserInput, AiConversationUncheckedCreateWithoutUserInput> | AiConversationCreateWithoutUserInput[] | AiConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutUserInput | AiConversationCreateOrConnectWithoutUserInput[]
    upsert?: AiConversationUpsertWithWhereUniqueWithoutUserInput | AiConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiConversationCreateManyUserInputEnvelope
    set?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    disconnect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    delete?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    update?: AiConversationUpdateWithWhereUniqueWithoutUserInput | AiConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiConversationUpdateManyWithWhereWithoutUserInput | AiConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
  }

  export type CompanyInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutInviterInput, CompanyInvitationUncheckedCreateWithoutInviterInput> | CompanyInvitationCreateWithoutInviterInput[] | CompanyInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutInviterInput | CompanyInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutInviterInput | CompanyInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: CompanyInvitationCreateManyInviterInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutInviterInput | CompanyInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutInviterInput | CompanyInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutAcceptedUserInput, CompanyInvitationUncheckedCreateWithoutAcceptedUserInput> | CompanyInvitationCreateWithoutAcceptedUserInput[] | CompanyInvitationUncheckedCreateWithoutAcceptedUserInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutAcceptedUserInput | CompanyInvitationCreateOrConnectWithoutAcceptedUserInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutAcceptedUserInput | CompanyInvitationUpsertWithWhereUniqueWithoutAcceptedUserInput[]
    createMany?: CompanyInvitationCreateManyAcceptedUserInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutAcceptedUserInput | CompanyInvitationUpdateWithWhereUniqueWithoutAcceptedUserInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutAcceptedUserInput | CompanyInvitationUpdateManyWithWhereWithoutAcceptedUserInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserOnboardingUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    upsert?: UserOnboardingUpsertWithoutUserInput
    disconnect?: UserOnboardingWhereInput | boolean
    delete?: UserOnboardingWhereInput | boolean
    connect?: UserOnboardingWhereUniqueInput
    update?: XOR<XOR<UserOnboardingUpdateToOneWithWhereWithoutUserInput, UserOnboardingUpdateWithoutUserInput>, UserOnboardingUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutUserInput | AnalyticsEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutUserInput | AnalyticsEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutUserInput | AnalyticsEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type OAuthAppUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OAuthAppCreateWithoutCreatedByInput, OAuthAppUncheckedCreateWithoutCreatedByInput> | OAuthAppCreateWithoutCreatedByInput[] | OAuthAppUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCreatedByInput | OAuthAppCreateOrConnectWithoutCreatedByInput[]
    upsert?: OAuthAppUpsertWithWhereUniqueWithoutCreatedByInput | OAuthAppUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OAuthAppCreateManyCreatedByInputEnvelope
    set?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    disconnect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    delete?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    update?: OAuthAppUpdateWithWhereUniqueWithoutCreatedByInput | OAuthAppUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OAuthAppUpdateManyWithWhereWithoutCreatedByInput | OAuthAppUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OAuthAppScalarWhereInput | OAuthAppScalarWhereInput[]
  }

  export type OAuthTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutUserInput | OAuthTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutUserInput | OAuthTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutUserInput | OAuthTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ApiUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput> | ApiUsageCreateWithoutUserInput[] | ApiUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutUserInput | ApiUsageCreateOrConnectWithoutUserInput[]
    upsert?: ApiUsageUpsertWithWhereUniqueWithoutUserInput | ApiUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiUsageCreateManyUserInputEnvelope
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    update?: ApiUsageUpdateWithWhereUniqueWithoutUserInput | ApiUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiUsageUpdateManyWithWhereWithoutUserInput | ApiUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type AiConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiConversationCreateWithoutUserInput, AiConversationUncheckedCreateWithoutUserInput> | AiConversationCreateWithoutUserInput[] | AiConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutUserInput | AiConversationCreateOrConnectWithoutUserInput[]
    upsert?: AiConversationUpsertWithWhereUniqueWithoutUserInput | AiConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiConversationCreateManyUserInputEnvelope
    set?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    disconnect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    delete?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    update?: AiConversationUpdateWithWhereUniqueWithoutUserInput | AiConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiConversationUpdateManyWithWhereWithoutUserInput | AiConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutInviterInput, CompanyInvitationUncheckedCreateWithoutInviterInput> | CompanyInvitationCreateWithoutInviterInput[] | CompanyInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutInviterInput | CompanyInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutInviterInput | CompanyInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: CompanyInvitationCreateManyInviterInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutInviterInput | CompanyInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutInviterInput | CompanyInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutAcceptedUserInput, CompanyInvitationUncheckedCreateWithoutAcceptedUserInput> | CompanyInvitationCreateWithoutAcceptedUserInput[] | CompanyInvitationUncheckedCreateWithoutAcceptedUserInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutAcceptedUserInput | CompanyInvitationCreateOrConnectWithoutAcceptedUserInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutAcceptedUserInput | CompanyInvitationUpsertWithWhereUniqueWithoutAcceptedUserInput[]
    createMany?: CompanyInvitationCreateManyAcceptedUserInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutAcceptedUserInput | CompanyInvitationUpdateWithWhereUniqueWithoutAcceptedUserInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutAcceptedUserInput | CompanyInvitationUpdateManyWithWhereWithoutAcceptedUserInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserOnboardingUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    upsert?: UserOnboardingUpsertWithoutUserInput
    disconnect?: UserOnboardingWhereInput | boolean
    delete?: UserOnboardingWhereInput | boolean
    connect?: UserOnboardingWhereUniqueInput
    update?: XOR<XOR<UserOnboardingUpdateToOneWithWhereWithoutUserInput, UserOnboardingUpdateWithoutUserInput>, UserOnboardingUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput> | AnalyticsEventCreateWithoutUserInput[] | AnalyticsEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutUserInput | AnalyticsEventCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutUserInput | AnalyticsEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutUserInput | AnalyticsEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutUserInput | AnalyticsEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OAuthAppCreateWithoutCreatedByInput, OAuthAppUncheckedCreateWithoutCreatedByInput> | OAuthAppCreateWithoutCreatedByInput[] | OAuthAppUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCreatedByInput | OAuthAppCreateOrConnectWithoutCreatedByInput[]
    upsert?: OAuthAppUpsertWithWhereUniqueWithoutCreatedByInput | OAuthAppUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OAuthAppCreateManyCreatedByInputEnvelope
    set?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    disconnect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    delete?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    update?: OAuthAppUpdateWithWhereUniqueWithoutCreatedByInput | OAuthAppUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OAuthAppUpdateManyWithWhereWithoutCreatedByInput | OAuthAppUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OAuthAppScalarWhereInput | OAuthAppScalarWhereInput[]
  }

  export type OAuthTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutUserInput | OAuthTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutUserInput | OAuthTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutUserInput | OAuthTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ApiUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput> | ApiUsageCreateWithoutUserInput[] | ApiUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutUserInput | ApiUsageCreateOrConnectWithoutUserInput[]
    upsert?: ApiUsageUpsertWithWhereUniqueWithoutUserInput | ApiUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiUsageCreateManyUserInputEnvelope
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    update?: ApiUsageUpdateWithWhereUniqueWithoutUserInput | ApiUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiUsageUpdateManyWithWhereWithoutUserInput | ApiUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
  }

  export type CompanyUserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type FiscalYearCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FiscalYearCreateWithoutCompanyInput, FiscalYearUncheckedCreateWithoutCompanyInput> | FiscalYearCreateWithoutCompanyInput[] | FiscalYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FiscalYearCreateOrConnectWithoutCompanyInput | FiscalYearCreateOrConnectWithoutCompanyInput[]
    createMany?: FiscalYearCreateManyCompanyInputEnvelope
    connect?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type JournalEntryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceSeriesCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceSeriesCreateWithoutCompanyInput, InvoiceSeriesUncheckedCreateWithoutCompanyInput> | InvoiceSeriesCreateWithoutCompanyInput[] | InvoiceSeriesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceSeriesCreateOrConnectWithoutCompanyInput | InvoiceSeriesCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceSeriesCreateManyCompanyInputEnvelope
    connect?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type WalletCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WalletCreateWithoutCompanyInput, WalletUncheckedCreateWithoutCompanyInput> | WalletCreateWithoutCompanyInput[] | WalletUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutCompanyInput | WalletCreateOrConnectWithoutCompanyInput[]
    createMany?: WalletCreateManyCompanyInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type CryptoAssetCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CryptoAssetCreateWithoutCompanyInput, CryptoAssetUncheckedCreateWithoutCompanyInput> | CryptoAssetCreateWithoutCompanyInput[] | CryptoAssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutCompanyInput | CryptoAssetCreateOrConnectWithoutCompanyInput[]
    createMany?: CryptoAssetCreateManyCompanyInputEnvelope
    connect?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
  }

  export type CryptoLotCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CryptoLotCreateWithoutCompanyInput, CryptoLotUncheckedCreateWithoutCompanyInput> | CryptoLotCreateWithoutCompanyInput[] | CryptoLotUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCompanyInput | CryptoLotCreateOrConnectWithoutCompanyInput[]
    createMany?: CryptoLotCreateManyCompanyInputEnvelope
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
  }

  export type ExchangeAccountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExchangeAccountCreateWithoutCompanyInput, ExchangeAccountUncheckedCreateWithoutCompanyInput> | ExchangeAccountCreateWithoutCompanyInput[] | ExchangeAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExchangeAccountCreateOrConnectWithoutCompanyInput | ExchangeAccountCreateOrConnectWithoutCompanyInput[]
    createMany?: ExchangeAccountCreateManyCompanyInputEnvelope
    connect?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
  }

  export type AiConversationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AiConversationCreateWithoutCompanyInput, AiConversationUncheckedCreateWithoutCompanyInput> | AiConversationCreateWithoutCompanyInput[] | AiConversationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutCompanyInput | AiConversationCreateOrConnectWithoutCompanyInput[]
    createMany?: AiConversationCreateManyCompanyInputEnvelope
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CompanyInvitationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type WebhookSubscriptionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCompanyInput, WebhookSubscriptionUncheckedCreateWithoutCompanyInput> | WebhookSubscriptionCreateWithoutCompanyInput[] | WebhookSubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCompanyInput | WebhookSubscriptionCreateOrConnectWithoutCompanyInput[]
    createMany?: WebhookSubscriptionCreateManyCompanyInputEnvelope
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
  }

  export type AnalyticsEventCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AnalyticsEventCreateWithoutCompanyInput, AnalyticsEventUncheckedCreateWithoutCompanyInput> | AnalyticsEventCreateWithoutCompanyInput[] | AnalyticsEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutCompanyInput | AnalyticsEventCreateOrConnectWithoutCompanyInput[]
    createMany?: AnalyticsEventCreateManyCompanyInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type OAuthAppCreateNestedManyWithoutCompanyInput = {
    create?: XOR<OAuthAppCreateWithoutCompanyInput, OAuthAppUncheckedCreateWithoutCompanyInput> | OAuthAppCreateWithoutCompanyInput[] | OAuthAppUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCompanyInput | OAuthAppCreateOrConnectWithoutCompanyInput[]
    createMany?: OAuthAppCreateManyCompanyInputEnvelope
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
  }

  export type OAuthTokenCreateNestedManyWithoutCompanyInput = {
    create?: XOR<OAuthTokenCreateWithoutCompanyInput, OAuthTokenUncheckedCreateWithoutCompanyInput> | OAuthTokenCreateWithoutCompanyInput[] | OAuthTokenUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutCompanyInput | OAuthTokenCreateOrConnectWithoutCompanyInput[]
    createMany?: OAuthTokenCreateManyCompanyInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ApiUsageCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ApiUsageCreateWithoutCompanyInput, ApiUsageUncheckedCreateWithoutCompanyInput> | ApiUsageCreateWithoutCompanyInput[] | ApiUsageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutCompanyInput | ApiUsageCreateOrConnectWithoutCompanyInput[]
    createMany?: ApiUsageCreateManyCompanyInputEnvelope
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type FiscalYearUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FiscalYearCreateWithoutCompanyInput, FiscalYearUncheckedCreateWithoutCompanyInput> | FiscalYearCreateWithoutCompanyInput[] | FiscalYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FiscalYearCreateOrConnectWithoutCompanyInput | FiscalYearCreateOrConnectWithoutCompanyInput[]
    createMany?: FiscalYearCreateManyCompanyInputEnvelope
    connect?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceSeriesCreateWithoutCompanyInput, InvoiceSeriesUncheckedCreateWithoutCompanyInput> | InvoiceSeriesCreateWithoutCompanyInput[] | InvoiceSeriesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceSeriesCreateOrConnectWithoutCompanyInput | InvoiceSeriesCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceSeriesCreateManyCompanyInputEnvelope
    connect?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WalletCreateWithoutCompanyInput, WalletUncheckedCreateWithoutCompanyInput> | WalletCreateWithoutCompanyInput[] | WalletUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutCompanyInput | WalletCreateOrConnectWithoutCompanyInput[]
    createMany?: WalletCreateManyCompanyInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CryptoAssetCreateWithoutCompanyInput, CryptoAssetUncheckedCreateWithoutCompanyInput> | CryptoAssetCreateWithoutCompanyInput[] | CryptoAssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutCompanyInput | CryptoAssetCreateOrConnectWithoutCompanyInput[]
    createMany?: CryptoAssetCreateManyCompanyInputEnvelope
    connect?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
  }

  export type CryptoLotUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CryptoLotCreateWithoutCompanyInput, CryptoLotUncheckedCreateWithoutCompanyInput> | CryptoLotCreateWithoutCompanyInput[] | CryptoLotUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCompanyInput | CryptoLotCreateOrConnectWithoutCompanyInput[]
    createMany?: CryptoLotCreateManyCompanyInputEnvelope
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
  }

  export type ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExchangeAccountCreateWithoutCompanyInput, ExchangeAccountUncheckedCreateWithoutCompanyInput> | ExchangeAccountCreateWithoutCompanyInput[] | ExchangeAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExchangeAccountCreateOrConnectWithoutCompanyInput | ExchangeAccountCreateOrConnectWithoutCompanyInput[]
    createMany?: ExchangeAccountCreateManyCompanyInputEnvelope
    connect?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
  }

  export type AiConversationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AiConversationCreateWithoutCompanyInput, AiConversationUncheckedCreateWithoutCompanyInput> | AiConversationCreateWithoutCompanyInput[] | AiConversationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutCompanyInput | AiConversationCreateOrConnectWithoutCompanyInput[]
    createMany?: AiConversationCreateManyCompanyInputEnvelope
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCompanyInput, WebhookSubscriptionUncheckedCreateWithoutCompanyInput> | WebhookSubscriptionCreateWithoutCompanyInput[] | WebhookSubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCompanyInput | WebhookSubscriptionCreateOrConnectWithoutCompanyInput[]
    createMany?: WebhookSubscriptionCreateManyCompanyInputEnvelope
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
  }

  export type AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AnalyticsEventCreateWithoutCompanyInput, AnalyticsEventUncheckedCreateWithoutCompanyInput> | AnalyticsEventCreateWithoutCompanyInput[] | AnalyticsEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutCompanyInput | AnalyticsEventCreateOrConnectWithoutCompanyInput[]
    createMany?: AnalyticsEventCreateManyCompanyInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type OAuthAppUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<OAuthAppCreateWithoutCompanyInput, OAuthAppUncheckedCreateWithoutCompanyInput> | OAuthAppCreateWithoutCompanyInput[] | OAuthAppUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCompanyInput | OAuthAppCreateOrConnectWithoutCompanyInput[]
    createMany?: OAuthAppCreateManyCompanyInputEnvelope
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
  }

  export type OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<OAuthTokenCreateWithoutCompanyInput, OAuthTokenUncheckedCreateWithoutCompanyInput> | OAuthTokenCreateWithoutCompanyInput[] | OAuthTokenUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutCompanyInput | OAuthTokenCreateOrConnectWithoutCompanyInput[]
    createMany?: OAuthTokenCreateManyCompanyInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ApiUsageUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ApiUsageCreateWithoutCompanyInput, ApiUsageUncheckedCreateWithoutCompanyInput> | ApiUsageCreateWithoutCompanyInput[] | ApiUsageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutCompanyInput | ApiUsageCreateOrConnectWithoutCompanyInput[]
    createMany?: ApiUsageCreateManyCompanyInputEnvelope
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
  }

  export type EnumTaxIdTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaxIdType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCryptoClassificationFieldUpdateOperationsInput = {
    set?: $Enums.CryptoClassification
  }

  export type CompanyUserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type FiscalYearUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FiscalYearCreateWithoutCompanyInput, FiscalYearUncheckedCreateWithoutCompanyInput> | FiscalYearCreateWithoutCompanyInput[] | FiscalYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FiscalYearCreateOrConnectWithoutCompanyInput | FiscalYearCreateOrConnectWithoutCompanyInput[]
    upsert?: FiscalYearUpsertWithWhereUniqueWithoutCompanyInput | FiscalYearUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FiscalYearCreateManyCompanyInputEnvelope
    set?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    disconnect?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    delete?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    connect?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    update?: FiscalYearUpdateWithWhereUniqueWithoutCompanyInput | FiscalYearUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FiscalYearUpdateManyWithWhereWithoutCompanyInput | FiscalYearUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FiscalYearScalarWhereInput | FiscalYearScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type JournalEntryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutCompanyInput | JournalEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutCompanyInput | JournalEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutCompanyInput | JournalEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceSeriesUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceSeriesCreateWithoutCompanyInput, InvoiceSeriesUncheckedCreateWithoutCompanyInput> | InvoiceSeriesCreateWithoutCompanyInput[] | InvoiceSeriesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceSeriesCreateOrConnectWithoutCompanyInput | InvoiceSeriesCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceSeriesUpsertWithWhereUniqueWithoutCompanyInput | InvoiceSeriesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceSeriesCreateManyCompanyInputEnvelope
    set?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    disconnect?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    delete?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    connect?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    update?: InvoiceSeriesUpdateWithWhereUniqueWithoutCompanyInput | InvoiceSeriesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceSeriesUpdateManyWithWhereWithoutCompanyInput | InvoiceSeriesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceSeriesScalarWhereInput | InvoiceSeriesScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type WalletUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WalletCreateWithoutCompanyInput, WalletUncheckedCreateWithoutCompanyInput> | WalletCreateWithoutCompanyInput[] | WalletUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutCompanyInput | WalletCreateOrConnectWithoutCompanyInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutCompanyInput | WalletUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WalletCreateManyCompanyInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutCompanyInput | WalletUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutCompanyInput | WalletUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type CryptoAssetUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CryptoAssetCreateWithoutCompanyInput, CryptoAssetUncheckedCreateWithoutCompanyInput> | CryptoAssetCreateWithoutCompanyInput[] | CryptoAssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutCompanyInput | CryptoAssetCreateOrConnectWithoutCompanyInput[]
    upsert?: CryptoAssetUpsertWithWhereUniqueWithoutCompanyInput | CryptoAssetUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CryptoAssetCreateManyCompanyInputEnvelope
    set?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    disconnect?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    delete?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    connect?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    update?: CryptoAssetUpdateWithWhereUniqueWithoutCompanyInput | CryptoAssetUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CryptoAssetUpdateManyWithWhereWithoutCompanyInput | CryptoAssetUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CryptoAssetScalarWhereInput | CryptoAssetScalarWhereInput[]
  }

  export type CryptoLotUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CryptoLotCreateWithoutCompanyInput, CryptoLotUncheckedCreateWithoutCompanyInput> | CryptoLotCreateWithoutCompanyInput[] | CryptoLotUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCompanyInput | CryptoLotCreateOrConnectWithoutCompanyInput[]
    upsert?: CryptoLotUpsertWithWhereUniqueWithoutCompanyInput | CryptoLotUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CryptoLotCreateManyCompanyInputEnvelope
    set?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    disconnect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    delete?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    update?: CryptoLotUpdateWithWhereUniqueWithoutCompanyInput | CryptoLotUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CryptoLotUpdateManyWithWhereWithoutCompanyInput | CryptoLotUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CryptoLotScalarWhereInput | CryptoLotScalarWhereInput[]
  }

  export type ExchangeAccountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExchangeAccountCreateWithoutCompanyInput, ExchangeAccountUncheckedCreateWithoutCompanyInput> | ExchangeAccountCreateWithoutCompanyInput[] | ExchangeAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExchangeAccountCreateOrConnectWithoutCompanyInput | ExchangeAccountCreateOrConnectWithoutCompanyInput[]
    upsert?: ExchangeAccountUpsertWithWhereUniqueWithoutCompanyInput | ExchangeAccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExchangeAccountCreateManyCompanyInputEnvelope
    set?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    disconnect?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    delete?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    connect?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    update?: ExchangeAccountUpdateWithWhereUniqueWithoutCompanyInput | ExchangeAccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExchangeAccountUpdateManyWithWhereWithoutCompanyInput | ExchangeAccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExchangeAccountScalarWhereInput | ExchangeAccountScalarWhereInput[]
  }

  export type AiConversationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AiConversationCreateWithoutCompanyInput, AiConversationUncheckedCreateWithoutCompanyInput> | AiConversationCreateWithoutCompanyInput[] | AiConversationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutCompanyInput | AiConversationCreateOrConnectWithoutCompanyInput[]
    upsert?: AiConversationUpsertWithWhereUniqueWithoutCompanyInput | AiConversationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AiConversationCreateManyCompanyInputEnvelope
    set?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    disconnect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    delete?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    update?: AiConversationUpdateWithWhereUniqueWithoutCompanyInput | AiConversationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AiConversationUpdateManyWithWhereWithoutCompanyInput | AiConversationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CompanyInvitationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutCompanyInput | CompanyInvitationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type WebhookSubscriptionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCompanyInput, WebhookSubscriptionUncheckedCreateWithoutCompanyInput> | WebhookSubscriptionCreateWithoutCompanyInput[] | WebhookSubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCompanyInput | WebhookSubscriptionCreateOrConnectWithoutCompanyInput[]
    upsert?: WebhookSubscriptionUpsertWithWhereUniqueWithoutCompanyInput | WebhookSubscriptionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WebhookSubscriptionCreateManyCompanyInputEnvelope
    set?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    disconnect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    delete?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    update?: WebhookSubscriptionUpdateWithWhereUniqueWithoutCompanyInput | WebhookSubscriptionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WebhookSubscriptionUpdateManyWithWhereWithoutCompanyInput | WebhookSubscriptionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
  }

  export type AnalyticsEventUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutCompanyInput, AnalyticsEventUncheckedCreateWithoutCompanyInput> | AnalyticsEventCreateWithoutCompanyInput[] | AnalyticsEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutCompanyInput | AnalyticsEventCreateOrConnectWithoutCompanyInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutCompanyInput | AnalyticsEventUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AnalyticsEventCreateManyCompanyInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutCompanyInput | AnalyticsEventUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutCompanyInput | AnalyticsEventUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type OAuthAppUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<OAuthAppCreateWithoutCompanyInput, OAuthAppUncheckedCreateWithoutCompanyInput> | OAuthAppCreateWithoutCompanyInput[] | OAuthAppUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCompanyInput | OAuthAppCreateOrConnectWithoutCompanyInput[]
    upsert?: OAuthAppUpsertWithWhereUniqueWithoutCompanyInput | OAuthAppUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: OAuthAppCreateManyCompanyInputEnvelope
    set?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    disconnect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    delete?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    update?: OAuthAppUpdateWithWhereUniqueWithoutCompanyInput | OAuthAppUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: OAuthAppUpdateManyWithWhereWithoutCompanyInput | OAuthAppUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: OAuthAppScalarWhereInput | OAuthAppScalarWhereInput[]
  }

  export type OAuthTokenUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutCompanyInput, OAuthTokenUncheckedCreateWithoutCompanyInput> | OAuthTokenCreateWithoutCompanyInput[] | OAuthTokenUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutCompanyInput | OAuthTokenCreateOrConnectWithoutCompanyInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutCompanyInput | OAuthTokenUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: OAuthTokenCreateManyCompanyInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutCompanyInput | OAuthTokenUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutCompanyInput | OAuthTokenUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ApiUsageUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ApiUsageCreateWithoutCompanyInput, ApiUsageUncheckedCreateWithoutCompanyInput> | ApiUsageCreateWithoutCompanyInput[] | ApiUsageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutCompanyInput | ApiUsageCreateOrConnectWithoutCompanyInput[]
    upsert?: ApiUsageUpsertWithWhereUniqueWithoutCompanyInput | ApiUsageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ApiUsageCreateManyCompanyInputEnvelope
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    update?: ApiUsageUpdateWithWhereUniqueWithoutCompanyInput | ApiUsageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ApiUsageUpdateManyWithWhereWithoutCompanyInput | ApiUsageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FiscalYearCreateWithoutCompanyInput, FiscalYearUncheckedCreateWithoutCompanyInput> | FiscalYearCreateWithoutCompanyInput[] | FiscalYearUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FiscalYearCreateOrConnectWithoutCompanyInput | FiscalYearCreateOrConnectWithoutCompanyInput[]
    upsert?: FiscalYearUpsertWithWhereUniqueWithoutCompanyInput | FiscalYearUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FiscalYearCreateManyCompanyInputEnvelope
    set?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    disconnect?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    delete?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    connect?: FiscalYearWhereUniqueInput | FiscalYearWhereUniqueInput[]
    update?: FiscalYearUpdateWithWhereUniqueWithoutCompanyInput | FiscalYearUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FiscalYearUpdateManyWithWhereWithoutCompanyInput | FiscalYearUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FiscalYearScalarWhereInput | FiscalYearScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutCompanyInput | JournalEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutCompanyInput | JournalEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutCompanyInput | JournalEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceSeriesCreateWithoutCompanyInput, InvoiceSeriesUncheckedCreateWithoutCompanyInput> | InvoiceSeriesCreateWithoutCompanyInput[] | InvoiceSeriesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceSeriesCreateOrConnectWithoutCompanyInput | InvoiceSeriesCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceSeriesUpsertWithWhereUniqueWithoutCompanyInput | InvoiceSeriesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceSeriesCreateManyCompanyInputEnvelope
    set?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    disconnect?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    delete?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    connect?: InvoiceSeriesWhereUniqueInput | InvoiceSeriesWhereUniqueInput[]
    update?: InvoiceSeriesUpdateWithWhereUniqueWithoutCompanyInput | InvoiceSeriesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceSeriesUpdateManyWithWhereWithoutCompanyInput | InvoiceSeriesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceSeriesScalarWhereInput | InvoiceSeriesScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type WalletUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WalletCreateWithoutCompanyInput, WalletUncheckedCreateWithoutCompanyInput> | WalletCreateWithoutCompanyInput[] | WalletUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutCompanyInput | WalletCreateOrConnectWithoutCompanyInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutCompanyInput | WalletUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WalletCreateManyCompanyInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutCompanyInput | WalletUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutCompanyInput | WalletUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CryptoAssetCreateWithoutCompanyInput, CryptoAssetUncheckedCreateWithoutCompanyInput> | CryptoAssetCreateWithoutCompanyInput[] | CryptoAssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutCompanyInput | CryptoAssetCreateOrConnectWithoutCompanyInput[]
    upsert?: CryptoAssetUpsertWithWhereUniqueWithoutCompanyInput | CryptoAssetUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CryptoAssetCreateManyCompanyInputEnvelope
    set?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    disconnect?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    delete?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    connect?: CryptoAssetWhereUniqueInput | CryptoAssetWhereUniqueInput[]
    update?: CryptoAssetUpdateWithWhereUniqueWithoutCompanyInput | CryptoAssetUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CryptoAssetUpdateManyWithWhereWithoutCompanyInput | CryptoAssetUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CryptoAssetScalarWhereInput | CryptoAssetScalarWhereInput[]
  }

  export type CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CryptoLotCreateWithoutCompanyInput, CryptoLotUncheckedCreateWithoutCompanyInput> | CryptoLotCreateWithoutCompanyInput[] | CryptoLotUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCompanyInput | CryptoLotCreateOrConnectWithoutCompanyInput[]
    upsert?: CryptoLotUpsertWithWhereUniqueWithoutCompanyInput | CryptoLotUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CryptoLotCreateManyCompanyInputEnvelope
    set?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    disconnect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    delete?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    update?: CryptoLotUpdateWithWhereUniqueWithoutCompanyInput | CryptoLotUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CryptoLotUpdateManyWithWhereWithoutCompanyInput | CryptoLotUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CryptoLotScalarWhereInput | CryptoLotScalarWhereInput[]
  }

  export type ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExchangeAccountCreateWithoutCompanyInput, ExchangeAccountUncheckedCreateWithoutCompanyInput> | ExchangeAccountCreateWithoutCompanyInput[] | ExchangeAccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExchangeAccountCreateOrConnectWithoutCompanyInput | ExchangeAccountCreateOrConnectWithoutCompanyInput[]
    upsert?: ExchangeAccountUpsertWithWhereUniqueWithoutCompanyInput | ExchangeAccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExchangeAccountCreateManyCompanyInputEnvelope
    set?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    disconnect?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    delete?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    connect?: ExchangeAccountWhereUniqueInput | ExchangeAccountWhereUniqueInput[]
    update?: ExchangeAccountUpdateWithWhereUniqueWithoutCompanyInput | ExchangeAccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExchangeAccountUpdateManyWithWhereWithoutCompanyInput | ExchangeAccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExchangeAccountScalarWhereInput | ExchangeAccountScalarWhereInput[]
  }

  export type AiConversationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AiConversationCreateWithoutCompanyInput, AiConversationUncheckedCreateWithoutCompanyInput> | AiConversationCreateWithoutCompanyInput[] | AiConversationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AiConversationCreateOrConnectWithoutCompanyInput | AiConversationCreateOrConnectWithoutCompanyInput[]
    upsert?: AiConversationUpsertWithWhereUniqueWithoutCompanyInput | AiConversationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AiConversationCreateManyCompanyInputEnvelope
    set?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    disconnect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    delete?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    connect?: AiConversationWhereUniqueInput | AiConversationWhereUniqueInput[]
    update?: AiConversationUpdateWithWhereUniqueWithoutCompanyInput | AiConversationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AiConversationUpdateManyWithWhereWithoutCompanyInput | AiConversationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput> | CompanyInvitationCreateWithoutCompanyInput[] | CompanyInvitationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvitationCreateOrConnectWithoutCompanyInput | CompanyInvitationCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyInvitationCreateManyCompanyInputEnvelope
    set?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    disconnect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    delete?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    connect?: CompanyInvitationWhereUniqueInput | CompanyInvitationWhereUniqueInput[]
    update?: CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput | CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyInvitationUpdateManyWithWhereWithoutCompanyInput | CompanyInvitationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCompanyInput, WebhookSubscriptionUncheckedCreateWithoutCompanyInput> | WebhookSubscriptionCreateWithoutCompanyInput[] | WebhookSubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCompanyInput | WebhookSubscriptionCreateOrConnectWithoutCompanyInput[]
    upsert?: WebhookSubscriptionUpsertWithWhereUniqueWithoutCompanyInput | WebhookSubscriptionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WebhookSubscriptionCreateManyCompanyInputEnvelope
    set?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    disconnect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    delete?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    update?: WebhookSubscriptionUpdateWithWhereUniqueWithoutCompanyInput | WebhookSubscriptionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WebhookSubscriptionUpdateManyWithWhereWithoutCompanyInput | WebhookSubscriptionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutCompanyInput, AnalyticsEventUncheckedCreateWithoutCompanyInput> | AnalyticsEventCreateWithoutCompanyInput[] | AnalyticsEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutCompanyInput | AnalyticsEventCreateOrConnectWithoutCompanyInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutCompanyInput | AnalyticsEventUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AnalyticsEventCreateManyCompanyInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutCompanyInput | AnalyticsEventUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutCompanyInput | AnalyticsEventUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<OAuthAppCreateWithoutCompanyInput, OAuthAppUncheckedCreateWithoutCompanyInput> | OAuthAppCreateWithoutCompanyInput[] | OAuthAppUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthAppCreateOrConnectWithoutCompanyInput | OAuthAppCreateOrConnectWithoutCompanyInput[]
    upsert?: OAuthAppUpsertWithWhereUniqueWithoutCompanyInput | OAuthAppUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: OAuthAppCreateManyCompanyInputEnvelope
    set?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    disconnect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    delete?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    connect?: OAuthAppWhereUniqueInput | OAuthAppWhereUniqueInput[]
    update?: OAuthAppUpdateWithWhereUniqueWithoutCompanyInput | OAuthAppUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: OAuthAppUpdateManyWithWhereWithoutCompanyInput | OAuthAppUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: OAuthAppScalarWhereInput | OAuthAppScalarWhereInput[]
  }

  export type OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutCompanyInput, OAuthTokenUncheckedCreateWithoutCompanyInput> | OAuthTokenCreateWithoutCompanyInput[] | OAuthTokenUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutCompanyInput | OAuthTokenCreateOrConnectWithoutCompanyInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutCompanyInput | OAuthTokenUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: OAuthTokenCreateManyCompanyInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutCompanyInput | OAuthTokenUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutCompanyInput | OAuthTokenUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ApiUsageCreateWithoutCompanyInput, ApiUsageUncheckedCreateWithoutCompanyInput> | ApiUsageCreateWithoutCompanyInput[] | ApiUsageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutCompanyInput | ApiUsageCreateOrConnectWithoutCompanyInput[]
    upsert?: ApiUsageUpsertWithWhereUniqueWithoutCompanyInput | ApiUsageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ApiUsageCreateManyCompanyInputEnvelope
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    update?: ApiUsageUpdateWithWhereUniqueWithoutCompanyInput | ApiUsageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ApiUsageUpdateManyWithWhereWithoutCompanyInput | ApiUsageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCompanyUsersInput = {
    create?: XOR<UserCreateWithoutCompanyUsersInput, UserUncheckedCreateWithoutCompanyUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyUsersInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutCompanyUsersInput = {
    create?: XOR<CompanyCreateWithoutCompanyUsersInput, CompanyUncheckedCreateWithoutCompanyUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type UserUpdateOneRequiredWithoutCompanyUsersNestedInput = {
    create?: XOR<UserCreateWithoutCompanyUsersInput, UserUncheckedCreateWithoutCompanyUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyUsersInput
    upsert?: UserUpsertWithoutCompanyUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompanyUsersInput, UserUpdateWithoutCompanyUsersInput>, UserUncheckedUpdateWithoutCompanyUsersInput>
  }

  export type CompanyUpdateOneRequiredWithoutCompanyUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanyUsersInput, CompanyUncheckedCreateWithoutCompanyUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyUsersInput
    upsert?: CompanyUpsertWithoutCompanyUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanyUsersInput, CompanyUpdateWithoutCompanyUsersInput>, CompanyUncheckedUpdateWithoutCompanyUsersInput>
  }

  export type CompanyCreateNestedOneWithoutContactsInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    connect?: CompanyWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutContactInput = {
    create?: XOR<InvoiceCreateWithoutContactInput, InvoiceUncheckedCreateWithoutContactInput> | InvoiceCreateWithoutContactInput[] | InvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutContactInput | InvoiceCreateOrConnectWithoutContactInput[]
    createMany?: InvoiceCreateManyContactInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<InvoiceCreateWithoutContactInput, InvoiceUncheckedCreateWithoutContactInput> | InvoiceCreateWithoutContactInput[] | InvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutContactInput | InvoiceCreateOrConnectWithoutContactInput[]
    createMany?: InvoiceCreateManyContactInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type NullableEnumTaxIdTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaxIdType | null
  }

  export type CompanyUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    upsert?: CompanyUpsertWithoutContactsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutContactsInput, CompanyUpdateWithoutContactsInput>, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type InvoiceUpdateManyWithoutContactNestedInput = {
    create?: XOR<InvoiceCreateWithoutContactInput, InvoiceUncheckedCreateWithoutContactInput> | InvoiceCreateWithoutContactInput[] | InvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutContactInput | InvoiceCreateOrConnectWithoutContactInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutContactInput | InvoiceUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: InvoiceCreateManyContactInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutContactInput | InvoiceUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutContactInput | InvoiceUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<InvoiceCreateWithoutContactInput, InvoiceUncheckedCreateWithoutContactInput> | InvoiceCreateWithoutContactInput[] | InvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutContactInput | InvoiceCreateOrConnectWithoutContactInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutContactInput | InvoiceUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: InvoiceCreateManyContactInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutContactInput | InvoiceUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutContactInput | InvoiceUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutFiscalYearsInput = {
    create?: XOR<CompanyCreateWithoutFiscalYearsInput, CompanyUncheckedCreateWithoutFiscalYearsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFiscalYearsInput
    connect?: CompanyWhereUniqueInput
  }

  export type JournalEntryCreateNestedManyWithoutFiscalYearInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutFiscalYearInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutFiscalYearsNestedInput = {
    create?: XOR<CompanyCreateWithoutFiscalYearsInput, CompanyUncheckedCreateWithoutFiscalYearsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFiscalYearsInput
    upsert?: CompanyUpsertWithoutFiscalYearsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFiscalYearsInput, CompanyUpdateWithoutFiscalYearsInput>, CompanyUncheckedUpdateWithoutFiscalYearsInput>
  }

  export type JournalEntryUpdateManyWithoutFiscalYearNestedInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutFiscalYearInput | JournalEntryUpdateManyWithWhereWithoutFiscalYearInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutFiscalYearNestedInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutFiscalYearInput | JournalEntryUpdateManyWithWhereWithoutFiscalYearInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutAccountsInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CryptoAssetCreateNestedOneWithoutAccountsInput = {
    create?: XOR<CryptoAssetCreateWithoutAccountsInput, CryptoAssetUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutAccountsInput
    connect?: CryptoAssetWhereUniqueInput
  }

  export type JournalLineCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type CompanyUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    upsert?: CompanyUpsertWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAccountsInput, CompanyUpdateWithoutAccountsInput>, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type CryptoAssetUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<CryptoAssetCreateWithoutAccountsInput, CryptoAssetUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutAccountsInput
    upsert?: CryptoAssetUpsertWithoutAccountsInput
    disconnect?: CryptoAssetWhereInput | boolean
    delete?: CryptoAssetWhereInput | boolean
    connect?: CryptoAssetWhereUniqueInput
    update?: XOR<XOR<CryptoAssetUpdateToOneWithWhereWithoutAccountsInput, CryptoAssetUpdateWithoutAccountsInput>, CryptoAssetUncheckedUpdateWithoutAccountsInput>
  }

  export type JournalLineUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJournalEntriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type FiscalYearCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: FiscalYearCreateOrConnectWithoutJournalEntriesInput
    connect?: FiscalYearWhereUniqueInput
  }

  export type JournalLineCreateNestedManyWithoutJournalEntryInput = {
    create?: XOR<JournalLineCreateWithoutJournalEntryInput, JournalLineUncheckedCreateWithoutJournalEntryInput> | JournalLineCreateWithoutJournalEntryInput[] | JournalLineUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalEntryInput | JournalLineCreateOrConnectWithoutJournalEntryInput[]
    createMany?: JournalLineCreateManyJournalEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutJournalEntryInput = {
    create?: XOR<JournalLineCreateWithoutJournalEntryInput, JournalLineUncheckedCreateWithoutJournalEntryInput> | JournalLineCreateWithoutJournalEntryInput[] | JournalLineUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalEntryInput | JournalLineCreateOrConnectWithoutJournalEntryInput[]
    createMany?: JournalLineCreateManyJournalEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type NullableEnumReferenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReferenceType | null
  }

  export type NullableEnumSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.SourceType | null
  }

  export type EnumJournalStatusFieldUpdateOperationsInput = {
    set?: $Enums.JournalStatus
  }

  export type CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJournalEntriesInput
    upsert?: CompanyUpsertWithoutJournalEntriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutJournalEntriesInput, CompanyUpdateWithoutJournalEntriesInput>, CompanyUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type FiscalYearUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: FiscalYearCreateOrConnectWithoutJournalEntriesInput
    upsert?: FiscalYearUpsertWithoutJournalEntriesInput
    connect?: FiscalYearWhereUniqueInput
    update?: XOR<XOR<FiscalYearUpdateToOneWithWhereWithoutJournalEntriesInput, FiscalYearUpdateWithoutJournalEntriesInput>, FiscalYearUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type JournalLineUpdateManyWithoutJournalEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutJournalEntryInput, JournalLineUncheckedCreateWithoutJournalEntryInput> | JournalLineCreateWithoutJournalEntryInput[] | JournalLineUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalEntryInput | JournalLineCreateOrConnectWithoutJournalEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutJournalEntryInput | JournalLineUpsertWithWhereUniqueWithoutJournalEntryInput[]
    createMany?: JournalLineCreateManyJournalEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutJournalEntryInput | JournalLineUpdateWithWhereUniqueWithoutJournalEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutJournalEntryInput | JournalLineUpdateManyWithWhereWithoutJournalEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutJournalEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutJournalEntryInput, JournalLineUncheckedCreateWithoutJournalEntryInput> | JournalLineCreateWithoutJournalEntryInput[] | JournalLineUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalEntryInput | JournalLineCreateOrConnectWithoutJournalEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutJournalEntryInput | JournalLineUpsertWithWhereUniqueWithoutJournalEntryInput[]
    createMany?: JournalLineCreateManyJournalEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutJournalEntryInput | JournalLineUpdateWithWhereUniqueWithoutJournalEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutJournalEntryInput | JournalLineUpdateManyWithWhereWithoutJournalEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type JournalEntryCreateNestedOneWithoutLinesInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutJournalLinesInput
    connect?: AccountWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type JournalEntryUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    upsert?: JournalEntryUpsertWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
    update?: XOR<XOR<JournalEntryUpdateToOneWithWhereWithoutLinesInput, JournalEntryUpdateWithoutLinesInput>, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type AccountUpdateOneRequiredWithoutJournalLinesNestedInput = {
    create?: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutJournalLinesInput
    upsert?: AccountUpsertWithoutJournalLinesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutJournalLinesInput, AccountUpdateWithoutJournalLinesInput>, AccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type CompanyCreateNestedOneWithoutInvoiceSeriesInput = {
    create?: XOR<CompanyCreateWithoutInvoiceSeriesInput, CompanyUncheckedCreateWithoutInvoiceSeriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoiceSeriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutSeriesInput = {
    create?: XOR<InvoiceCreateWithoutSeriesInput, InvoiceUncheckedCreateWithoutSeriesInput> | InvoiceCreateWithoutSeriesInput[] | InvoiceUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSeriesInput | InvoiceCreateOrConnectWithoutSeriesInput[]
    createMany?: InvoiceCreateManySeriesInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<InvoiceCreateWithoutSeriesInput, InvoiceUncheckedCreateWithoutSeriesInput> | InvoiceCreateWithoutSeriesInput[] | InvoiceUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSeriesInput | InvoiceCreateOrConnectWithoutSeriesInput[]
    createMany?: InvoiceCreateManySeriesInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type CompanyUpdateOneRequiredWithoutInvoiceSeriesNestedInput = {
    create?: XOR<CompanyCreateWithoutInvoiceSeriesInput, CompanyUncheckedCreateWithoutInvoiceSeriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoiceSeriesInput
    upsert?: CompanyUpsertWithoutInvoiceSeriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvoiceSeriesInput, CompanyUpdateWithoutInvoiceSeriesInput>, CompanyUncheckedUpdateWithoutInvoiceSeriesInput>
  }

  export type InvoiceUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<InvoiceCreateWithoutSeriesInput, InvoiceUncheckedCreateWithoutSeriesInput> | InvoiceCreateWithoutSeriesInput[] | InvoiceUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSeriesInput | InvoiceCreateOrConnectWithoutSeriesInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSeriesInput | InvoiceUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: InvoiceCreateManySeriesInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSeriesInput | InvoiceUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSeriesInput | InvoiceUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<InvoiceCreateWithoutSeriesInput, InvoiceUncheckedCreateWithoutSeriesInput> | InvoiceCreateWithoutSeriesInput[] | InvoiceUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSeriesInput | InvoiceCreateOrConnectWithoutSeriesInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSeriesInput | InvoiceUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: InvoiceCreateManySeriesInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSeriesInput | InvoiceUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSeriesInput | InvoiceUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type InvoiceSeriesCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<InvoiceSeriesCreateWithoutInvoicesInput, InvoiceSeriesUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: InvoiceSeriesCreateOrConnectWithoutInvoicesInput
    connect?: InvoiceSeriesWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ContactCreateWithoutInvoicesInput, ContactUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutInvoicesInput
    connect?: ContactWhereUniqueInput
  }

  export type InvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type InvoiceTaxCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceTaxCreateWithoutInvoiceInput, InvoiceTaxUncheckedCreateWithoutInvoiceInput> | InvoiceTaxCreateWithoutInvoiceInput[] | InvoiceTaxUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceTaxCreateOrConnectWithoutInvoiceInput | InvoiceTaxCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceTaxCreateManyInvoiceInputEnvelope
    connect?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
  }

  export type VerifactuRecordCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<VerifactuRecordCreateWithoutInvoiceInput, VerifactuRecordUncheckedCreateWithoutInvoiceInput> | VerifactuRecordCreateWithoutInvoiceInput[] | VerifactuRecordUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: VerifactuRecordCreateOrConnectWithoutInvoiceInput | VerifactuRecordCreateOrConnectWithoutInvoiceInput[]
    createMany?: VerifactuRecordCreateManyInvoiceInputEnvelope
    connect?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type InvoiceTaxUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceTaxCreateWithoutInvoiceInput, InvoiceTaxUncheckedCreateWithoutInvoiceInput> | InvoiceTaxCreateWithoutInvoiceInput[] | InvoiceTaxUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceTaxCreateOrConnectWithoutInvoiceInput | InvoiceTaxCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceTaxCreateManyInvoiceInputEnvelope
    connect?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
  }

  export type VerifactuRecordUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<VerifactuRecordCreateWithoutInvoiceInput, VerifactuRecordUncheckedCreateWithoutInvoiceInput> | VerifactuRecordCreateWithoutInvoiceInput[] | VerifactuRecordUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: VerifactuRecordCreateOrConnectWithoutInvoiceInput | VerifactuRecordCreateOrConnectWithoutInvoiceInput[]
    createMany?: VerifactuRecordCreateManyInvoiceInputEnvelope
    connect?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type EnumInvoiceDirectionFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceDirection
  }

  export type NullableEnumVerifactuStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerifactuStatus | null
  }

  export type CompanyUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    upsert?: CompanyUpsertWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvoicesInput, CompanyUpdateWithoutInvoicesInput>, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceSeriesUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<InvoiceSeriesCreateWithoutInvoicesInput, InvoiceSeriesUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: InvoiceSeriesCreateOrConnectWithoutInvoicesInput
    upsert?: InvoiceSeriesUpsertWithoutInvoicesInput
    connect?: InvoiceSeriesWhereUniqueInput
    update?: XOR<XOR<InvoiceSeriesUpdateToOneWithWhereWithoutInvoicesInput, InvoiceSeriesUpdateWithoutInvoicesInput>, InvoiceSeriesUncheckedUpdateWithoutInvoicesInput>
  }

  export type ContactUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<ContactCreateWithoutInvoicesInput, ContactUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutInvoicesInput
    upsert?: ContactUpsertWithoutInvoicesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutInvoicesInput, ContactUpdateWithoutInvoicesInput>, ContactUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type InvoiceTaxUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceTaxCreateWithoutInvoiceInput, InvoiceTaxUncheckedCreateWithoutInvoiceInput> | InvoiceTaxCreateWithoutInvoiceInput[] | InvoiceTaxUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceTaxCreateOrConnectWithoutInvoiceInput | InvoiceTaxCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceTaxUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceTaxUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceTaxCreateManyInvoiceInputEnvelope
    set?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    disconnect?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    delete?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    connect?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    update?: InvoiceTaxUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceTaxUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceTaxUpdateManyWithWhereWithoutInvoiceInput | InvoiceTaxUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceTaxScalarWhereInput | InvoiceTaxScalarWhereInput[]
  }

  export type VerifactuRecordUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<VerifactuRecordCreateWithoutInvoiceInput, VerifactuRecordUncheckedCreateWithoutInvoiceInput> | VerifactuRecordCreateWithoutInvoiceInput[] | VerifactuRecordUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: VerifactuRecordCreateOrConnectWithoutInvoiceInput | VerifactuRecordCreateOrConnectWithoutInvoiceInput[]
    upsert?: VerifactuRecordUpsertWithWhereUniqueWithoutInvoiceInput | VerifactuRecordUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: VerifactuRecordCreateManyInvoiceInputEnvelope
    set?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    disconnect?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    delete?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    connect?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    update?: VerifactuRecordUpdateWithWhereUniqueWithoutInvoiceInput | VerifactuRecordUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: VerifactuRecordUpdateManyWithWhereWithoutInvoiceInput | VerifactuRecordUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: VerifactuRecordScalarWhereInput | VerifactuRecordScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type InvoiceTaxUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceTaxCreateWithoutInvoiceInput, InvoiceTaxUncheckedCreateWithoutInvoiceInput> | InvoiceTaxCreateWithoutInvoiceInput[] | InvoiceTaxUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceTaxCreateOrConnectWithoutInvoiceInput | InvoiceTaxCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceTaxUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceTaxUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceTaxCreateManyInvoiceInputEnvelope
    set?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    disconnect?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    delete?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    connect?: InvoiceTaxWhereUniqueInput | InvoiceTaxWhereUniqueInput[]
    update?: InvoiceTaxUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceTaxUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceTaxUpdateManyWithWhereWithoutInvoiceInput | InvoiceTaxUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceTaxScalarWhereInput | InvoiceTaxScalarWhereInput[]
  }

  export type VerifactuRecordUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<VerifactuRecordCreateWithoutInvoiceInput, VerifactuRecordUncheckedCreateWithoutInvoiceInput> | VerifactuRecordCreateWithoutInvoiceInput[] | VerifactuRecordUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: VerifactuRecordCreateOrConnectWithoutInvoiceInput | VerifactuRecordCreateOrConnectWithoutInvoiceInput[]
    upsert?: VerifactuRecordUpsertWithWhereUniqueWithoutInvoiceInput | VerifactuRecordUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: VerifactuRecordCreateManyInvoiceInputEnvelope
    set?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    disconnect?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    delete?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    connect?: VerifactuRecordWhereUniqueInput | VerifactuRecordWhereUniqueInput[]
    update?: VerifactuRecordUpdateWithWhereUniqueWithoutInvoiceInput | VerifactuRecordUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: VerifactuRecordUpdateManyWithWhereWithoutInvoiceInput | VerifactuRecordUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: VerifactuRecordScalarWhereInput | VerifactuRecordScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    upsert?: InvoiceUpsertWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLinesInput, InvoiceUpdateWithoutLinesInput>, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceCreateNestedOneWithoutTaxesInput = {
    create?: XOR<InvoiceCreateWithoutTaxesInput, InvoiceUncheckedCreateWithoutTaxesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTaxesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumTaxTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaxType
  }

  export type InvoiceUpdateOneRequiredWithoutTaxesNestedInput = {
    create?: XOR<InvoiceCreateWithoutTaxesInput, InvoiceUncheckedCreateWithoutTaxesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTaxesInput
    upsert?: InvoiceUpsertWithoutTaxesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTaxesInput, InvoiceUpdateWithoutTaxesInput>, InvoiceUncheckedUpdateWithoutTaxesInput>
  }

  export type CompanyCreateNestedOneWithoutCryptoAssetsInput = {
    create?: XOR<CompanyCreateWithoutCryptoAssetsInput, CompanyUncheckedCreateWithoutCryptoAssetsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCryptoAssetsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutCryptoAssetInput = {
    create?: XOR<AccountCreateWithoutCryptoAssetInput, AccountUncheckedCreateWithoutCryptoAssetInput> | AccountCreateWithoutCryptoAssetInput[] | AccountUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCryptoAssetInput | AccountCreateOrConnectWithoutCryptoAssetInput[]
    createMany?: AccountCreateManyCryptoAssetInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CryptoLotCreateNestedManyWithoutCryptoAssetInput = {
    create?: XOR<CryptoLotCreateWithoutCryptoAssetInput, CryptoLotUncheckedCreateWithoutCryptoAssetInput> | CryptoLotCreateWithoutCryptoAssetInput[] | CryptoLotUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCryptoAssetInput | CryptoLotCreateOrConnectWithoutCryptoAssetInput[]
    createMany?: CryptoLotCreateManyCryptoAssetInputEnvelope
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutCryptoAssetInput = {
    create?: XOR<AccountCreateWithoutCryptoAssetInput, AccountUncheckedCreateWithoutCryptoAssetInput> | AccountCreateWithoutCryptoAssetInput[] | AccountUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCryptoAssetInput | AccountCreateOrConnectWithoutCryptoAssetInput[]
    createMany?: AccountCreateManyCryptoAssetInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CryptoLotUncheckedCreateNestedManyWithoutCryptoAssetInput = {
    create?: XOR<CryptoLotCreateWithoutCryptoAssetInput, CryptoLotUncheckedCreateWithoutCryptoAssetInput> | CryptoLotCreateWithoutCryptoAssetInput[] | CryptoLotUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCryptoAssetInput | CryptoLotCreateOrConnectWithoutCryptoAssetInput[]
    createMany?: CryptoLotCreateManyCryptoAssetInputEnvelope
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutCryptoAssetsNestedInput = {
    create?: XOR<CompanyCreateWithoutCryptoAssetsInput, CompanyUncheckedCreateWithoutCryptoAssetsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCryptoAssetsInput
    upsert?: CompanyUpsertWithoutCryptoAssetsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCryptoAssetsInput, CompanyUpdateWithoutCryptoAssetsInput>, CompanyUncheckedUpdateWithoutCryptoAssetsInput>
  }

  export type AccountUpdateManyWithoutCryptoAssetNestedInput = {
    create?: XOR<AccountCreateWithoutCryptoAssetInput, AccountUncheckedCreateWithoutCryptoAssetInput> | AccountCreateWithoutCryptoAssetInput[] | AccountUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCryptoAssetInput | AccountCreateOrConnectWithoutCryptoAssetInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCryptoAssetInput | AccountUpsertWithWhereUniqueWithoutCryptoAssetInput[]
    createMany?: AccountCreateManyCryptoAssetInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCryptoAssetInput | AccountUpdateWithWhereUniqueWithoutCryptoAssetInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCryptoAssetInput | AccountUpdateManyWithWhereWithoutCryptoAssetInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CryptoLotUpdateManyWithoutCryptoAssetNestedInput = {
    create?: XOR<CryptoLotCreateWithoutCryptoAssetInput, CryptoLotUncheckedCreateWithoutCryptoAssetInput> | CryptoLotCreateWithoutCryptoAssetInput[] | CryptoLotUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCryptoAssetInput | CryptoLotCreateOrConnectWithoutCryptoAssetInput[]
    upsert?: CryptoLotUpsertWithWhereUniqueWithoutCryptoAssetInput | CryptoLotUpsertWithWhereUniqueWithoutCryptoAssetInput[]
    createMany?: CryptoLotCreateManyCryptoAssetInputEnvelope
    set?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    disconnect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    delete?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    update?: CryptoLotUpdateWithWhereUniqueWithoutCryptoAssetInput | CryptoLotUpdateWithWhereUniqueWithoutCryptoAssetInput[]
    updateMany?: CryptoLotUpdateManyWithWhereWithoutCryptoAssetInput | CryptoLotUpdateManyWithWhereWithoutCryptoAssetInput[]
    deleteMany?: CryptoLotScalarWhereInput | CryptoLotScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutCryptoAssetNestedInput = {
    create?: XOR<AccountCreateWithoutCryptoAssetInput, AccountUncheckedCreateWithoutCryptoAssetInput> | AccountCreateWithoutCryptoAssetInput[] | AccountUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCryptoAssetInput | AccountCreateOrConnectWithoutCryptoAssetInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCryptoAssetInput | AccountUpsertWithWhereUniqueWithoutCryptoAssetInput[]
    createMany?: AccountCreateManyCryptoAssetInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCryptoAssetInput | AccountUpdateWithWhereUniqueWithoutCryptoAssetInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCryptoAssetInput | AccountUpdateManyWithWhereWithoutCryptoAssetInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CryptoLotUncheckedUpdateManyWithoutCryptoAssetNestedInput = {
    create?: XOR<CryptoLotCreateWithoutCryptoAssetInput, CryptoLotUncheckedCreateWithoutCryptoAssetInput> | CryptoLotCreateWithoutCryptoAssetInput[] | CryptoLotUncheckedCreateWithoutCryptoAssetInput[]
    connectOrCreate?: CryptoLotCreateOrConnectWithoutCryptoAssetInput | CryptoLotCreateOrConnectWithoutCryptoAssetInput[]
    upsert?: CryptoLotUpsertWithWhereUniqueWithoutCryptoAssetInput | CryptoLotUpsertWithWhereUniqueWithoutCryptoAssetInput[]
    createMany?: CryptoLotCreateManyCryptoAssetInputEnvelope
    set?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    disconnect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    delete?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    connect?: CryptoLotWhereUniqueInput | CryptoLotWhereUniqueInput[]
    update?: CryptoLotUpdateWithWhereUniqueWithoutCryptoAssetInput | CryptoLotUpdateWithWhereUniqueWithoutCryptoAssetInput[]
    updateMany?: CryptoLotUpdateManyWithWhereWithoutCryptoAssetInput | CryptoLotUpdateManyWithWhereWithoutCryptoAssetInput[]
    deleteMany?: CryptoLotScalarWhereInput | CryptoLotScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutWalletsInput = {
    create?: XOR<CompanyCreateWithoutWalletsInput, CompanyUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWalletsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CryptoTransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<CryptoTransactionCreateWithoutWalletInput, CryptoTransactionUncheckedCreateWithoutWalletInput> | CryptoTransactionCreateWithoutWalletInput[] | CryptoTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTransactionCreateOrConnectWithoutWalletInput | CryptoTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: CryptoTransactionCreateManyWalletInputEnvelope
    connect?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
  }

  export type CryptoTransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<CryptoTransactionCreateWithoutWalletInput, CryptoTransactionUncheckedCreateWithoutWalletInput> | CryptoTransactionCreateWithoutWalletInput[] | CryptoTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTransactionCreateOrConnectWithoutWalletInput | CryptoTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: CryptoTransactionCreateManyWalletInputEnvelope
    connect?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
  }

  export type EnumWalletTypeFieldUpdateOperationsInput = {
    set?: $Enums.WalletType
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus
  }

  export type CompanyUpdateOneRequiredWithoutWalletsNestedInput = {
    create?: XOR<CompanyCreateWithoutWalletsInput, CompanyUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWalletsInput
    upsert?: CompanyUpsertWithoutWalletsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWalletsInput, CompanyUpdateWithoutWalletsInput>, CompanyUncheckedUpdateWithoutWalletsInput>
  }

  export type CryptoTransactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<CryptoTransactionCreateWithoutWalletInput, CryptoTransactionUncheckedCreateWithoutWalletInput> | CryptoTransactionCreateWithoutWalletInput[] | CryptoTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTransactionCreateOrConnectWithoutWalletInput | CryptoTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: CryptoTransactionUpsertWithWhereUniqueWithoutWalletInput | CryptoTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: CryptoTransactionCreateManyWalletInputEnvelope
    set?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    disconnect?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    delete?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    connect?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    update?: CryptoTransactionUpdateWithWhereUniqueWithoutWalletInput | CryptoTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: CryptoTransactionUpdateManyWithWhereWithoutWalletInput | CryptoTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: CryptoTransactionScalarWhereInput | CryptoTransactionScalarWhereInput[]
  }

  export type CryptoTransactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<CryptoTransactionCreateWithoutWalletInput, CryptoTransactionUncheckedCreateWithoutWalletInput> | CryptoTransactionCreateWithoutWalletInput[] | CryptoTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTransactionCreateOrConnectWithoutWalletInput | CryptoTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: CryptoTransactionUpsertWithWhereUniqueWithoutWalletInput | CryptoTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: CryptoTransactionCreateManyWalletInputEnvelope
    set?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    disconnect?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    delete?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    connect?: CryptoTransactionWhereUniqueInput | CryptoTransactionWhereUniqueInput[]
    update?: CryptoTransactionUpdateWithWhereUniqueWithoutWalletInput | CryptoTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: CryptoTransactionUpdateManyWithWhereWithoutWalletInput | CryptoTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: CryptoTransactionScalarWhereInput | CryptoTransactionScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutExchangeAccountsInput = {
    create?: XOR<CompanyCreateWithoutExchangeAccountsInput, CompanyUncheckedCreateWithoutExchangeAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExchangeAccountsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutExchangeAccountsNestedInput = {
    create?: XOR<CompanyCreateWithoutExchangeAccountsInput, CompanyUncheckedCreateWithoutExchangeAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExchangeAccountsInput
    upsert?: CompanyUpsertWithoutExchangeAccountsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutExchangeAccountsInput, CompanyUpdateWithoutExchangeAccountsInput>, CompanyUncheckedUpdateWithoutExchangeAccountsInput>
  }

  export type WalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumCryptoTxTypeFieldUpdateOperationsInput = {
    set?: $Enums.CryptoTxType
  }

  export type NullableEnumCryptoTxTypeFieldUpdateOperationsInput = {
    set?: $Enums.CryptoTxType | null
  }

  export type EnumTxStatusFieldUpdateOperationsInput = {
    set?: $Enums.TxStatus
  }

  export type WalletUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    upsert?: WalletUpsertWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionsInput, WalletUpdateWithoutTransactionsInput>, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type CompanyCreateNestedOneWithoutCryptoLotsInput = {
    create?: XOR<CompanyCreateWithoutCryptoLotsInput, CompanyUncheckedCreateWithoutCryptoLotsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCryptoLotsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CryptoAssetCreateNestedOneWithoutLotsInput = {
    create?: XOR<CryptoAssetCreateWithoutLotsInput, CryptoAssetUncheckedCreateWithoutLotsInput>
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutLotsInput
    connect?: CryptoAssetWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCryptoLotsNestedInput = {
    create?: XOR<CompanyCreateWithoutCryptoLotsInput, CompanyUncheckedCreateWithoutCryptoLotsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCryptoLotsInput
    upsert?: CompanyUpsertWithoutCryptoLotsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCryptoLotsInput, CompanyUpdateWithoutCryptoLotsInput>, CompanyUncheckedUpdateWithoutCryptoLotsInput>
  }

  export type CryptoAssetUpdateOneRequiredWithoutLotsNestedInput = {
    create?: XOR<CryptoAssetCreateWithoutLotsInput, CryptoAssetUncheckedCreateWithoutLotsInput>
    connectOrCreate?: CryptoAssetCreateOrConnectWithoutLotsInput
    upsert?: CryptoAssetUpsertWithoutLotsInput
    connect?: CryptoAssetWhereUniqueInput
    update?: XOR<XOR<CryptoAssetUpdateToOneWithWhereWithoutLotsInput, CryptoAssetUpdateWithoutLotsInput>, CryptoAssetUncheckedUpdateWithoutLotsInput>
  }

  export type InvoiceCreateNestedOneWithoutVerifactuRecordsInput = {
    create?: XOR<InvoiceCreateWithoutVerifactuRecordsInput, InvoiceUncheckedCreateWithoutVerifactuRecordsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutVerifactuRecordsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumVerifactuRecordStateFieldUpdateOperationsInput = {
    set?: $Enums.VerifactuRecordState
  }

  export type InvoiceUpdateOneRequiredWithoutVerifactuRecordsNestedInput = {
    create?: XOR<InvoiceCreateWithoutVerifactuRecordsInput, InvoiceUncheckedCreateWithoutVerifactuRecordsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutVerifactuRecordsInput
    upsert?: InvoiceUpsertWithoutVerifactuRecordsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutVerifactuRecordsInput, InvoiceUpdateWithoutVerifactuRecordsInput>, InvoiceUncheckedUpdateWithoutVerifactuRecordsInput>
  }

  export type CompanyCreateNestedOneWithoutAiConversationsInput = {
    create?: XOR<CompanyCreateWithoutAiConversationsInput, CompanyUncheckedCreateWithoutAiConversationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAiConversationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAiConversationsInput = {
    create?: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type AiMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
  }

  export type AiMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutAiConversationsNestedInput = {
    create?: XOR<CompanyCreateWithoutAiConversationsInput, CompanyUncheckedCreateWithoutAiConversationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAiConversationsInput
    upsert?: CompanyUpsertWithoutAiConversationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAiConversationsInput, CompanyUpdateWithoutAiConversationsInput>, CompanyUncheckedUpdateWithoutAiConversationsInput>
  }

  export type UserUpdateOneRequiredWithoutAiConversationsNestedInput = {
    create?: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiConversationsInput
    upsert?: UserUpsertWithoutAiConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiConversationsInput, UserUpdateWithoutAiConversationsInput>, UserUncheckedUpdateWithoutAiConversationsInput>
  }

  export type AiMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AiMessageUpsertWithWhereUniqueWithoutConversationInput | AiMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    set?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    disconnect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    delete?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    update?: AiMessageUpdateWithWhereUniqueWithoutConversationInput | AiMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AiMessageUpdateManyWithWhereWithoutConversationInput | AiMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
  }

  export type AiMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput> | AiMessageCreateWithoutConversationInput[] | AiMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: AiMessageCreateOrConnectWithoutConversationInput | AiMessageCreateOrConnectWithoutConversationInput[]
    upsert?: AiMessageUpsertWithWhereUniqueWithoutConversationInput | AiMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: AiMessageCreateManyConversationInputEnvelope
    set?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    disconnect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    delete?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    connect?: AiMessageWhereUniqueInput | AiMessageWhereUniqueInput[]
    update?: AiMessageUpdateWithWhereUniqueWithoutConversationInput | AiMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: AiMessageUpdateManyWithWhereWithoutConversationInput | AiMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
  }

  export type AiConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiConversationCreateOrConnectWithoutMessagesInput
    connect?: AiConversationWhereUniqueInput
  }

  export type EnumAiRoleFieldUpdateOperationsInput = {
    set?: $Enums.AiRole
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AiConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiConversationCreateOrConnectWithoutMessagesInput
    upsert?: AiConversationUpsertWithoutMessagesInput
    connect?: AiConversationWhereUniqueInput
    update?: XOR<XOR<AiConversationUpdateToOneWithWhereWithoutMessagesInput, AiConversationUpdateWithoutMessagesInput>, AiConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type CompanyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type CompanyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    upsert?: CompanyUpsertWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDocumentsInput, CompanyUpdateWithoutDocumentsInput>, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvitationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsSentInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsAcceptedInput = {
    create?: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsAcceptedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type CompanyUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvitationsInput
    upsert?: CompanyUpsertWithoutInvitationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvitationsInput, CompanyUpdateWithoutInvitationsInput>, CompanyUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationsSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    upsert?: UserUpsertWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsSentInput, UserUpdateWithoutInvitationsSentInput>, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserUpdateOneWithoutInvitationsAcceptedNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsAcceptedInput
    upsert?: UserUpsertWithoutInvitationsAcceptedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsAcceptedInput, UserUpdateWithoutInvitationsAcceptedInput>, UserUncheckedUpdateWithoutInvitationsAcceptedInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyCreateNestedOneWithoutAnalyticsEventsInput = {
    create?: XOR<CompanyCreateWithoutAnalyticsEventsInput, CompanyUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAnalyticsEventsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnalyticsEventsInput = {
    create?: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEventsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutAnalyticsEventsNestedInput = {
    create?: XOR<CompanyCreateWithoutAnalyticsEventsInput, CompanyUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAnalyticsEventsInput
    upsert?: CompanyUpsertWithoutAnalyticsEventsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAnalyticsEventsInput, CompanyUpdateWithoutAnalyticsEventsInput>, CompanyUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type UserUpdateOneWithoutAnalyticsEventsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEventsInput
    upsert?: UserUpsertWithoutAnalyticsEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsEventsInput, UserUpdateWithoutAnalyticsEventsInput>, UserUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type OAuthAppCreateredirectUrisInput = {
    set: string[]
  }

  export type OAuthAppCreatescopesInput = {
    set: string[]
  }

  export type CompanyCreateNestedOneWithoutOauthAppsInput = {
    create?: XOR<CompanyCreateWithoutOauthAppsInput, CompanyUncheckedCreateWithoutOauthAppsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOauthAppsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOauthAppsCreatedInput = {
    create?: XOR<UserCreateWithoutOauthAppsCreatedInput, UserUncheckedCreateWithoutOauthAppsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAppsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type OAuthTokenCreateNestedManyWithoutAppInput = {
    create?: XOR<OAuthTokenCreateWithoutAppInput, OAuthTokenUncheckedCreateWithoutAppInput> | OAuthTokenCreateWithoutAppInput[] | OAuthTokenUncheckedCreateWithoutAppInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutAppInput | OAuthTokenCreateOrConnectWithoutAppInput[]
    createMany?: OAuthTokenCreateManyAppInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ApiUsageCreateNestedManyWithoutAppInput = {
    create?: XOR<ApiUsageCreateWithoutAppInput, ApiUsageUncheckedCreateWithoutAppInput> | ApiUsageCreateWithoutAppInput[] | ApiUsageUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutAppInput | ApiUsageCreateOrConnectWithoutAppInput[]
    createMany?: ApiUsageCreateManyAppInputEnvelope
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
  }

  export type OAuthTokenUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<OAuthTokenCreateWithoutAppInput, OAuthTokenUncheckedCreateWithoutAppInput> | OAuthTokenCreateWithoutAppInput[] | OAuthTokenUncheckedCreateWithoutAppInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutAppInput | OAuthTokenCreateOrConnectWithoutAppInput[]
    createMany?: OAuthTokenCreateManyAppInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ApiUsageUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<ApiUsageCreateWithoutAppInput, ApiUsageUncheckedCreateWithoutAppInput> | ApiUsageCreateWithoutAppInput[] | ApiUsageUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutAppInput | ApiUsageCreateOrConnectWithoutAppInput[]
    createMany?: ApiUsageCreateManyAppInputEnvelope
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
  }

  export type OAuthAppUpdateredirectUrisInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthAppUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompanyUpdateOneRequiredWithoutOauthAppsNestedInput = {
    create?: XOR<CompanyCreateWithoutOauthAppsInput, CompanyUncheckedCreateWithoutOauthAppsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOauthAppsInput
    upsert?: CompanyUpsertWithoutOauthAppsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutOauthAppsInput, CompanyUpdateWithoutOauthAppsInput>, CompanyUncheckedUpdateWithoutOauthAppsInput>
  }

  export type UserUpdateOneRequiredWithoutOauthAppsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutOauthAppsCreatedInput, UserUncheckedCreateWithoutOauthAppsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAppsCreatedInput
    upsert?: UserUpsertWithoutOauthAppsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthAppsCreatedInput, UserUpdateWithoutOauthAppsCreatedInput>, UserUncheckedUpdateWithoutOauthAppsCreatedInput>
  }

  export type OAuthTokenUpdateManyWithoutAppNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutAppInput, OAuthTokenUncheckedCreateWithoutAppInput> | OAuthTokenCreateWithoutAppInput[] | OAuthTokenUncheckedCreateWithoutAppInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutAppInput | OAuthTokenCreateOrConnectWithoutAppInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutAppInput | OAuthTokenUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: OAuthTokenCreateManyAppInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutAppInput | OAuthTokenUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutAppInput | OAuthTokenUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ApiUsageUpdateManyWithoutAppNestedInput = {
    create?: XOR<ApiUsageCreateWithoutAppInput, ApiUsageUncheckedCreateWithoutAppInput> | ApiUsageCreateWithoutAppInput[] | ApiUsageUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutAppInput | ApiUsageCreateOrConnectWithoutAppInput[]
    upsert?: ApiUsageUpsertWithWhereUniqueWithoutAppInput | ApiUsageUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: ApiUsageCreateManyAppInputEnvelope
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    update?: ApiUsageUpdateWithWhereUniqueWithoutAppInput | ApiUsageUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: ApiUsageUpdateManyWithWhereWithoutAppInput | ApiUsageUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
  }

  export type OAuthTokenUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutAppInput, OAuthTokenUncheckedCreateWithoutAppInput> | OAuthTokenCreateWithoutAppInput[] | OAuthTokenUncheckedCreateWithoutAppInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutAppInput | OAuthTokenCreateOrConnectWithoutAppInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutAppInput | OAuthTokenUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: OAuthTokenCreateManyAppInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutAppInput | OAuthTokenUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutAppInput | OAuthTokenUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ApiUsageUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<ApiUsageCreateWithoutAppInput, ApiUsageUncheckedCreateWithoutAppInput> | ApiUsageCreateWithoutAppInput[] | ApiUsageUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ApiUsageCreateOrConnectWithoutAppInput | ApiUsageCreateOrConnectWithoutAppInput[]
    upsert?: ApiUsageUpsertWithWhereUniqueWithoutAppInput | ApiUsageUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: ApiUsageCreateManyAppInputEnvelope
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[]
    update?: ApiUsageUpdateWithWhereUniqueWithoutAppInput | ApiUsageUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: ApiUsageUpdateManyWithWhereWithoutAppInput | ApiUsageUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
  }

  export type OAuthTokenCreatescopesInput = {
    set: string[]
  }

  export type OAuthAppCreateNestedOneWithoutTokensInput = {
    create?: XOR<OAuthAppCreateWithoutTokensInput, OAuthAppUncheckedCreateWithoutTokensInput>
    connectOrCreate?: OAuthAppCreateOrConnectWithoutTokensInput
    connect?: OAuthAppWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOauthTokensInput = {
    create?: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthTokensInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutOauthTokensInput = {
    create?: XOR<CompanyCreateWithoutOauthTokensInput, CompanyUncheckedCreateWithoutOauthTokensInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOauthTokensInput
    connect?: CompanyWhereUniqueInput
  }

  export type OAuthTokenUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthAppUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<OAuthAppCreateWithoutTokensInput, OAuthAppUncheckedCreateWithoutTokensInput>
    connectOrCreate?: OAuthAppCreateOrConnectWithoutTokensInput
    upsert?: OAuthAppUpsertWithoutTokensInput
    connect?: OAuthAppWhereUniqueInput
    update?: XOR<XOR<OAuthAppUpdateToOneWithWhereWithoutTokensInput, OAuthAppUpdateWithoutTokensInput>, OAuthAppUncheckedUpdateWithoutTokensInput>
  }

  export type UserUpdateOneRequiredWithoutOauthTokensNestedInput = {
    create?: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthTokensInput
    upsert?: UserUpsertWithoutOauthTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthTokensInput, UserUpdateWithoutOauthTokensInput>, UserUncheckedUpdateWithoutOauthTokensInput>
  }

  export type CompanyUpdateOneRequiredWithoutOauthTokensNestedInput = {
    create?: XOR<CompanyCreateWithoutOauthTokensInput, CompanyUncheckedCreateWithoutOauthTokensInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOauthTokensInput
    upsert?: CompanyUpsertWithoutOauthTokensInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutOauthTokensInput, CompanyUpdateWithoutOauthTokensInput>, CompanyUncheckedUpdateWithoutOauthTokensInput>
  }

  export type OAuthAppCreateNestedOneWithoutApiUsageInput = {
    create?: XOR<OAuthAppCreateWithoutApiUsageInput, OAuthAppUncheckedCreateWithoutApiUsageInput>
    connectOrCreate?: OAuthAppCreateOrConnectWithoutApiUsageInput
    connect?: OAuthAppWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutApiUsageInput = {
    create?: XOR<CompanyCreateWithoutApiUsageInput, CompanyUncheckedCreateWithoutApiUsageInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutApiUsageInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApiUsageInput = {
    create?: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiUsageInput
    connect?: UserWhereUniqueInput
  }

  export type OAuthAppUpdateOneWithoutApiUsageNestedInput = {
    create?: XOR<OAuthAppCreateWithoutApiUsageInput, OAuthAppUncheckedCreateWithoutApiUsageInput>
    connectOrCreate?: OAuthAppCreateOrConnectWithoutApiUsageInput
    upsert?: OAuthAppUpsertWithoutApiUsageInput
    disconnect?: OAuthAppWhereInput | boolean
    delete?: OAuthAppWhereInput | boolean
    connect?: OAuthAppWhereUniqueInput
    update?: XOR<XOR<OAuthAppUpdateToOneWithWhereWithoutApiUsageInput, OAuthAppUpdateWithoutApiUsageInput>, OAuthAppUncheckedUpdateWithoutApiUsageInput>
  }

  export type CompanyUpdateOneRequiredWithoutApiUsageNestedInput = {
    create?: XOR<CompanyCreateWithoutApiUsageInput, CompanyUncheckedCreateWithoutApiUsageInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutApiUsageInput
    upsert?: CompanyUpsertWithoutApiUsageInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutApiUsageInput, CompanyUpdateWithoutApiUsageInput>, CompanyUncheckedUpdateWithoutApiUsageInput>
  }

  export type UserUpdateOneWithoutApiUsageNestedInput = {
    create?: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiUsageInput
    upsert?: UserUpsertWithoutApiUsageInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiUsageInput, UserUpdateWithoutApiUsageInput>, UserUncheckedUpdateWithoutApiUsageInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutOnboardingInput = {
    create?: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUserOnboardingStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserOnboardingStatus
  }

  export type UserUpdateOneRequiredWithoutOnboardingNestedInput = {
    create?: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput
    upsert?: UserUpsertWithoutOnboardingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnboardingInput, UserUpdateWithoutOnboardingInput>, UserUncheckedUpdateWithoutOnboardingInput>
  }

  export type CompanyCreateNestedOneWithoutWebhookSubscriptionsInput = {
    create?: XOR<CompanyCreateWithoutWebhookSubscriptionsInput, CompanyUncheckedCreateWithoutWebhookSubscriptionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWebhookSubscriptionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type WebhookDeliveryCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<WebhookDeliveryCreateWithoutSubscriptionInput, WebhookDeliveryUncheckedCreateWithoutSubscriptionInput> | WebhookDeliveryCreateWithoutSubscriptionInput[] | WebhookDeliveryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutSubscriptionInput | WebhookDeliveryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: WebhookDeliveryCreateManySubscriptionInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<WebhookDeliveryCreateWithoutSubscriptionInput, WebhookDeliveryUncheckedCreateWithoutSubscriptionInput> | WebhookDeliveryCreateWithoutSubscriptionInput[] | WebhookDeliveryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutSubscriptionInput | WebhookDeliveryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: WebhookDeliveryCreateManySubscriptionInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWebhookSubscriptionsNestedInput = {
    create?: XOR<CompanyCreateWithoutWebhookSubscriptionsInput, CompanyUncheckedCreateWithoutWebhookSubscriptionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWebhookSubscriptionsInput
    upsert?: CompanyUpsertWithoutWebhookSubscriptionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWebhookSubscriptionsInput, CompanyUpdateWithoutWebhookSubscriptionsInput>, CompanyUncheckedUpdateWithoutWebhookSubscriptionsInput>
  }

  export type WebhookDeliveryUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutSubscriptionInput, WebhookDeliveryUncheckedCreateWithoutSubscriptionInput> | WebhookDeliveryCreateWithoutSubscriptionInput[] | WebhookDeliveryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutSubscriptionInput | WebhookDeliveryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutSubscriptionInput | WebhookDeliveryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: WebhookDeliveryCreateManySubscriptionInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutSubscriptionInput | WebhookDeliveryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutSubscriptionInput | WebhookDeliveryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutSubscriptionInput, WebhookDeliveryUncheckedCreateWithoutSubscriptionInput> | WebhookDeliveryCreateWithoutSubscriptionInput[] | WebhookDeliveryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutSubscriptionInput | WebhookDeliveryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutSubscriptionInput | WebhookDeliveryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: WebhookDeliveryCreateManySubscriptionInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutSubscriptionInput | WebhookDeliveryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutSubscriptionInput | WebhookDeliveryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookSubscriptionCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookSubscriptionWhereUniqueInput
  }

  export type EnumWebhookDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.WebhookDeliveryStatus
  }

  export type WebhookSubscriptionUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookSubscriptionUpsertWithoutDeliveriesInput
    connect?: WebhookSubscriptionWhereUniqueInput
    update?: XOR<XOR<WebhookSubscriptionUpdateToOneWithWhereWithoutDeliveriesInput, WebhookSubscriptionUpdateWithoutDeliveriesInput>, WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTaxIdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeFilter<$PrismaModel> | $Enums.TaxIdType
  }

  export type NestedEnumCryptoClassificationFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoClassification | EnumCryptoClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoClassificationFilter<$PrismaModel> | $Enums.CryptoClassification
  }

  export type NestedEnumTaxIdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxIdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxIdTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxIdTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCryptoClassificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoClassification | EnumCryptoClassificationFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoClassification[] | ListEnumCryptoClassificationFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoClassificationWithAggregatesFilter<$PrismaModel> | $Enums.CryptoClassification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCryptoClassificationFilter<$PrismaModel>
    _max?: NestedEnumCryptoClassificationFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedEnumTaxIdTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaxIdTypeNullableFilter<$PrismaModel> | $Enums.TaxIdType | null
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaxIdTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaxIdTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaxIdType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaxIdTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTaxIdTypeNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumReferenceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReferenceTypeNullableFilter<$PrismaModel> | $Enums.ReferenceType | null
  }

  export type NestedEnumSourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTypeNullableFilter<$PrismaModel> | $Enums.SourceType | null
  }

  export type NestedEnumJournalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusFilter<$PrismaModel> | $Enums.JournalStatus
  }

  export type NestedEnumReferenceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReferenceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReferenceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReferenceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReferenceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.SourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumJournalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalStatus | EnumJournalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalStatus[] | ListEnumJournalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalStatusWithAggregatesFilter<$PrismaModel> | $Enums.JournalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalStatusFilter<$PrismaModel>
    _max?: NestedEnumJournalStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceDirection | EnumInvoiceDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceDirectionFilter<$PrismaModel> | $Enums.InvoiceDirection
  }

  export type NestedEnumVerifactuStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuStatus | EnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerifactuStatusNullableFilter<$PrismaModel> | $Enums.VerifactuStatus | null
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceDirection | EnumInvoiceDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceDirection[] | ListEnumInvoiceDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceDirectionWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceDirectionFilter<$PrismaModel>
    _max?: NestedEnumInvoiceDirectionFilter<$PrismaModel>
  }

  export type NestedEnumVerifactuStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuStatus | EnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerifactuStatus[] | ListEnumVerifactuStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerifactuStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerifactuStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerifactuStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumVerifactuStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeFilter<$PrismaModel> | $Enums.TaxType
  }

  export type NestedEnumTaxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxType | EnumTaxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxType[] | ListEnumTaxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxTypeFilter<$PrismaModel>
  }

  export type NestedEnumWalletTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletType | EnumWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTypeFilter<$PrismaModel> | $Enums.WalletType
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type NestedEnumWalletTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletType | EnumWalletTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletType[] | ListEnumWalletTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTypeWithAggregatesFilter<$PrismaModel> | $Enums.WalletType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletTypeFilter<$PrismaModel>
    _max?: NestedEnumWalletTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumCryptoTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoTxTypeFilter<$PrismaModel> | $Enums.CryptoTxType
  }

  export type NestedEnumCryptoTxTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCryptoTxTypeNullableFilter<$PrismaModel> | $Enums.CryptoTxType | null
  }

  export type NestedEnumTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusFilter<$PrismaModel> | $Enums.TxStatus
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumCryptoTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCryptoTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.CryptoTxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCryptoTxTypeFilter<$PrismaModel>
    _max?: NestedEnumCryptoTxTypeFilter<$PrismaModel>
  }

  export type NestedEnumCryptoTxTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CryptoTxType | EnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CryptoTxType[] | ListEnumCryptoTxTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCryptoTxTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CryptoTxType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCryptoTxTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCryptoTxTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.TxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxStatusFilter<$PrismaModel>
    _max?: NestedEnumTxStatusFilter<$PrismaModel>
  }

  export type NestedEnumVerifactuRecordStateFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuRecordState | EnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    in?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    not?: NestedEnumVerifactuRecordStateFilter<$PrismaModel> | $Enums.VerifactuRecordState
  }

  export type NestedEnumVerifactuRecordStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerifactuRecordState | EnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    in?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerifactuRecordState[] | ListEnumVerifactuRecordStateFieldRefInput<$PrismaModel>
    not?: NestedEnumVerifactuRecordStateWithAggregatesFilter<$PrismaModel> | $Enums.VerifactuRecordState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerifactuRecordStateFilter<$PrismaModel>
    _max?: NestedEnumVerifactuRecordStateFilter<$PrismaModel>
  }

  export type NestedEnumAiRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AiRole | EnumAiRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiRoleFilter<$PrismaModel> | $Enums.AiRole
  }

  export type NestedEnumAiRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiRole | EnumAiRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiRole[] | ListEnumAiRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiRoleWithAggregatesFilter<$PrismaModel> | $Enums.AiRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiRoleFilter<$PrismaModel>
    _max?: NestedEnumAiRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserOnboardingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserOnboardingStatus | EnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserOnboardingStatusFilter<$PrismaModel> | $Enums.UserOnboardingStatus
  }

  export type NestedEnumUserOnboardingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserOnboardingStatus | EnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserOnboardingStatus[] | ListEnumUserOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserOnboardingStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserOnboardingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserOnboardingStatusFilter<$PrismaModel>
    _max?: NestedEnumUserOnboardingStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumWebhookDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookDeliveryStatus | EnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookDeliveryStatusFilter<$PrismaModel> | $Enums.WebhookDeliveryStatus
  }

  export type NestedEnumWebhookDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookDeliveryStatus | EnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookDeliveryStatus[] | ListEnumWebhookDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.WebhookDeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumWebhookDeliveryStatusFilter<$PrismaModel>
  }

  export type CompanyUserCreateWithoutUserInput = {
    id?: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanyUsersInput
  }

  export type CompanyUserUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserCreateManyUserInputEnvelope = {
    data: CompanyUserCreateManyUserInput | CompanyUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AiConversationCreateWithoutUserInput = {
    id?: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAiConversationsInput
    messages?: AiMessageCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AiConversationCreateOrConnectWithoutUserInput = {
    where: AiConversationWhereUniqueInput
    create: XOR<AiConversationCreateWithoutUserInput, AiConversationUncheckedCreateWithoutUserInput>
  }

  export type AiConversationCreateManyUserInputEnvelope = {
    data: AiConversationCreateManyUserInput | AiConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyInvitationCreateWithoutInviterInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvitationsInput
    acceptedUser?: UserCreateNestedOneWithoutInvitationsAcceptedInput
  }

  export type CompanyInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    companyId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationCreateOrConnectWithoutInviterInput = {
    where: CompanyInvitationWhereUniqueInput
    create: XOR<CompanyInvitationCreateWithoutInviterInput, CompanyInvitationUncheckedCreateWithoutInviterInput>
  }

  export type CompanyInvitationCreateManyInviterInputEnvelope = {
    data: CompanyInvitationCreateManyInviterInput | CompanyInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type CompanyInvitationCreateWithoutAcceptedUserInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutInvitationsSentInput
  }

  export type CompanyInvitationUncheckedCreateWithoutAcceptedUserInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    companyId: string
    inviterId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationCreateOrConnectWithoutAcceptedUserInput = {
    where: CompanyInvitationWhereUniqueInput
    create: XOR<CompanyInvitationCreateWithoutAcceptedUserInput, CompanyInvitationUncheckedCreateWithoutAcceptedUserInput>
  }

  export type CompanyInvitationCreateManyAcceptedUserInputEnvelope = {
    data: CompanyInvitationCreateManyAcceptedUserInput | CompanyInvitationCreateManyAcceptedUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    company?: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserOnboardingCreateWithoutUserInput = {
    status?: $Enums.UserOnboardingStatus
    currentStep?: number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastActivityAt?: Date | string
  }

  export type UserOnboardingUncheckedCreateWithoutUserInput = {
    status?: $Enums.UserOnboardingStatus
    currentStep?: number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastActivityAt?: Date | string
  }

  export type UserOnboardingCreateOrConnectWithoutUserInput = {
    where: UserOnboardingWhereUniqueInput
    create: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEventCreateWithoutUserInput = {
    id?: string
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    company?: CompanyCreateNestedOneWithoutAnalyticsEventsInput
  }

  export type AnalyticsEventUncheckedCreateWithoutUserInput = {
    id?: string
    companyId?: string | null
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AnalyticsEventCreateOrConnectWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    create: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEventCreateManyUserInputEnvelope = {
    data: AnalyticsEventCreateManyUserInput | AnalyticsEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAppCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutOauthAppsInput
    tokens?: OAuthTokenCreateNestedManyWithoutAppInput
    apiUsage?: ApiUsageCreateNestedManyWithoutAppInput
  }

  export type OAuthAppUncheckedCreateWithoutCreatedByInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: OAuthTokenUncheckedCreateNestedManyWithoutAppInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutAppInput
  }

  export type OAuthAppCreateOrConnectWithoutCreatedByInput = {
    where: OAuthAppWhereUniqueInput
    create: XOR<OAuthAppCreateWithoutCreatedByInput, OAuthAppUncheckedCreateWithoutCreatedByInput>
  }

  export type OAuthAppCreateManyCreatedByInputEnvelope = {
    data: OAuthAppCreateManyCreatedByInput | OAuthAppCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OAuthTokenCreateWithoutUserInput = {
    id?: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    app: OAuthAppCreateNestedOneWithoutTokensInput
    company: CompanyCreateNestedOneWithoutOauthTokensInput
  }

  export type OAuthTokenUncheckedCreateWithoutUserInput = {
    id?: string
    appId: string
    companyId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type OAuthTokenCreateOrConnectWithoutUserInput = {
    where: OAuthTokenWhereUniqueInput
    create: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput>
  }

  export type OAuthTokenCreateManyUserInputEnvelope = {
    data: OAuthTokenCreateManyUserInput | OAuthTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiUsageCreateWithoutUserInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    app?: OAuthAppCreateNestedOneWithoutApiUsageInput
    company: CompanyCreateNestedOneWithoutApiUsageInput
  }

  export type ApiUsageUncheckedCreateWithoutUserInput = {
    id?: string
    appId?: string | null
    companyId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiUsageCreateOrConnectWithoutUserInput = {
    where: ApiUsageWhereUniqueInput
    create: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>
  }

  export type ApiUsageCreateManyUserInputEnvelope = {
    data: ApiUsageCreateManyUserInput | ApiUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutUserInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyUserScalarWhereInput = {
    AND?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    OR?: CompanyUserScalarWhereInput[]
    NOT?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    id?: UuidFilter<"CompanyUser"> | string
    userId?: UuidFilter<"CompanyUser"> | string
    companyId?: UuidFilter<"CompanyUser"> | string
    role?: EnumUserRoleFilter<"CompanyUser"> | $Enums.UserRole
    isDefault?: BoolFilter<"CompanyUser"> | boolean
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
  }

  export type AiConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: AiConversationWhereUniqueInput
    update: XOR<AiConversationUpdateWithoutUserInput, AiConversationUncheckedUpdateWithoutUserInput>
    create: XOR<AiConversationCreateWithoutUserInput, AiConversationUncheckedCreateWithoutUserInput>
  }

  export type AiConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: AiConversationWhereUniqueInput
    data: XOR<AiConversationUpdateWithoutUserInput, AiConversationUncheckedUpdateWithoutUserInput>
  }

  export type AiConversationUpdateManyWithWhereWithoutUserInput = {
    where: AiConversationScalarWhereInput
    data: XOR<AiConversationUpdateManyMutationInput, AiConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type AiConversationScalarWhereInput = {
    AND?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
    OR?: AiConversationScalarWhereInput[]
    NOT?: AiConversationScalarWhereInput | AiConversationScalarWhereInput[]
    id?: UuidFilter<"AiConversation"> | string
    companyId?: UuidFilter<"AiConversation"> | string
    userId?: UuidFilter<"AiConversation"> | string
    title?: StringNullableFilter<"AiConversation"> | string | null
    context?: JsonNullableFilter<"AiConversation">
    createdAt?: DateTimeFilter<"AiConversation"> | Date | string
    updatedAt?: DateTimeFilter<"AiConversation"> | Date | string
  }

  export type CompanyInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: CompanyInvitationWhereUniqueInput
    update: XOR<CompanyInvitationUpdateWithoutInviterInput, CompanyInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<CompanyInvitationCreateWithoutInviterInput, CompanyInvitationUncheckedCreateWithoutInviterInput>
  }

  export type CompanyInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: CompanyInvitationWhereUniqueInput
    data: XOR<CompanyInvitationUpdateWithoutInviterInput, CompanyInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type CompanyInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: CompanyInvitationScalarWhereInput
    data: XOR<CompanyInvitationUpdateManyMutationInput, CompanyInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type CompanyInvitationScalarWhereInput = {
    AND?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
    OR?: CompanyInvitationScalarWhereInput[]
    NOT?: CompanyInvitationScalarWhereInput | CompanyInvitationScalarWhereInput[]
    id?: UuidFilter<"CompanyInvitation"> | string
    email?: StringFilter<"CompanyInvitation"> | string
    role?: EnumUserRoleFilter<"CompanyInvitation"> | $Enums.UserRole
    token?: UuidFilter<"CompanyInvitation"> | string
    status?: EnumInvitationStatusFilter<"CompanyInvitation"> | $Enums.InvitationStatus
    companyId?: UuidFilter<"CompanyInvitation"> | string
    inviterId?: UuidFilter<"CompanyInvitation"> | string
    expiresAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CompanyInvitation"> | Date | string | null
    acceptedBy?: UuidNullableFilter<"CompanyInvitation"> | string | null
    createdAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvitation"> | Date | string
  }

  export type CompanyInvitationUpsertWithWhereUniqueWithoutAcceptedUserInput = {
    where: CompanyInvitationWhereUniqueInput
    update: XOR<CompanyInvitationUpdateWithoutAcceptedUserInput, CompanyInvitationUncheckedUpdateWithoutAcceptedUserInput>
    create: XOR<CompanyInvitationCreateWithoutAcceptedUserInput, CompanyInvitationUncheckedCreateWithoutAcceptedUserInput>
  }

  export type CompanyInvitationUpdateWithWhereUniqueWithoutAcceptedUserInput = {
    where: CompanyInvitationWhereUniqueInput
    data: XOR<CompanyInvitationUpdateWithoutAcceptedUserInput, CompanyInvitationUncheckedUpdateWithoutAcceptedUserInput>
  }

  export type CompanyInvitationUpdateManyWithWhereWithoutAcceptedUserInput = {
    where: CompanyInvitationScalarWhereInput
    data: XOR<CompanyInvitationUpdateManyMutationInput, CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidFilter<"AuditLog"> | string
    companyId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserOnboardingUpsertWithoutUserInput = {
    update: XOR<UserOnboardingUpdateWithoutUserInput, UserOnboardingUncheckedUpdateWithoutUserInput>
    create: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    where?: UserOnboardingWhereInput
  }

  export type UserOnboardingUpdateToOneWithWhereWithoutUserInput = {
    where?: UserOnboardingWhereInput
    data: XOR<UserOnboardingUpdateWithoutUserInput, UserOnboardingUncheckedUpdateWithoutUserInput>
  }

  export type UserOnboardingUpdateWithoutUserInput = {
    status?: EnumUserOnboardingStatusFieldUpdateOperationsInput | $Enums.UserOnboardingStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingUncheckedUpdateWithoutUserInput = {
    status?: EnumUserOnboardingStatusFieldUpdateOperationsInput | $Enums.UserOnboardingStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    skippedSteps?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    update: XOR<AnalyticsEventUpdateWithoutUserInput, AnalyticsEventUncheckedUpdateWithoutUserInput>
    create: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEventUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    data: XOR<AnalyticsEventUpdateWithoutUserInput, AnalyticsEventUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEventUpdateManyWithWhereWithoutUserInput = {
    where: AnalyticsEventScalarWhereInput
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyWithoutUserInput>
  }

  export type AnalyticsEventScalarWhereInput = {
    AND?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    OR?: AnalyticsEventScalarWhereInput[]
    NOT?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    id?: UuidFilter<"AnalyticsEvent"> | string
    companyId?: UuidNullableFilter<"AnalyticsEvent"> | string | null
    userId?: UuidNullableFilter<"AnalyticsEvent"> | string | null
    eventType?: StringFilter<"AnalyticsEvent"> | string
    category?: StringFilter<"AnalyticsEvent"> | string
    value?: DecimalNullableFilter<"AnalyticsEvent"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"AnalyticsEvent"> | string | null
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }

  export type OAuthAppUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OAuthAppWhereUniqueInput
    update: XOR<OAuthAppUpdateWithoutCreatedByInput, OAuthAppUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OAuthAppCreateWithoutCreatedByInput, OAuthAppUncheckedCreateWithoutCreatedByInput>
  }

  export type OAuthAppUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OAuthAppWhereUniqueInput
    data: XOR<OAuthAppUpdateWithoutCreatedByInput, OAuthAppUncheckedUpdateWithoutCreatedByInput>
  }

  export type OAuthAppUpdateManyWithWhereWithoutCreatedByInput = {
    where: OAuthAppScalarWhereInput
    data: XOR<OAuthAppUpdateManyMutationInput, OAuthAppUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type OAuthAppScalarWhereInput = {
    AND?: OAuthAppScalarWhereInput | OAuthAppScalarWhereInput[]
    OR?: OAuthAppScalarWhereInput[]
    NOT?: OAuthAppScalarWhereInput | OAuthAppScalarWhereInput[]
    id?: UuidFilter<"OAuthApp"> | string
    companyId?: UuidFilter<"OAuthApp"> | string
    createdById?: UuidFilter<"OAuthApp"> | string
    name?: StringFilter<"OAuthApp"> | string
    description?: StringNullableFilter<"OAuthApp"> | string | null
    logoUrl?: StringNullableFilter<"OAuthApp"> | string | null
    website?: StringNullableFilter<"OAuthApp"> | string | null
    clientId?: StringFilter<"OAuthApp"> | string
    clientSecret?: StringFilter<"OAuthApp"> | string
    redirectUris?: StringNullableListFilter<"OAuthApp">
    scopes?: StringNullableListFilter<"OAuthApp">
    rateLimit?: IntFilter<"OAuthApp"> | number
    dailyQuota?: IntFilter<"OAuthApp"> | number
    isActive?: BoolFilter<"OAuthApp"> | boolean
    isPublic?: BoolFilter<"OAuthApp"> | boolean
    createdAt?: DateTimeFilter<"OAuthApp"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthApp"> | Date | string
  }

  export type OAuthTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: OAuthTokenWhereUniqueInput
    update: XOR<OAuthTokenUpdateWithoutUserInput, OAuthTokenUncheckedUpdateWithoutUserInput>
    create: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput>
  }

  export type OAuthTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: OAuthTokenWhereUniqueInput
    data: XOR<OAuthTokenUpdateWithoutUserInput, OAuthTokenUncheckedUpdateWithoutUserInput>
  }

  export type OAuthTokenUpdateManyWithWhereWithoutUserInput = {
    where: OAuthTokenScalarWhereInput
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type OAuthTokenScalarWhereInput = {
    AND?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
    OR?: OAuthTokenScalarWhereInput[]
    NOT?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
    id?: UuidFilter<"OAuthToken"> | string
    appId?: UuidFilter<"OAuthToken"> | string
    userId?: UuidFilter<"OAuthToken"> | string
    companyId?: UuidFilter<"OAuthToken"> | string
    accessToken?: StringFilter<"OAuthToken"> | string
    refreshToken?: StringNullableFilter<"OAuthToken"> | string | null
    scopes?: StringNullableListFilter<"OAuthToken">
    expiresAt?: DateTimeFilter<"OAuthToken"> | Date | string
    refreshExpiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    authorizationCode?: StringNullableFilter<"OAuthToken"> | string | null
    codeExpiresAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
    isRevoked?: BoolFilter<"OAuthToken"> | boolean
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"OAuthToken"> | Date | string | null
  }

  export type ApiUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiUsageWhereUniqueInput
    update: XOR<ApiUsageUpdateWithoutUserInput, ApiUsageUncheckedUpdateWithoutUserInput>
    create: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>
  }

  export type ApiUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiUsageWhereUniqueInput
    data: XOR<ApiUsageUpdateWithoutUserInput, ApiUsageUncheckedUpdateWithoutUserInput>
  }

  export type ApiUsageUpdateManyWithWhereWithoutUserInput = {
    where: ApiUsageScalarWhereInput
    data: XOR<ApiUsageUpdateManyMutationInput, ApiUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiUsageScalarWhereInput = {
    AND?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
    OR?: ApiUsageScalarWhereInput[]
    NOT?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[]
    id?: UuidFilter<"ApiUsage"> | string
    appId?: UuidNullableFilter<"ApiUsage"> | string | null
    companyId?: UuidFilter<"ApiUsage"> | string
    userId?: UuidNullableFilter<"ApiUsage"> | string | null
    endpoint?: StringFilter<"ApiUsage"> | string
    method?: StringFilter<"ApiUsage"> | string
    statusCode?: IntFilter<"ApiUsage"> | number
    responseTime?: IntFilter<"ApiUsage"> | number
    requestCount?: IntFilter<"ApiUsage"> | number
    timestamp?: DateTimeFilter<"ApiUsage"> | Date | string
    ipAddress?: StringNullableFilter<"ApiUsage"> | string | null
    userAgent?: StringNullableFilter<"ApiUsage"> | string | null
  }

  export type CompanyUserCreateWithoutCompanyInput = {
    id?: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompanyUsersInput
  }

  export type CompanyUserUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserCreateManyCompanyInputEnvelope = {
    data: CompanyUserCreateManyCompanyInput | CompanyUserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FiscalYearCreateWithoutCompanyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journalEntries?: JournalEntryCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearCreateOrConnectWithoutCompanyInput = {
    where: FiscalYearWhereUniqueInput
    create: XOR<FiscalYearCreateWithoutCompanyInput, FiscalYearUncheckedCreateWithoutCompanyInput>
  }

  export type FiscalYearCreateManyCompanyInputEnvelope = {
    data: FiscalYearCreateManyCompanyInput | FiscalYearCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoAsset?: CryptoAssetCreateNestedOneWithoutAccountsInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    cryptoAssetId?: string | null
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountCreateManyCompanyInputEnvelope = {
    data: AccountCreateManyCompanyInput | AccountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JournalEntryCreateWithoutCompanyInput = {
    id?: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: FiscalYearCreateNestedOneWithoutJournalEntriesInput
    lines?: JournalLineCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutCompanyInput = {
    id?: string
    fiscalYearId: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: JournalLineUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput>
  }

  export type JournalEntryCreateManyCompanyInputEnvelope = {
    data: JournalEntryCreateManyCompanyInput | JournalEntryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCompanyInput = {
    id?: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    series: InvoiceSeriesCreateNestedOneWithoutInvoicesInput
    contact?: ContactCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCompanyInput = {
    id?: string
    seriesId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxUncheckedCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceCreateManyCompanyInputEnvelope = {
    data: InvoiceCreateManyCompanyInput | InvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceSeriesCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutSeriesInput
  }

  export type InvoiceSeriesUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type InvoiceSeriesCreateOrConnectWithoutCompanyInput = {
    where: InvoiceSeriesWhereUniqueInput
    create: XOR<InvoiceSeriesCreateWithoutCompanyInput, InvoiceSeriesUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceSeriesCreateManyCompanyInputEnvelope = {
    data: InvoiceSeriesCreateManyCompanyInput | InvoiceSeriesCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCompanyInput = {
    id?: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCompanyInput = {
    id?: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactCreateManyCompanyInputEnvelope = {
    data: ContactCreateManyCompanyInput | ContactCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutCompanyInput = {
    id?: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: CryptoTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutCompanyInput = {
    id?: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: CryptoTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutCompanyInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutCompanyInput, WalletUncheckedCreateWithoutCompanyInput>
  }

  export type WalletCreateManyCompanyInputEnvelope = {
    data: WalletCreateManyCompanyInput | WalletCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CryptoAssetCreateWithoutCompanyInput = {
    id?: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutCryptoAssetInput
    lots?: CryptoLotCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetUncheckedCreateWithoutCompanyInput = {
    id?: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutCryptoAssetInput
    lots?: CryptoLotUncheckedCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetCreateOrConnectWithoutCompanyInput = {
    where: CryptoAssetWhereUniqueInput
    create: XOR<CryptoAssetCreateWithoutCompanyInput, CryptoAssetUncheckedCreateWithoutCompanyInput>
  }

  export type CryptoAssetCreateManyCompanyInputEnvelope = {
    data: CryptoAssetCreateManyCompanyInput | CryptoAssetCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CryptoLotCreateWithoutCompanyInput = {
    id?: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoAsset: CryptoAssetCreateNestedOneWithoutLotsInput
  }

  export type CryptoLotUncheckedCreateWithoutCompanyInput = {
    id?: string
    cryptoAssetId: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoLotCreateOrConnectWithoutCompanyInput = {
    where: CryptoLotWhereUniqueInput
    create: XOR<CryptoLotCreateWithoutCompanyInput, CryptoLotUncheckedCreateWithoutCompanyInput>
  }

  export type CryptoLotCreateManyCompanyInputEnvelope = {
    data: CryptoLotCreateManyCompanyInput | CryptoLotCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ExchangeAccountCreateWithoutCompanyInput = {
    id?: string
    exchange: string
    label?: string | null
    apiKey?: string | null
    apiSecret?: string | null
    isReadOnly?: boolean
    lastSyncAt?: Date | string | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangeAccountUncheckedCreateWithoutCompanyInput = {
    id?: string
    exchange: string
    label?: string | null
    apiKey?: string | null
    apiSecret?: string | null
    isReadOnly?: boolean
    lastSyncAt?: Date | string | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangeAccountCreateOrConnectWithoutCompanyInput = {
    where: ExchangeAccountWhereUniqueInput
    create: XOR<ExchangeAccountCreateWithoutCompanyInput, ExchangeAccountUncheckedCreateWithoutCompanyInput>
  }

  export type ExchangeAccountCreateManyCompanyInputEnvelope = {
    data: ExchangeAccountCreateManyCompanyInput | ExchangeAccountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AiConversationCreateWithoutCompanyInput = {
    id?: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAiConversationsInput
    messages?: AiMessageCreateNestedManyWithoutConversationInput
  }

  export type AiConversationUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AiMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type AiConversationCreateOrConnectWithoutCompanyInput = {
    where: AiConversationWhereUniqueInput
    create: XOR<AiConversationCreateWithoutCompanyInput, AiConversationUncheckedCreateWithoutCompanyInput>
  }

  export type AiConversationCreateManyCompanyInputEnvelope = {
    data: AiConversationCreateManyCompanyInput | AiConversationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCompanyInput = {
    id?: string
    title: string
    content: string
    type: $Enums.DocumentType
    sourceUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutCompanyInput = {
    id?: string
    title: string
    content: string
    type: $Enums.DocumentType
    sourceUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentCreateManyCompanyInputEnvelope = {
    data: DocumentCreateManyCompanyInput | DocumentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyInvitationCreateWithoutCompanyInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserCreateNestedOneWithoutInvitationsSentInput
    acceptedUser?: UserCreateNestedOneWithoutInvitationsAcceptedInput
  }

  export type CompanyInvitationUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    inviterId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationCreateOrConnectWithoutCompanyInput = {
    where: CompanyInvitationWhereUniqueInput
    create: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyInvitationCreateManyCompanyInputEnvelope = {
    data: CompanyInvitationCreateManyCompanyInput | CompanyInvitationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    id?: string
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type WebhookSubscriptionCreateWithoutCompanyInput = {
    id?: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryCreateNestedManyWithoutSubscriptionInput
  }

  export type WebhookSubscriptionUncheckedCreateWithoutCompanyInput = {
    id?: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type WebhookSubscriptionCreateOrConnectWithoutCompanyInput = {
    where: WebhookSubscriptionWhereUniqueInput
    create: XOR<WebhookSubscriptionCreateWithoutCompanyInput, WebhookSubscriptionUncheckedCreateWithoutCompanyInput>
  }

  export type WebhookSubscriptionCreateManyCompanyInputEnvelope = {
    data: WebhookSubscriptionCreateManyCompanyInput | WebhookSubscriptionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsEventCreateWithoutCompanyInput = {
    id?: string
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutAnalyticsEventsInput
  }

  export type AnalyticsEventUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId?: string | null
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AnalyticsEventCreateOrConnectWithoutCompanyInput = {
    where: AnalyticsEventWhereUniqueInput
    create: XOR<AnalyticsEventCreateWithoutCompanyInput, AnalyticsEventUncheckedCreateWithoutCompanyInput>
  }

  export type AnalyticsEventCreateManyCompanyInputEnvelope = {
    data: AnalyticsEventCreateManyCompanyInput | AnalyticsEventCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAppCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutOauthAppsCreatedInput
    tokens?: OAuthTokenCreateNestedManyWithoutAppInput
    apiUsage?: ApiUsageCreateNestedManyWithoutAppInput
  }

  export type OAuthAppUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdById: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: OAuthTokenUncheckedCreateNestedManyWithoutAppInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutAppInput
  }

  export type OAuthAppCreateOrConnectWithoutCompanyInput = {
    where: OAuthAppWhereUniqueInput
    create: XOR<OAuthAppCreateWithoutCompanyInput, OAuthAppUncheckedCreateWithoutCompanyInput>
  }

  export type OAuthAppCreateManyCompanyInputEnvelope = {
    data: OAuthAppCreateManyCompanyInput | OAuthAppCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type OAuthTokenCreateWithoutCompanyInput = {
    id?: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    app: OAuthAppCreateNestedOneWithoutTokensInput
    user: UserCreateNestedOneWithoutOauthTokensInput
  }

  export type OAuthTokenUncheckedCreateWithoutCompanyInput = {
    id?: string
    appId: string
    userId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type OAuthTokenCreateOrConnectWithoutCompanyInput = {
    where: OAuthTokenWhereUniqueInput
    create: XOR<OAuthTokenCreateWithoutCompanyInput, OAuthTokenUncheckedCreateWithoutCompanyInput>
  }

  export type OAuthTokenCreateManyCompanyInputEnvelope = {
    data: OAuthTokenCreateManyCompanyInput | OAuthTokenCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ApiUsageCreateWithoutCompanyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    app?: OAuthAppCreateNestedOneWithoutApiUsageInput
    user?: UserCreateNestedOneWithoutApiUsageInput
  }

  export type ApiUsageUncheckedCreateWithoutCompanyInput = {
    id?: string
    appId?: string | null
    userId?: string | null
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiUsageCreateOrConnectWithoutCompanyInput = {
    where: ApiUsageWhereUniqueInput
    create: XOR<ApiUsageCreateWithoutCompanyInput, ApiUsageUncheckedCreateWithoutCompanyInput>
  }

  export type ApiUsageCreateManyCompanyInputEnvelope = {
    data: ApiUsageCreateManyCompanyInput | ApiUsageCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FiscalYearUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FiscalYearWhereUniqueInput
    update: XOR<FiscalYearUpdateWithoutCompanyInput, FiscalYearUncheckedUpdateWithoutCompanyInput>
    create: XOR<FiscalYearCreateWithoutCompanyInput, FiscalYearUncheckedCreateWithoutCompanyInput>
  }

  export type FiscalYearUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FiscalYearWhereUniqueInput
    data: XOR<FiscalYearUpdateWithoutCompanyInput, FiscalYearUncheckedUpdateWithoutCompanyInput>
  }

  export type FiscalYearUpdateManyWithWhereWithoutCompanyInput = {
    where: FiscalYearScalarWhereInput
    data: XOR<FiscalYearUpdateManyMutationInput, FiscalYearUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FiscalYearScalarWhereInput = {
    AND?: FiscalYearScalarWhereInput | FiscalYearScalarWhereInput[]
    OR?: FiscalYearScalarWhereInput[]
    NOT?: FiscalYearScalarWhereInput | FiscalYearScalarWhereInput[]
    id?: UuidFilter<"FiscalYear"> | string
    companyId?: UuidFilter<"FiscalYear"> | string
    name?: StringFilter<"FiscalYear"> | string
    startDate?: DateTimeFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeFilter<"FiscalYear"> | Date | string
    isClosed?: BoolFilter<"FiscalYear"> | boolean
    closedAt?: DateTimeNullableFilter<"FiscalYear"> | Date | string | null
    closedBy?: UuidNullableFilter<"FiscalYear"> | string | null
    notes?: StringNullableFilter<"FiscalYear"> | string | null
    createdAt?: DateTimeFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalYear"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
  }

  export type AccountUpdateManyWithWhereWithoutCompanyInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: UuidFilter<"Account"> | string
    companyId?: UuidFilter<"Account"> | string
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    parentCode?: StringNullableFilter<"Account"> | string | null
    description?: StringNullableFilter<"Account"> | string | null
    isCrypto?: BoolFilter<"Account"> | boolean
    cryptoAssetId?: UuidNullableFilter<"Account"> | string | null
    isActive?: BoolFilter<"Account"> | boolean
    isSystem?: BoolFilter<"Account"> | boolean
    allowDirectPosting?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutCompanyInput, JournalEntryUncheckedUpdateWithoutCompanyInput>
    create: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutCompanyInput, JournalEntryUncheckedUpdateWithoutCompanyInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutCompanyInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    OR?: JournalEntryScalarWhereInput[]
    NOT?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    id?: UuidFilter<"JournalEntry"> | string
    companyId?: UuidFilter<"JournalEntry"> | string
    fiscalYearId?: UuidFilter<"JournalEntry"> | string
    number?: IntFilter<"JournalEntry"> | number
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringFilter<"JournalEntry"> | string
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    referenceType?: EnumReferenceTypeNullableFilter<"JournalEntry"> | $Enums.ReferenceType | null
    sourceType?: EnumSourceTypeNullableFilter<"JournalEntry"> | $Enums.SourceType | null
    sourceId?: StringNullableFilter<"JournalEntry"> | string | null
    status?: EnumJournalStatusFilter<"JournalEntry"> | $Enums.JournalStatus
    isPosted?: BoolFilter<"JournalEntry"> | boolean
    postedAt?: DateTimeNullableFilter<"JournalEntry"> | Date | string | null
    postedBy?: UuidNullableFilter<"JournalEntry"> | string | null
    isReversal?: BoolFilter<"JournalEntry"> | boolean
    reversalOf?: UuidNullableFilter<"JournalEntry"> | string | null
    reversedBy?: UuidNullableFilter<"JournalEntry"> | string | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    companyId?: UuidFilter<"Invoice"> | string
    seriesId?: UuidFilter<"Invoice"> | string
    contactId?: UuidNullableFilter<"Invoice"> | string | null
    number?: IntFilter<"Invoice"> | number
    fullNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFilter<"Invoice"> | $Enums.InvoiceDirection
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    operationDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    counterpartyName?: StringFilter<"Invoice"> | string
    counterpartyTaxId?: StringNullableFilter<"Invoice"> | string | null
    counterpartyAddress?: StringNullableFilter<"Invoice"> | string | null
    counterpartyCity?: StringNullableFilter<"Invoice"> | string | null
    counterpartyCountry?: StringFilter<"Invoice"> | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    exchangeRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFilter<"Invoice"> | boolean
    cryptoAsset?: StringNullableFilter<"Invoice"> | string | null
    cryptoAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuPrevHash?: StringNullableFilter<"Invoice"> | string | null
    verifactuQrData?: StringNullableFilter<"Invoice"> | string | null
    verifactuSentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    verifactuResponse?: JsonNullableFilter<"Invoice">
    verifactuStatus?: EnumVerifactuStatusNullableFilter<"Invoice"> | $Enums.VerifactuStatus | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    internalNotes?: StringNullableFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    journalEntryId?: UuidNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type InvoiceSeriesUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceSeriesWhereUniqueInput
    update: XOR<InvoiceSeriesUpdateWithoutCompanyInput, InvoiceSeriesUncheckedUpdateWithoutCompanyInput>
    create: XOR<InvoiceSeriesCreateWithoutCompanyInput, InvoiceSeriesUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceSeriesUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceSeriesWhereUniqueInput
    data: XOR<InvoiceSeriesUpdateWithoutCompanyInput, InvoiceSeriesUncheckedUpdateWithoutCompanyInput>
  }

  export type InvoiceSeriesUpdateManyWithWhereWithoutCompanyInput = {
    where: InvoiceSeriesScalarWhereInput
    data: XOR<InvoiceSeriesUpdateManyMutationInput, InvoiceSeriesUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InvoiceSeriesScalarWhereInput = {
    AND?: InvoiceSeriesScalarWhereInput | InvoiceSeriesScalarWhereInput[]
    OR?: InvoiceSeriesScalarWhereInput[]
    NOT?: InvoiceSeriesScalarWhereInput | InvoiceSeriesScalarWhereInput[]
    id?: UuidFilter<"InvoiceSeries"> | string
    companyId?: UuidFilter<"InvoiceSeries"> | string
    code?: StringFilter<"InvoiceSeries"> | string
    name?: StringFilter<"InvoiceSeries"> | string
    type?: EnumInvoiceTypeFilter<"InvoiceSeries"> | $Enums.InvoiceType
    prefix?: StringNullableFilter<"InvoiceSeries"> | string | null
    suffix?: StringNullableFilter<"InvoiceSeries"> | string | null
    nextNumber?: IntFilter<"InvoiceSeries"> | number
    digitCount?: IntFilter<"InvoiceSeries"> | number
    isDefault?: BoolFilter<"InvoiceSeries"> | boolean
    isActive?: BoolFilter<"InvoiceSeries"> | boolean
    createdAt?: DateTimeFilter<"InvoiceSeries"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceSeries"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: UuidFilter<"Contact"> | string
    companyId?: UuidFilter<"Contact"> | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    name?: StringFilter<"Contact"> | string
    legalName?: StringNullableFilter<"Contact"> | string | null
    taxId?: StringNullableFilter<"Contact"> | string | null
    taxIdType?: EnumTaxIdTypeNullableFilter<"Contact"> | $Enums.TaxIdType | null
    address?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    country?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type WalletUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutCompanyInput, WalletUncheckedUpdateWithoutCompanyInput>
    create: XOR<WalletCreateWithoutCompanyInput, WalletUncheckedCreateWithoutCompanyInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutCompanyInput, WalletUncheckedUpdateWithoutCompanyInput>
  }

  export type WalletUpdateManyWithWhereWithoutCompanyInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WalletScalarWhereInput = {
    AND?: WalletScalarWhereInput | WalletScalarWhereInput[]
    OR?: WalletScalarWhereInput[]
    NOT?: WalletScalarWhereInput | WalletScalarWhereInput[]
    id?: UuidFilter<"Wallet"> | string
    companyId?: UuidFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    chain?: StringFilter<"Wallet"> | string
    label?: StringNullableFilter<"Wallet"> | string | null
    type?: EnumWalletTypeFilter<"Wallet"> | $Enums.WalletType
    lastSyncAt?: DateTimeNullableFilter<"Wallet"> | Date | string | null
    lastSyncBlock?: BigIntNullableFilter<"Wallet"> | bigint | number | null
    syncStatus?: EnumSyncStatusFilter<"Wallet"> | $Enums.SyncStatus
    syncError?: StringNullableFilter<"Wallet"> | string | null
    accountCode?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
  }

  export type CryptoAssetUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CryptoAssetWhereUniqueInput
    update: XOR<CryptoAssetUpdateWithoutCompanyInput, CryptoAssetUncheckedUpdateWithoutCompanyInput>
    create: XOR<CryptoAssetCreateWithoutCompanyInput, CryptoAssetUncheckedCreateWithoutCompanyInput>
  }

  export type CryptoAssetUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CryptoAssetWhereUniqueInput
    data: XOR<CryptoAssetUpdateWithoutCompanyInput, CryptoAssetUncheckedUpdateWithoutCompanyInput>
  }

  export type CryptoAssetUpdateManyWithWhereWithoutCompanyInput = {
    where: CryptoAssetScalarWhereInput
    data: XOR<CryptoAssetUpdateManyMutationInput, CryptoAssetUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CryptoAssetScalarWhereInput = {
    AND?: CryptoAssetScalarWhereInput | CryptoAssetScalarWhereInput[]
    OR?: CryptoAssetScalarWhereInput[]
    NOT?: CryptoAssetScalarWhereInput | CryptoAssetScalarWhereInput[]
    id?: UuidFilter<"CryptoAsset"> | string
    companyId?: UuidFilter<"CryptoAsset"> | string
    symbol?: StringFilter<"CryptoAsset"> | string
    name?: StringFilter<"CryptoAsset"> | string
    decimals?: IntFilter<"CryptoAsset"> | number
    contractAddress?: StringNullableFilter<"CryptoAsset"> | string | null
    classification?: EnumCryptoClassificationFilter<"CryptoAsset"> | $Enums.CryptoClassification
    coingeckoId?: StringNullableFilter<"CryptoAsset"> | string | null
    lastPrice?: DecimalNullableFilter<"CryptoAsset"> | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: DateTimeNullableFilter<"CryptoAsset"> | Date | string | null
    isActive?: BoolFilter<"CryptoAsset"> | boolean
    createdAt?: DateTimeFilter<"CryptoAsset"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoAsset"> | Date | string
  }

  export type CryptoLotUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CryptoLotWhereUniqueInput
    update: XOR<CryptoLotUpdateWithoutCompanyInput, CryptoLotUncheckedUpdateWithoutCompanyInput>
    create: XOR<CryptoLotCreateWithoutCompanyInput, CryptoLotUncheckedCreateWithoutCompanyInput>
  }

  export type CryptoLotUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CryptoLotWhereUniqueInput
    data: XOR<CryptoLotUpdateWithoutCompanyInput, CryptoLotUncheckedUpdateWithoutCompanyInput>
  }

  export type CryptoLotUpdateManyWithWhereWithoutCompanyInput = {
    where: CryptoLotScalarWhereInput
    data: XOR<CryptoLotUpdateManyMutationInput, CryptoLotUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CryptoLotScalarWhereInput = {
    AND?: CryptoLotScalarWhereInput | CryptoLotScalarWhereInput[]
    OR?: CryptoLotScalarWhereInput[]
    NOT?: CryptoLotScalarWhereInput | CryptoLotScalarWhereInput[]
    id?: UuidFilter<"CryptoLot"> | string
    companyId?: UuidFilter<"CryptoLot"> | string
    cryptoAssetId?: UuidFilter<"CryptoLot"> | string
    acquiredAt?: DateTimeFilter<"CryptoLot"> | Date | string
    acquiredAmount?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFilter<"CryptoLot"> | Decimal | DecimalJsLike | number | string
    sourceTxId?: StringNullableFilter<"CryptoLot"> | string | null
    sourceType?: StringNullableFilter<"CryptoLot"> | string | null
    createdAt?: DateTimeFilter<"CryptoLot"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoLot"> | Date | string
  }

  export type ExchangeAccountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ExchangeAccountWhereUniqueInput
    update: XOR<ExchangeAccountUpdateWithoutCompanyInput, ExchangeAccountUncheckedUpdateWithoutCompanyInput>
    create: XOR<ExchangeAccountCreateWithoutCompanyInput, ExchangeAccountUncheckedCreateWithoutCompanyInput>
  }

  export type ExchangeAccountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ExchangeAccountWhereUniqueInput
    data: XOR<ExchangeAccountUpdateWithoutCompanyInput, ExchangeAccountUncheckedUpdateWithoutCompanyInput>
  }

  export type ExchangeAccountUpdateManyWithWhereWithoutCompanyInput = {
    where: ExchangeAccountScalarWhereInput
    data: XOR<ExchangeAccountUpdateManyMutationInput, ExchangeAccountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ExchangeAccountScalarWhereInput = {
    AND?: ExchangeAccountScalarWhereInput | ExchangeAccountScalarWhereInput[]
    OR?: ExchangeAccountScalarWhereInput[]
    NOT?: ExchangeAccountScalarWhereInput | ExchangeAccountScalarWhereInput[]
    id?: UuidFilter<"ExchangeAccount"> | string
    companyId?: UuidFilter<"ExchangeAccount"> | string
    exchange?: StringFilter<"ExchangeAccount"> | string
    label?: StringNullableFilter<"ExchangeAccount"> | string | null
    apiKey?: StringNullableFilter<"ExchangeAccount"> | string | null
    apiSecret?: StringNullableFilter<"ExchangeAccount"> | string | null
    isReadOnly?: BoolFilter<"ExchangeAccount"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"ExchangeAccount"> | Date | string | null
    syncStatus?: EnumSyncStatusFilter<"ExchangeAccount"> | $Enums.SyncStatus
    syncError?: StringNullableFilter<"ExchangeAccount"> | string | null
    country?: StringFilter<"ExchangeAccount"> | string
    isActive?: BoolFilter<"ExchangeAccount"> | boolean
    createdAt?: DateTimeFilter<"ExchangeAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ExchangeAccount"> | Date | string
  }

  export type AiConversationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AiConversationWhereUniqueInput
    update: XOR<AiConversationUpdateWithoutCompanyInput, AiConversationUncheckedUpdateWithoutCompanyInput>
    create: XOR<AiConversationCreateWithoutCompanyInput, AiConversationUncheckedCreateWithoutCompanyInput>
  }

  export type AiConversationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AiConversationWhereUniqueInput
    data: XOR<AiConversationUpdateWithoutCompanyInput, AiConversationUncheckedUpdateWithoutCompanyInput>
  }

  export type AiConversationUpdateManyWithWhereWithoutCompanyInput = {
    where: AiConversationScalarWhereInput
    data: XOR<AiConversationUpdateManyMutationInput, AiConversationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCompanyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: UuidFilter<"Document"> | string
    companyId?: UuidFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    content?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    sourceUrl?: StringNullableFilter<"Document"> | string | null
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type CompanyInvitationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyInvitationWhereUniqueInput
    update: XOR<CompanyInvitationUpdateWithoutCompanyInput, CompanyInvitationUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyInvitationCreateWithoutCompanyInput, CompanyInvitationUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyInvitationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyInvitationWhereUniqueInput
    data: XOR<CompanyInvitationUpdateWithoutCompanyInput, CompanyInvitationUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyInvitationUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyInvitationScalarWhereInput
    data: XOR<CompanyInvitationUpdateManyMutationInput, CompanyInvitationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WebhookSubscriptionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WebhookSubscriptionWhereUniqueInput
    update: XOR<WebhookSubscriptionUpdateWithoutCompanyInput, WebhookSubscriptionUncheckedUpdateWithoutCompanyInput>
    create: XOR<WebhookSubscriptionCreateWithoutCompanyInput, WebhookSubscriptionUncheckedCreateWithoutCompanyInput>
  }

  export type WebhookSubscriptionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WebhookSubscriptionWhereUniqueInput
    data: XOR<WebhookSubscriptionUpdateWithoutCompanyInput, WebhookSubscriptionUncheckedUpdateWithoutCompanyInput>
  }

  export type WebhookSubscriptionUpdateManyWithWhereWithoutCompanyInput = {
    where: WebhookSubscriptionScalarWhereInput
    data: XOR<WebhookSubscriptionUpdateManyMutationInput, WebhookSubscriptionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WebhookSubscriptionScalarWhereInput = {
    AND?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
    OR?: WebhookSubscriptionScalarWhereInput[]
    NOT?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
    id?: UuidFilter<"WebhookSubscription"> | string
    companyId?: UuidFilter<"WebhookSubscription"> | string
    url?: StringFilter<"WebhookSubscription"> | string
    secret?: StringFilter<"WebhookSubscription"> | string
    isActive?: BoolFilter<"WebhookSubscription"> | boolean
    events?: JsonFilter<"WebhookSubscription">
    retryCount?: IntFilter<"WebhookSubscription"> | number
    timeout?: IntFilter<"WebhookSubscription"> | number
    description?: StringNullableFilter<"WebhookSubscription"> | string | null
    metadata?: JsonNullableFilter<"WebhookSubscription">
    createdAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
  }

  export type AnalyticsEventUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AnalyticsEventWhereUniqueInput
    update: XOR<AnalyticsEventUpdateWithoutCompanyInput, AnalyticsEventUncheckedUpdateWithoutCompanyInput>
    create: XOR<AnalyticsEventCreateWithoutCompanyInput, AnalyticsEventUncheckedCreateWithoutCompanyInput>
  }

  export type AnalyticsEventUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AnalyticsEventWhereUniqueInput
    data: XOR<AnalyticsEventUpdateWithoutCompanyInput, AnalyticsEventUncheckedUpdateWithoutCompanyInput>
  }

  export type AnalyticsEventUpdateManyWithWhereWithoutCompanyInput = {
    where: AnalyticsEventScalarWhereInput
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyWithoutCompanyInput>
  }

  export type OAuthAppUpsertWithWhereUniqueWithoutCompanyInput = {
    where: OAuthAppWhereUniqueInput
    update: XOR<OAuthAppUpdateWithoutCompanyInput, OAuthAppUncheckedUpdateWithoutCompanyInput>
    create: XOR<OAuthAppCreateWithoutCompanyInput, OAuthAppUncheckedCreateWithoutCompanyInput>
  }

  export type OAuthAppUpdateWithWhereUniqueWithoutCompanyInput = {
    where: OAuthAppWhereUniqueInput
    data: XOR<OAuthAppUpdateWithoutCompanyInput, OAuthAppUncheckedUpdateWithoutCompanyInput>
  }

  export type OAuthAppUpdateManyWithWhereWithoutCompanyInput = {
    where: OAuthAppScalarWhereInput
    data: XOR<OAuthAppUpdateManyMutationInput, OAuthAppUncheckedUpdateManyWithoutCompanyInput>
  }

  export type OAuthTokenUpsertWithWhereUniqueWithoutCompanyInput = {
    where: OAuthTokenWhereUniqueInput
    update: XOR<OAuthTokenUpdateWithoutCompanyInput, OAuthTokenUncheckedUpdateWithoutCompanyInput>
    create: XOR<OAuthTokenCreateWithoutCompanyInput, OAuthTokenUncheckedCreateWithoutCompanyInput>
  }

  export type OAuthTokenUpdateWithWhereUniqueWithoutCompanyInput = {
    where: OAuthTokenWhereUniqueInput
    data: XOR<OAuthTokenUpdateWithoutCompanyInput, OAuthTokenUncheckedUpdateWithoutCompanyInput>
  }

  export type OAuthTokenUpdateManyWithWhereWithoutCompanyInput = {
    where: OAuthTokenScalarWhereInput
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ApiUsageUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ApiUsageWhereUniqueInput
    update: XOR<ApiUsageUpdateWithoutCompanyInput, ApiUsageUncheckedUpdateWithoutCompanyInput>
    create: XOR<ApiUsageCreateWithoutCompanyInput, ApiUsageUncheckedCreateWithoutCompanyInput>
  }

  export type ApiUsageUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ApiUsageWhereUniqueInput
    data: XOR<ApiUsageUpdateWithoutCompanyInput, ApiUsageUncheckedUpdateWithoutCompanyInput>
  }

  export type ApiUsageUpdateManyWithWhereWithoutCompanyInput = {
    where: ApiUsageScalarWhereInput
    data: XOR<ApiUsageUpdateManyMutationInput, ApiUsageUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserCreateWithoutCompanyUsersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyUsersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyUsersInput, UserUncheckedCreateWithoutCompanyUsersInput>
  }

  export type CompanyCreateWithoutCompanyUsersInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCompanyUsersInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCompanyUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanyUsersInput, CompanyUncheckedCreateWithoutCompanyUsersInput>
  }

  export type UserUpsertWithoutCompanyUsersInput = {
    update: XOR<UserUpdateWithoutCompanyUsersInput, UserUncheckedUpdateWithoutCompanyUsersInput>
    create: XOR<UserCreateWithoutCompanyUsersInput, UserUncheckedCreateWithoutCompanyUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompanyUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompanyUsersInput, UserUncheckedUpdateWithoutCompanyUsersInput>
  }

  export type UserUpdateWithoutCompanyUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutCompanyUsersInput = {
    update: XOR<CompanyUpdateWithoutCompanyUsersInput, CompanyUncheckedUpdateWithoutCompanyUsersInput>
    create: XOR<CompanyCreateWithoutCompanyUsersInput, CompanyUncheckedCreateWithoutCompanyUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanyUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanyUsersInput, CompanyUncheckedUpdateWithoutCompanyUsersInput>
  }

  export type CompanyUpdateWithoutCompanyUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCompanyUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutContactsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutContactsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
  }

  export type InvoiceCreateWithoutContactInput = {
    id?: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
    series: InvoiceSeriesCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutContactInput = {
    id?: string
    companyId: string
    seriesId: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxUncheckedCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutContactInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutContactInput, InvoiceUncheckedCreateWithoutContactInput>
  }

  export type InvoiceCreateManyContactInputEnvelope = {
    data: InvoiceCreateManyContactInput | InvoiceCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutContactsInput = {
    update: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutContactsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type CompanyUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutContactInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutContactInput, InvoiceUncheckedUpdateWithoutContactInput>
    create: XOR<InvoiceCreateWithoutContactInput, InvoiceUncheckedCreateWithoutContactInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutContactInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutContactInput, InvoiceUncheckedUpdateWithoutContactInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutContactInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutContactInput>
  }

  export type CompanyCreateWithoutFiscalYearsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFiscalYearsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFiscalYearsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFiscalYearsInput, CompanyUncheckedCreateWithoutFiscalYearsInput>
  }

  export type JournalEntryCreateWithoutFiscalYearInput = {
    id?: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
    lines?: JournalLineCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutFiscalYearInput = {
    id?: string
    companyId: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: JournalLineUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutFiscalYearInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput>
  }

  export type JournalEntryCreateManyFiscalYearInputEnvelope = {
    data: JournalEntryCreateManyFiscalYearInput | JournalEntryCreateManyFiscalYearInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutFiscalYearsInput = {
    update: XOR<CompanyUpdateWithoutFiscalYearsInput, CompanyUncheckedUpdateWithoutFiscalYearsInput>
    create: XOR<CompanyCreateWithoutFiscalYearsInput, CompanyUncheckedCreateWithoutFiscalYearsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFiscalYearsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFiscalYearsInput, CompanyUncheckedUpdateWithoutFiscalYearsInput>
  }

  export type CompanyUpdateWithoutFiscalYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFiscalYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutFiscalYearInput, JournalEntryUncheckedUpdateWithoutFiscalYearInput>
    create: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutFiscalYearInput, JournalEntryUncheckedUpdateWithoutFiscalYearInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutFiscalYearInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutFiscalYearInput>
  }

  export type CompanyCreateWithoutAccountsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAccountsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
  }

  export type CryptoAssetCreateWithoutAccountsInput = {
    id?: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCryptoAssetsInput
    lots?: CryptoLotCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetUncheckedCreateWithoutAccountsInput = {
    id?: string
    companyId: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: CryptoLotUncheckedCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetCreateOrConnectWithoutAccountsInput = {
    where: CryptoAssetWhereUniqueInput
    create: XOR<CryptoAssetCreateWithoutAccountsInput, CryptoAssetUncheckedCreateWithoutAccountsInput>
  }

  export type JournalLineCreateWithoutAccountInput = {
    id?: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
    journalEntry: JournalEntryCreateNestedOneWithoutLinesInput
  }

  export type JournalLineUncheckedCreateWithoutAccountInput = {
    id?: string
    journalEntryId: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
  }

  export type JournalLineCreateOrConnectWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineCreateManyAccountInputEnvelope = {
    data: JournalLineCreateManyAccountInput | JournalLineCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutAccountsInput = {
    update: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAccountsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type CompanyUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CryptoAssetUpsertWithoutAccountsInput = {
    update: XOR<CryptoAssetUpdateWithoutAccountsInput, CryptoAssetUncheckedUpdateWithoutAccountsInput>
    create: XOR<CryptoAssetCreateWithoutAccountsInput, CryptoAssetUncheckedCreateWithoutAccountsInput>
    where?: CryptoAssetWhereInput
  }

  export type CryptoAssetUpdateToOneWithWhereWithoutAccountsInput = {
    where?: CryptoAssetWhereInput
    data: XOR<CryptoAssetUpdateWithoutAccountsInput, CryptoAssetUncheckedUpdateWithoutAccountsInput>
  }

  export type CryptoAssetUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCryptoAssetsNestedInput
    lots?: CryptoLotUpdateManyWithoutCryptoAssetNestedInput
  }

  export type CryptoAssetUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: CryptoLotUncheckedUpdateManyWithoutCryptoAssetNestedInput
  }

  export type JournalLineUpsertWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutAccountInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutAccountInput>
  }

  export type JournalLineScalarWhereInput = {
    AND?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    OR?: JournalLineScalarWhereInput[]
    NOT?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    id?: UuidFilter<"JournalLine"> | string
    journalEntryId?: UuidFilter<"JournalLine"> | string
    accountId?: UuidFilter<"JournalLine"> | string
    lineNumber?: IntFilter<"JournalLine"> | number
    description?: StringNullableFilter<"JournalLine"> | string | null
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    cryptoAmount?: DecimalNullableFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: StringNullableFilter<"JournalLine"> | string | null
    cryptoPrice?: DecimalNullableFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string | null
    costCenter?: StringNullableFilter<"JournalLine"> | string | null
    project?: StringNullableFilter<"JournalLine"> | string | null
    createdAt?: DateTimeFilter<"JournalLine"> | Date | string
  }

  export type CompanyCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutJournalEntriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
  }

  export type FiscalYearCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFiscalYearsInput
  }

  export type FiscalYearUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    companyId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearCreateOrConnectWithoutJournalEntriesInput = {
    where: FiscalYearWhereUniqueInput
    create: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
  }

  export type JournalLineCreateWithoutJournalEntryInput = {
    id?: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutJournalEntryInput = {
    id?: string
    accountId: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
  }

  export type JournalLineCreateOrConnectWithoutJournalEntryInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutJournalEntryInput, JournalLineUncheckedCreateWithoutJournalEntryInput>
  }

  export type JournalLineCreateManyJournalEntryInputEnvelope = {
    data: JournalLineCreateManyJournalEntryInput | JournalLineCreateManyJournalEntryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutJournalEntriesInput = {
    update: XOR<CompanyUpdateWithoutJournalEntriesInput, CompanyUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutJournalEntriesInput, CompanyUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type CompanyUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FiscalYearUpsertWithoutJournalEntriesInput = {
    update: XOR<FiscalYearUpdateWithoutJournalEntriesInput, FiscalYearUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
    where?: FiscalYearWhereInput
  }

  export type FiscalYearUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: FiscalYearWhereInput
    data: XOR<FiscalYearUpdateWithoutJournalEntriesInput, FiscalYearUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type FiscalYearUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFiscalYearsNestedInput
  }

  export type FiscalYearUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUpsertWithWhereUniqueWithoutJournalEntryInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutJournalEntryInput, JournalLineUncheckedUpdateWithoutJournalEntryInput>
    create: XOR<JournalLineCreateWithoutJournalEntryInput, JournalLineUncheckedCreateWithoutJournalEntryInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutJournalEntryInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutJournalEntryInput, JournalLineUncheckedUpdateWithoutJournalEntryInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutJournalEntryInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutJournalEntryInput>
  }

  export type JournalEntryCreateWithoutLinesInput = {
    id?: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
    fiscalYear: FiscalYearCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateWithoutLinesInput = {
    id?: string
    companyId: string
    fiscalYearId: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateOrConnectWithoutLinesInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
  }

  export type AccountCreateWithoutJournalLinesInput = {
    id?: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAccountsInput
    cryptoAsset?: CryptoAssetCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    cryptoAssetId?: string | null
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutJournalLinesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
  }

  export type JournalEntryUpsertWithoutLinesInput = {
    update: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    where?: JournalEntryWhereInput
  }

  export type JournalEntryUpdateToOneWithWhereWithoutLinesInput = {
    where?: JournalEntryWhereInput
    data: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type JournalEntryUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
    fiscalYear?: FiscalYearUpdateOneRequiredWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    fiscalYearId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithoutJournalLinesInput = {
    update: XOR<AccountUpdateWithoutJournalLinesInput, AccountUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutJournalLinesInput, AccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type AccountUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    cryptoAsset?: CryptoAssetUpdateOneWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    cryptoAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutInvoiceSeriesInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvoiceSeriesInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvoiceSeriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvoiceSeriesInput, CompanyUncheckedCreateWithoutInvoiceSeriesInput>
  }

  export type InvoiceCreateWithoutSeriesInput = {
    id?: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
    contact?: ContactCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSeriesInput = {
    id?: string
    companyId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxUncheckedCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSeriesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSeriesInput, InvoiceUncheckedCreateWithoutSeriesInput>
  }

  export type InvoiceCreateManySeriesInputEnvelope = {
    data: InvoiceCreateManySeriesInput | InvoiceCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutInvoiceSeriesInput = {
    update: XOR<CompanyUpdateWithoutInvoiceSeriesInput, CompanyUncheckedUpdateWithoutInvoiceSeriesInput>
    create: XOR<CompanyCreateWithoutInvoiceSeriesInput, CompanyUncheckedCreateWithoutInvoiceSeriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvoiceSeriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvoiceSeriesInput, CompanyUncheckedUpdateWithoutInvoiceSeriesInput>
  }

  export type CompanyUpdateWithoutInvoiceSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvoiceSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSeriesInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSeriesInput, InvoiceUncheckedUpdateWithoutSeriesInput>
    create: XOR<InvoiceCreateWithoutSeriesInput, InvoiceUncheckedCreateWithoutSeriesInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSeriesInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSeriesInput, InvoiceUncheckedUpdateWithoutSeriesInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSeriesInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSeriesInput>
  }

  export type CompanyCreateWithoutInvoicesInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceSeriesCreateWithoutInvoicesInput = {
    id?: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoiceSeriesInput
  }

  export type InvoiceSeriesUncheckedCreateWithoutInvoicesInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceSeriesCreateOrConnectWithoutInvoicesInput = {
    where: InvoiceSeriesWhereUniqueInput
    create: XOR<InvoiceSeriesCreateWithoutInvoicesInput, InvoiceSeriesUncheckedCreateWithoutInvoicesInput>
  }

  export type ContactCreateWithoutInvoicesInput = {
    id?: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutInvoicesInput = {
    id?: string
    companyId: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutInvoicesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutInvoicesInput, ContactUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    lineNumber: number
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    accountCode?: string | null
  }

  export type InvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    lineNumber: number
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    accountCode?: string | null
  }

  export type InvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineCreateManyInvoiceInput | InvoiceLineCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceTaxCreateWithoutInvoiceInput = {
    id?: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxType?: $Enums.TaxType
  }

  export type InvoiceTaxUncheckedCreateWithoutInvoiceInput = {
    id?: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxType?: $Enums.TaxType
  }

  export type InvoiceTaxCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceTaxWhereUniqueInput
    create: XOR<InvoiceTaxCreateWithoutInvoiceInput, InvoiceTaxUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceTaxCreateManyInvoiceInputEnvelope = {
    data: InvoiceTaxCreateManyInvoiceInput | InvoiceTaxCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type VerifactuRecordCreateWithoutInvoiceInput = {
    id?: string
    hash: string
    prevHash?: string | null
    xmlContent: string
    state?: $Enums.VerifactuRecordState
    csv?: string | null
    sentAt?: Date | string | null
    retryCount?: number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerifactuRecordUncheckedCreateWithoutInvoiceInput = {
    id?: string
    hash: string
    prevHash?: string | null
    xmlContent: string
    state?: $Enums.VerifactuRecordState
    csv?: string | null
    sentAt?: Date | string | null
    retryCount?: number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerifactuRecordCreateOrConnectWithoutInvoiceInput = {
    where: VerifactuRecordWhereUniqueInput
    create: XOR<VerifactuRecordCreateWithoutInvoiceInput, VerifactuRecordUncheckedCreateWithoutInvoiceInput>
  }

  export type VerifactuRecordCreateManyInvoiceInputEnvelope = {
    data: VerifactuRecordCreateManyInvoiceInput | VerifactuRecordCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutInvoicesInput = {
    update: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type CompanyUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type InvoiceSeriesUpsertWithoutInvoicesInput = {
    update: XOR<InvoiceSeriesUpdateWithoutInvoicesInput, InvoiceSeriesUncheckedUpdateWithoutInvoicesInput>
    create: XOR<InvoiceSeriesCreateWithoutInvoicesInput, InvoiceSeriesUncheckedCreateWithoutInvoicesInput>
    where?: InvoiceSeriesWhereInput
  }

  export type InvoiceSeriesUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: InvoiceSeriesWhereInput
    data: XOR<InvoiceSeriesUpdateWithoutInvoicesInput, InvoiceSeriesUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceSeriesUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoiceSeriesNestedInput
  }

  export type InvoiceSeriesUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpsertWithoutInvoicesInput = {
    update: XOR<ContactUpdateWithoutInvoicesInput, ContactUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ContactCreateWithoutInvoicesInput, ContactUncheckedCreateWithoutInvoicesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutInvoicesInput, ContactUncheckedUpdateWithoutInvoicesInput>
  }

  export type ContactUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceLineScalarWhereInput = {
    AND?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    OR?: InvoiceLineScalarWhereInput[]
    NOT?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    id?: UuidFilter<"InvoiceLine"> | string
    invoiceId?: UuidFilter<"InvoiceLine"> | string
    lineNumber?: IntFilter<"InvoiceLine"> | number
    description?: StringFilter<"InvoiceLine"> | string
    quantity?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    accountCode?: StringNullableFilter<"InvoiceLine"> | string | null
  }

  export type InvoiceTaxUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceTaxWhereUniqueInput
    update: XOR<InvoiceTaxUpdateWithoutInvoiceInput, InvoiceTaxUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceTaxCreateWithoutInvoiceInput, InvoiceTaxUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceTaxUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceTaxWhereUniqueInput
    data: XOR<InvoiceTaxUpdateWithoutInvoiceInput, InvoiceTaxUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceTaxUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceTaxScalarWhereInput
    data: XOR<InvoiceTaxUpdateManyMutationInput, InvoiceTaxUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceTaxScalarWhereInput = {
    AND?: InvoiceTaxScalarWhereInput | InvoiceTaxScalarWhereInput[]
    OR?: InvoiceTaxScalarWhereInput[]
    NOT?: InvoiceTaxScalarWhereInput | InvoiceTaxScalarWhereInput[]
    id?: UuidFilter<"InvoiceTax"> | string
    invoiceId?: UuidFilter<"InvoiceTax"> | string
    taxRate?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceTax"> | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFilter<"InvoiceTax"> | $Enums.TaxType
  }

  export type VerifactuRecordUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: VerifactuRecordWhereUniqueInput
    update: XOR<VerifactuRecordUpdateWithoutInvoiceInput, VerifactuRecordUncheckedUpdateWithoutInvoiceInput>
    create: XOR<VerifactuRecordCreateWithoutInvoiceInput, VerifactuRecordUncheckedCreateWithoutInvoiceInput>
  }

  export type VerifactuRecordUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: VerifactuRecordWhereUniqueInput
    data: XOR<VerifactuRecordUpdateWithoutInvoiceInput, VerifactuRecordUncheckedUpdateWithoutInvoiceInput>
  }

  export type VerifactuRecordUpdateManyWithWhereWithoutInvoiceInput = {
    where: VerifactuRecordScalarWhereInput
    data: XOR<VerifactuRecordUpdateManyMutationInput, VerifactuRecordUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type VerifactuRecordScalarWhereInput = {
    AND?: VerifactuRecordScalarWhereInput | VerifactuRecordScalarWhereInput[]
    OR?: VerifactuRecordScalarWhereInput[]
    NOT?: VerifactuRecordScalarWhereInput | VerifactuRecordScalarWhereInput[]
    id?: UuidFilter<"VerifactuRecord"> | string
    invoiceId?: UuidFilter<"VerifactuRecord"> | string
    hash?: StringFilter<"VerifactuRecord"> | string
    prevHash?: StringNullableFilter<"VerifactuRecord"> | string | null
    xmlContent?: StringFilter<"VerifactuRecord"> | string
    state?: EnumVerifactuRecordStateFilter<"VerifactuRecord"> | $Enums.VerifactuRecordState
    csv?: StringNullableFilter<"VerifactuRecord"> | string | null
    sentAt?: DateTimeNullableFilter<"VerifactuRecord"> | Date | string | null
    retryCount?: IntFilter<"VerifactuRecord"> | number
    aeatResponse?: JsonNullableFilter<"VerifactuRecord">
    createdAt?: DateTimeFilter<"VerifactuRecord"> | Date | string
    updatedAt?: DateTimeFilter<"VerifactuRecord"> | Date | string
  }

  export type InvoiceCreateWithoutLinesInput = {
    id?: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
    series: InvoiceSeriesCreateNestedOneWithoutInvoicesInput
    contact?: ContactCreateNestedOneWithoutInvoicesInput
    taxes?: InvoiceTaxCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    companyId: string
    seriesId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxes?: InvoiceTaxUncheckedCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLinesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
  }

  export type InvoiceUpsertWithoutLinesInput = {
    update: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    series?: InvoiceSeriesUpdateOneRequiredWithoutInvoicesNestedInput
    contact?: ContactUpdateOneWithoutInvoicesNestedInput
    taxes?: InvoiceTaxUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxes?: InvoiceTaxUncheckedUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutTaxesInput = {
    id?: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
    series: InvoiceSeriesCreateNestedOneWithoutInvoicesInput
    contact?: ContactCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTaxesInput = {
    id?: string
    companyId: string
    seriesId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    verifactuRecords?: VerifactuRecordUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTaxesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTaxesInput, InvoiceUncheckedCreateWithoutTaxesInput>
  }

  export type InvoiceUpsertWithoutTaxesInput = {
    update: XOR<InvoiceUpdateWithoutTaxesInput, InvoiceUncheckedUpdateWithoutTaxesInput>
    create: XOR<InvoiceCreateWithoutTaxesInput, InvoiceUncheckedCreateWithoutTaxesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTaxesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTaxesInput, InvoiceUncheckedUpdateWithoutTaxesInput>
  }

  export type InvoiceUpdateWithoutTaxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    series?: InvoiceSeriesUpdateOneRequiredWithoutInvoicesNestedInput
    contact?: ContactUpdateOneWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTaxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CompanyCreateWithoutCryptoAssetsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCryptoAssetsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCryptoAssetsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCryptoAssetsInput, CompanyUncheckedCreateWithoutCryptoAssetsInput>
  }

  export type AccountCreateWithoutCryptoAssetInput = {
    id?: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAccountsInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCryptoAssetInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCryptoAssetInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCryptoAssetInput, AccountUncheckedCreateWithoutCryptoAssetInput>
  }

  export type AccountCreateManyCryptoAssetInputEnvelope = {
    data: AccountCreateManyCryptoAssetInput | AccountCreateManyCryptoAssetInput[]
    skipDuplicates?: boolean
  }

  export type CryptoLotCreateWithoutCryptoAssetInput = {
    id?: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCryptoLotsInput
  }

  export type CryptoLotUncheckedCreateWithoutCryptoAssetInput = {
    id?: string
    companyId: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoLotCreateOrConnectWithoutCryptoAssetInput = {
    where: CryptoLotWhereUniqueInput
    create: XOR<CryptoLotCreateWithoutCryptoAssetInput, CryptoLotUncheckedCreateWithoutCryptoAssetInput>
  }

  export type CryptoLotCreateManyCryptoAssetInputEnvelope = {
    data: CryptoLotCreateManyCryptoAssetInput | CryptoLotCreateManyCryptoAssetInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutCryptoAssetsInput = {
    update: XOR<CompanyUpdateWithoutCryptoAssetsInput, CompanyUncheckedUpdateWithoutCryptoAssetsInput>
    create: XOR<CompanyCreateWithoutCryptoAssetsInput, CompanyUncheckedCreateWithoutCryptoAssetsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCryptoAssetsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCryptoAssetsInput, CompanyUncheckedUpdateWithoutCryptoAssetsInput>
  }

  export type CompanyUpdateWithoutCryptoAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCryptoAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutCryptoAssetInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutCryptoAssetInput, AccountUncheckedUpdateWithoutCryptoAssetInput>
    create: XOR<AccountCreateWithoutCryptoAssetInput, AccountUncheckedCreateWithoutCryptoAssetInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutCryptoAssetInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutCryptoAssetInput, AccountUncheckedUpdateWithoutCryptoAssetInput>
  }

  export type AccountUpdateManyWithWhereWithoutCryptoAssetInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutCryptoAssetInput>
  }

  export type CryptoLotUpsertWithWhereUniqueWithoutCryptoAssetInput = {
    where: CryptoLotWhereUniqueInput
    update: XOR<CryptoLotUpdateWithoutCryptoAssetInput, CryptoLotUncheckedUpdateWithoutCryptoAssetInput>
    create: XOR<CryptoLotCreateWithoutCryptoAssetInput, CryptoLotUncheckedCreateWithoutCryptoAssetInput>
  }

  export type CryptoLotUpdateWithWhereUniqueWithoutCryptoAssetInput = {
    where: CryptoLotWhereUniqueInput
    data: XOR<CryptoLotUpdateWithoutCryptoAssetInput, CryptoLotUncheckedUpdateWithoutCryptoAssetInput>
  }

  export type CryptoLotUpdateManyWithWhereWithoutCryptoAssetInput = {
    where: CryptoLotScalarWhereInput
    data: XOR<CryptoLotUpdateManyMutationInput, CryptoLotUncheckedUpdateManyWithoutCryptoAssetInput>
  }

  export type CompanyCreateWithoutWalletsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWalletsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWalletsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWalletsInput, CompanyUncheckedCreateWithoutWalletsInput>
  }

  export type CryptoTransactionCreateWithoutWalletInput = {
    id?: string
    txHash: string
    blockNumber: bigint | number
    blockTimestamp: Date | string
    chain: string
    type: $Enums.CryptoTxType
    subtype?: string | null
    assetIn?: string | null
    amountIn?: Decimal | DecimalJsLike | number | string | null
    assetOut?: string | null
    amountOut?: Decimal | DecimalJsLike | number | string | null
    feeAsset?: string | null
    feeAmount?: Decimal | DecimalJsLike | number | string | null
    priceInEur?: Decimal | DecimalJsLike | number | string | null
    priceOutEur?: Decimal | DecimalJsLike | number | string | null
    feeEur?: Decimal | DecimalJsLike | number | string | null
    costBasis?: Decimal | DecimalJsLike | number | string | null
    realizedGain?: Decimal | DecimalJsLike | number | string | null
    aiCategorized?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiReasoning?: string | null
    manualType?: $Enums.CryptoTxType | null
    manualNotes?: string | null
    journalEntryId?: string | null
    status?: $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoTransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    txHash: string
    blockNumber: bigint | number
    blockTimestamp: Date | string
    chain: string
    type: $Enums.CryptoTxType
    subtype?: string | null
    assetIn?: string | null
    amountIn?: Decimal | DecimalJsLike | number | string | null
    assetOut?: string | null
    amountOut?: Decimal | DecimalJsLike | number | string | null
    feeAsset?: string | null
    feeAmount?: Decimal | DecimalJsLike | number | string | null
    priceInEur?: Decimal | DecimalJsLike | number | string | null
    priceOutEur?: Decimal | DecimalJsLike | number | string | null
    feeEur?: Decimal | DecimalJsLike | number | string | null
    costBasis?: Decimal | DecimalJsLike | number | string | null
    realizedGain?: Decimal | DecimalJsLike | number | string | null
    aiCategorized?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiReasoning?: string | null
    manualType?: $Enums.CryptoTxType | null
    manualNotes?: string | null
    journalEntryId?: string | null
    status?: $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoTransactionCreateOrConnectWithoutWalletInput = {
    where: CryptoTransactionWhereUniqueInput
    create: XOR<CryptoTransactionCreateWithoutWalletInput, CryptoTransactionUncheckedCreateWithoutWalletInput>
  }

  export type CryptoTransactionCreateManyWalletInputEnvelope = {
    data: CryptoTransactionCreateManyWalletInput | CryptoTransactionCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutWalletsInput = {
    update: XOR<CompanyUpdateWithoutWalletsInput, CompanyUncheckedUpdateWithoutWalletsInput>
    create: XOR<CompanyCreateWithoutWalletsInput, CompanyUncheckedCreateWithoutWalletsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWalletsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWalletsInput, CompanyUncheckedUpdateWithoutWalletsInput>
  }

  export type CompanyUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CryptoTransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: CryptoTransactionWhereUniqueInput
    update: XOR<CryptoTransactionUpdateWithoutWalletInput, CryptoTransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<CryptoTransactionCreateWithoutWalletInput, CryptoTransactionUncheckedCreateWithoutWalletInput>
  }

  export type CryptoTransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: CryptoTransactionWhereUniqueInput
    data: XOR<CryptoTransactionUpdateWithoutWalletInput, CryptoTransactionUncheckedUpdateWithoutWalletInput>
  }

  export type CryptoTransactionUpdateManyWithWhereWithoutWalletInput = {
    where: CryptoTransactionScalarWhereInput
    data: XOR<CryptoTransactionUpdateManyMutationInput, CryptoTransactionUncheckedUpdateManyWithoutWalletInput>
  }

  export type CryptoTransactionScalarWhereInput = {
    AND?: CryptoTransactionScalarWhereInput | CryptoTransactionScalarWhereInput[]
    OR?: CryptoTransactionScalarWhereInput[]
    NOT?: CryptoTransactionScalarWhereInput | CryptoTransactionScalarWhereInput[]
    id?: UuidFilter<"CryptoTransaction"> | string
    walletId?: UuidFilter<"CryptoTransaction"> | string
    txHash?: StringFilter<"CryptoTransaction"> | string
    blockNumber?: BigIntFilter<"CryptoTransaction"> | bigint | number
    blockTimestamp?: DateTimeFilter<"CryptoTransaction"> | Date | string
    chain?: StringFilter<"CryptoTransaction"> | string
    type?: EnumCryptoTxTypeFilter<"CryptoTransaction"> | $Enums.CryptoTxType
    subtype?: StringNullableFilter<"CryptoTransaction"> | string | null
    assetIn?: StringNullableFilter<"CryptoTransaction"> | string | null
    amountIn?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    assetOut?: StringNullableFilter<"CryptoTransaction"> | string | null
    amountOut?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeAsset?: StringNullableFilter<"CryptoTransaction"> | string | null
    feeAmount?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceInEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    feeEur?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    costBasis?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    realizedGain?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFilter<"CryptoTransaction"> | boolean
    aiConfidence?: DecimalNullableFilter<"CryptoTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: StringNullableFilter<"CryptoTransaction"> | string | null
    manualType?: EnumCryptoTxTypeNullableFilter<"CryptoTransaction"> | $Enums.CryptoTxType | null
    manualNotes?: StringNullableFilter<"CryptoTransaction"> | string | null
    journalEntryId?: UuidNullableFilter<"CryptoTransaction"> | string | null
    status?: EnumTxStatusFilter<"CryptoTransaction"> | $Enums.TxStatus
    rawData?: JsonNullableFilter<"CryptoTransaction">
    createdAt?: DateTimeFilter<"CryptoTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoTransaction"> | Date | string
  }

  export type CompanyCreateWithoutExchangeAccountsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutExchangeAccountsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutExchangeAccountsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutExchangeAccountsInput, CompanyUncheckedCreateWithoutExchangeAccountsInput>
  }

  export type CompanyUpsertWithoutExchangeAccountsInput = {
    update: XOR<CompanyUpdateWithoutExchangeAccountsInput, CompanyUncheckedUpdateWithoutExchangeAccountsInput>
    create: XOR<CompanyCreateWithoutExchangeAccountsInput, CompanyUncheckedCreateWithoutExchangeAccountsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutExchangeAccountsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutExchangeAccountsInput, CompanyUncheckedUpdateWithoutExchangeAccountsInput>
  }

  export type CompanyUpdateWithoutExchangeAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutExchangeAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WalletCreateWithoutTransactionsInput = {
    id?: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutWalletsInput
  }

  export type WalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    companyId: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutTransactionsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
  }

  export type WalletUpsertWithoutTransactionsInput = {
    update: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type WalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWalletsNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutCryptoLotsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCryptoLotsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCryptoLotsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCryptoLotsInput, CompanyUncheckedCreateWithoutCryptoLotsInput>
  }

  export type CryptoAssetCreateWithoutLotsInput = {
    id?: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCryptoAssetsInput
    accounts?: AccountCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetUncheckedCreateWithoutLotsInput = {
    id?: string
    companyId: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutCryptoAssetInput
  }

  export type CryptoAssetCreateOrConnectWithoutLotsInput = {
    where: CryptoAssetWhereUniqueInput
    create: XOR<CryptoAssetCreateWithoutLotsInput, CryptoAssetUncheckedCreateWithoutLotsInput>
  }

  export type CompanyUpsertWithoutCryptoLotsInput = {
    update: XOR<CompanyUpdateWithoutCryptoLotsInput, CompanyUncheckedUpdateWithoutCryptoLotsInput>
    create: XOR<CompanyCreateWithoutCryptoLotsInput, CompanyUncheckedCreateWithoutCryptoLotsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCryptoLotsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCryptoLotsInput, CompanyUncheckedUpdateWithoutCryptoLotsInput>
  }

  export type CompanyUpdateWithoutCryptoLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCryptoLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CryptoAssetUpsertWithoutLotsInput = {
    update: XOR<CryptoAssetUpdateWithoutLotsInput, CryptoAssetUncheckedUpdateWithoutLotsInput>
    create: XOR<CryptoAssetCreateWithoutLotsInput, CryptoAssetUncheckedCreateWithoutLotsInput>
    where?: CryptoAssetWhereInput
  }

  export type CryptoAssetUpdateToOneWithWhereWithoutLotsInput = {
    where?: CryptoAssetWhereInput
    data: XOR<CryptoAssetUpdateWithoutLotsInput, CryptoAssetUncheckedUpdateWithoutLotsInput>
  }

  export type CryptoAssetUpdateWithoutLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCryptoAssetsNestedInput
    accounts?: AccountUpdateManyWithoutCryptoAssetNestedInput
  }

  export type CryptoAssetUncheckedUpdateWithoutLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutCryptoAssetNestedInput
  }

  export type InvoiceCreateWithoutVerifactuRecordsInput = {
    id?: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
    series: InvoiceSeriesCreateNestedOneWithoutInvoicesInput
    contact?: ContactCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutVerifactuRecordsInput = {
    id?: string
    companyId: string
    seriesId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    taxes?: InvoiceTaxUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutVerifactuRecordsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutVerifactuRecordsInput, InvoiceUncheckedCreateWithoutVerifactuRecordsInput>
  }

  export type InvoiceUpsertWithoutVerifactuRecordsInput = {
    update: XOR<InvoiceUpdateWithoutVerifactuRecordsInput, InvoiceUncheckedUpdateWithoutVerifactuRecordsInput>
    create: XOR<InvoiceCreateWithoutVerifactuRecordsInput, InvoiceUncheckedCreateWithoutVerifactuRecordsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutVerifactuRecordsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutVerifactuRecordsInput, InvoiceUncheckedUpdateWithoutVerifactuRecordsInput>
  }

  export type InvoiceUpdateWithoutVerifactuRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    series?: InvoiceSeriesUpdateOneRequiredWithoutInvoicesNestedInput
    contact?: ContactUpdateOneWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutVerifactuRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CompanyCreateWithoutAiConversationsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAiConversationsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAiConversationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAiConversationsInput, CompanyUncheckedCreateWithoutAiConversationsInput>
  }

  export type UserCreateWithoutAiConversationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiConversationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
  }

  export type AiMessageCreateWithoutConversationInput = {
    id?: string
    role: $Enums.AiRole
    content: string
    inputTokens?: number | null
    outputTokens?: number | null
    provider?: string | null
    model?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type AiMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: $Enums.AiRole
    content: string
    inputTokens?: number | null
    outputTokens?: number | null
    provider?: string | null
    model?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type AiMessageCreateOrConnectWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    create: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput>
  }

  export type AiMessageCreateManyConversationInputEnvelope = {
    data: AiMessageCreateManyConversationInput | AiMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutAiConversationsInput = {
    update: XOR<CompanyUpdateWithoutAiConversationsInput, CompanyUncheckedUpdateWithoutAiConversationsInput>
    create: XOR<CompanyCreateWithoutAiConversationsInput, CompanyUncheckedCreateWithoutAiConversationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAiConversationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAiConversationsInput, CompanyUncheckedUpdateWithoutAiConversationsInput>
  }

  export type CompanyUpdateWithoutAiConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAiConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutAiConversationsInput = {
    update: XOR<UserUpdateWithoutAiConversationsInput, UserUncheckedUpdateWithoutAiConversationsInput>
    create: XOR<UserCreateWithoutAiConversationsInput, UserUncheckedCreateWithoutAiConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiConversationsInput, UserUncheckedUpdateWithoutAiConversationsInput>
  }

  export type UserUpdateWithoutAiConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AiMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    update: XOR<AiMessageUpdateWithoutConversationInput, AiMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<AiMessageCreateWithoutConversationInput, AiMessageUncheckedCreateWithoutConversationInput>
  }

  export type AiMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: AiMessageWhereUniqueInput
    data: XOR<AiMessageUpdateWithoutConversationInput, AiMessageUncheckedUpdateWithoutConversationInput>
  }

  export type AiMessageUpdateManyWithWhereWithoutConversationInput = {
    where: AiMessageScalarWhereInput
    data: XOR<AiMessageUpdateManyMutationInput, AiMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type AiMessageScalarWhereInput = {
    AND?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
    OR?: AiMessageScalarWhereInput[]
    NOT?: AiMessageScalarWhereInput | AiMessageScalarWhereInput[]
    id?: UuidFilter<"AiMessage"> | string
    conversationId?: UuidFilter<"AiMessage"> | string
    role?: EnumAiRoleFilter<"AiMessage"> | $Enums.AiRole
    content?: StringFilter<"AiMessage"> | string
    inputTokens?: IntNullableFilter<"AiMessage"> | number | null
    outputTokens?: IntNullableFilter<"AiMessage"> | number | null
    provider?: StringNullableFilter<"AiMessage"> | string | null
    model?: StringNullableFilter<"AiMessage"> | string | null
    latencyMs?: IntNullableFilter<"AiMessage"> | number | null
    createdAt?: DateTimeFilter<"AiMessage"> | Date | string
  }

  export type AiConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAiConversationsInput
    user: UserCreateNestedOneWithoutAiConversationsInput
  }

  export type AiConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    companyId: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationCreateOrConnectWithoutMessagesInput = {
    where: AiConversationWhereUniqueInput
    create: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
  }

  export type AiConversationUpsertWithoutMessagesInput = {
    update: XOR<AiConversationUpdateWithoutMessagesInput, AiConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<AiConversationCreateWithoutMessagesInput, AiConversationUncheckedCreateWithoutMessagesInput>
    where?: AiConversationWhereInput
  }

  export type AiConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AiConversationWhereInput
    data: XOR<AiConversationUpdateWithoutMessagesInput, AiConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type AiConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAiConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutAiConversationsNestedInput
  }

  export type AiConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutDocumentsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDocumentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
  }

  export type CompanyUpsertWithoutDocumentsInput = {
    update: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutInvitationsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvitationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutInvitationsSentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsSentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
  }

  export type UserCreateWithoutInvitationsAcceptedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsAcceptedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsAcceptedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
  }

  export type CompanyUpsertWithoutInvitationsInput = {
    update: XOR<CompanyUpdateWithoutInvitationsInput, CompanyUncheckedUpdateWithoutInvitationsInput>
    create: XOR<CompanyCreateWithoutInvitationsInput, CompanyUncheckedCreateWithoutInvitationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvitationsInput, CompanyUncheckedUpdateWithoutInvitationsInput>
  }

  export type CompanyUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutInvitationsSentInput = {
    update: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutInvitationsAcceptedInput = {
    update: XOR<UserUpdateWithoutInvitationsAcceptedInput, UserUncheckedUpdateWithoutInvitationsAcceptedInput>
    create: XOR<UserCreateWithoutInvitationsAcceptedInput, UserUncheckedCreateWithoutInvitationsAcceptedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsAcceptedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsAcceptedInput, UserUncheckedUpdateWithoutInvitationsAcceptedInput>
  }

  export type UserUpdateWithoutInvitationsAcceptedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsAcceptedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutAnalyticsEventsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAnalyticsEventsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAnalyticsEventsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAnalyticsEventsInput, CompanyUncheckedCreateWithoutAnalyticsEventsInput>
  }

  export type UserCreateWithoutAnalyticsEventsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsEventsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
  }

  export type CompanyUpsertWithoutAnalyticsEventsInput = {
    update: XOR<CompanyUpdateWithoutAnalyticsEventsInput, CompanyUncheckedUpdateWithoutAnalyticsEventsInput>
    create: XOR<CompanyCreateWithoutAnalyticsEventsInput, CompanyUncheckedCreateWithoutAnalyticsEventsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAnalyticsEventsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAnalyticsEventsInput, CompanyUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type CompanyUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutAnalyticsEventsInput = {
    update: XOR<UserUpdateWithoutAnalyticsEventsInput, UserUncheckedUpdateWithoutAnalyticsEventsInput>
    create: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsEventsInput, UserUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type UserUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutOauthAppsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutOauthAppsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutOauthAppsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutOauthAppsInput, CompanyUncheckedCreateWithoutOauthAppsInput>
  }

  export type UserCreateWithoutOauthAppsCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthAppsCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthAppsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthAppsCreatedInput, UserUncheckedCreateWithoutOauthAppsCreatedInput>
  }

  export type OAuthTokenCreateWithoutAppInput = {
    id?: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    user: UserCreateNestedOneWithoutOauthTokensInput
    company: CompanyCreateNestedOneWithoutOauthTokensInput
  }

  export type OAuthTokenUncheckedCreateWithoutAppInput = {
    id?: string
    userId: string
    companyId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type OAuthTokenCreateOrConnectWithoutAppInput = {
    where: OAuthTokenWhereUniqueInput
    create: XOR<OAuthTokenCreateWithoutAppInput, OAuthTokenUncheckedCreateWithoutAppInput>
  }

  export type OAuthTokenCreateManyAppInputEnvelope = {
    data: OAuthTokenCreateManyAppInput | OAuthTokenCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type ApiUsageCreateWithoutAppInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    company: CompanyCreateNestedOneWithoutApiUsageInput
    user?: UserCreateNestedOneWithoutApiUsageInput
  }

  export type ApiUsageUncheckedCreateWithoutAppInput = {
    id?: string
    companyId: string
    userId?: string | null
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ApiUsageCreateOrConnectWithoutAppInput = {
    where: ApiUsageWhereUniqueInput
    create: XOR<ApiUsageCreateWithoutAppInput, ApiUsageUncheckedCreateWithoutAppInput>
  }

  export type ApiUsageCreateManyAppInputEnvelope = {
    data: ApiUsageCreateManyAppInput | ApiUsageCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutOauthAppsInput = {
    update: XOR<CompanyUpdateWithoutOauthAppsInput, CompanyUncheckedUpdateWithoutOauthAppsInput>
    create: XOR<CompanyCreateWithoutOauthAppsInput, CompanyUncheckedCreateWithoutOauthAppsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutOauthAppsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutOauthAppsInput, CompanyUncheckedUpdateWithoutOauthAppsInput>
  }

  export type CompanyUpdateWithoutOauthAppsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutOauthAppsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutOauthAppsCreatedInput = {
    update: XOR<UserUpdateWithoutOauthAppsCreatedInput, UserUncheckedUpdateWithoutOauthAppsCreatedInput>
    create: XOR<UserCreateWithoutOauthAppsCreatedInput, UserUncheckedCreateWithoutOauthAppsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthAppsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthAppsCreatedInput, UserUncheckedUpdateWithoutOauthAppsCreatedInput>
  }

  export type UserUpdateWithoutOauthAppsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthAppsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OAuthTokenUpsertWithWhereUniqueWithoutAppInput = {
    where: OAuthTokenWhereUniqueInput
    update: XOR<OAuthTokenUpdateWithoutAppInput, OAuthTokenUncheckedUpdateWithoutAppInput>
    create: XOR<OAuthTokenCreateWithoutAppInput, OAuthTokenUncheckedCreateWithoutAppInput>
  }

  export type OAuthTokenUpdateWithWhereUniqueWithoutAppInput = {
    where: OAuthTokenWhereUniqueInput
    data: XOR<OAuthTokenUpdateWithoutAppInput, OAuthTokenUncheckedUpdateWithoutAppInput>
  }

  export type OAuthTokenUpdateManyWithWhereWithoutAppInput = {
    where: OAuthTokenScalarWhereInput
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyWithoutAppInput>
  }

  export type ApiUsageUpsertWithWhereUniqueWithoutAppInput = {
    where: ApiUsageWhereUniqueInput
    update: XOR<ApiUsageUpdateWithoutAppInput, ApiUsageUncheckedUpdateWithoutAppInput>
    create: XOR<ApiUsageCreateWithoutAppInput, ApiUsageUncheckedCreateWithoutAppInput>
  }

  export type ApiUsageUpdateWithWhereUniqueWithoutAppInput = {
    where: ApiUsageWhereUniqueInput
    data: XOR<ApiUsageUpdateWithoutAppInput, ApiUsageUncheckedUpdateWithoutAppInput>
  }

  export type ApiUsageUpdateManyWithWhereWithoutAppInput = {
    where: ApiUsageScalarWhereInput
    data: XOR<ApiUsageUpdateManyMutationInput, ApiUsageUncheckedUpdateManyWithoutAppInput>
  }

  export type OAuthAppCreateWithoutTokensInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutOauthAppsInput
    createdBy: UserCreateNestedOneWithoutOauthAppsCreatedInput
    apiUsage?: ApiUsageCreateNestedManyWithoutAppInput
  }

  export type OAuthAppUncheckedCreateWithoutTokensInput = {
    id?: string
    companyId: string
    createdById: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutAppInput
  }

  export type OAuthAppCreateOrConnectWithoutTokensInput = {
    where: OAuthAppWhereUniqueInput
    create: XOR<OAuthAppCreateWithoutTokensInput, OAuthAppUncheckedCreateWithoutTokensInput>
  }

  export type UserCreateWithoutOauthTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
  }

  export type CompanyCreateWithoutOauthTokensInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutOauthTokensInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutOauthTokensInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutOauthTokensInput, CompanyUncheckedCreateWithoutOauthTokensInput>
  }

  export type OAuthAppUpsertWithoutTokensInput = {
    update: XOR<OAuthAppUpdateWithoutTokensInput, OAuthAppUncheckedUpdateWithoutTokensInput>
    create: XOR<OAuthAppCreateWithoutTokensInput, OAuthAppUncheckedCreateWithoutTokensInput>
    where?: OAuthAppWhereInput
  }

  export type OAuthAppUpdateToOneWithWhereWithoutTokensInput = {
    where?: OAuthAppWhereInput
    data: XOR<OAuthAppUpdateWithoutTokensInput, OAuthAppUncheckedUpdateWithoutTokensInput>
  }

  export type OAuthAppUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutOauthAppsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOauthAppsCreatedNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutAppNestedInput
  }

  export type UserUpsertWithoutOauthTokensInput = {
    update: XOR<UserUpdateWithoutOauthTokensInput, UserUncheckedUpdateWithoutOauthTokensInput>
    create: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthTokensInput, UserUncheckedUpdateWithoutOauthTokensInput>
  }

  export type UserUpdateWithoutOauthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutOauthTokensInput = {
    update: XOR<CompanyUpdateWithoutOauthTokensInput, CompanyUncheckedUpdateWithoutOauthTokensInput>
    create: XOR<CompanyCreateWithoutOauthTokensInput, CompanyUncheckedCreateWithoutOauthTokensInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutOauthTokensInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutOauthTokensInput, CompanyUncheckedUpdateWithoutOauthTokensInput>
  }

  export type CompanyUpdateWithoutOauthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutOauthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type OAuthAppCreateWithoutApiUsageInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutOauthAppsInput
    createdBy: UserCreateNestedOneWithoutOauthAppsCreatedInput
    tokens?: OAuthTokenCreateNestedManyWithoutAppInput
  }

  export type OAuthAppUncheckedCreateWithoutApiUsageInput = {
    id?: string
    companyId: string
    createdById: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: OAuthTokenUncheckedCreateNestedManyWithoutAppInput
  }

  export type OAuthAppCreateOrConnectWithoutApiUsageInput = {
    where: OAuthAppWhereUniqueInput
    create: XOR<OAuthAppCreateWithoutApiUsageInput, OAuthAppUncheckedCreateWithoutApiUsageInput>
  }

  export type CompanyCreateWithoutApiUsageInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutApiUsageInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutApiUsageInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutApiUsageInput, CompanyUncheckedCreateWithoutApiUsageInput>
  }

  export type UserCreateWithoutApiUsageInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiUsageInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>
  }

  export type OAuthAppUpsertWithoutApiUsageInput = {
    update: XOR<OAuthAppUpdateWithoutApiUsageInput, OAuthAppUncheckedUpdateWithoutApiUsageInput>
    create: XOR<OAuthAppCreateWithoutApiUsageInput, OAuthAppUncheckedCreateWithoutApiUsageInput>
    where?: OAuthAppWhereInput
  }

  export type OAuthAppUpdateToOneWithWhereWithoutApiUsageInput = {
    where?: OAuthAppWhereInput
    data: XOR<OAuthAppUpdateWithoutApiUsageInput, OAuthAppUncheckedUpdateWithoutApiUsageInput>
  }

  export type OAuthAppUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutOauthAppsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOauthAppsCreatedNestedInput
    tokens?: OAuthTokenUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppUncheckedUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: OAuthTokenUncheckedUpdateManyWithoutAppNestedInput
  }

  export type CompanyUpsertWithoutApiUsageInput = {
    update: XOR<CompanyUpdateWithoutApiUsageInput, CompanyUncheckedUpdateWithoutApiUsageInput>
    create: XOR<CompanyCreateWithoutApiUsageInput, CompanyUncheckedCreateWithoutApiUsageInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutApiUsageInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutApiUsageInput, CompanyUncheckedUpdateWithoutApiUsageInput>
  }

  export type CompanyUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutApiUsageInput = {
    update: XOR<UserUpdateWithoutApiUsageInput, UserUncheckedUpdateWithoutApiUsageInput>
    create: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiUsageInput, UserUncheckedUpdateWithoutApiUsageInput>
  }

  export type UserUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    companyId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    companyId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: UuidFilter<"Subscription"> | string
    companyId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    invoicesThisMonth?: IntFilter<"Subscription"> | number
    aiMessagesThisMonth?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    stripePriceId?: string | null
    monthlyPrice?: Decimal | DecimalJsLike | number | string
    yearlyPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxCompanies?: number
    maxUsers?: number
    maxInvoicesPerMonth?: number
    maxWallets?: number
    maxAiMessagesPerMonth?: number
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    stripePriceId?: string | null
    monthlyPrice?: Decimal | DecimalJsLike | number | string
    yearlyPrice?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxCompanies?: number
    maxUsers?: number
    maxInvoicesPerMonth?: number
    maxWallets?: number
    maxAiMessagesPerMonth?: number
    verifactuEnabled?: boolean
    siiEnabled?: boolean
    aiChatEnabled?: boolean
    aiOcrEnabled?: boolean
    cryptoEnabled?: boolean
    multiUserEnabled?: boolean
    prioritySupport?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentCreateWithoutSubscriptionInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    description?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    description?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateManySubscriptionInputEnvelope = {
    data: PaymentCreateManySubscriptionInput | PaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxCompanies?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxInvoicesPerMonth?: IntFieldUpdateOperationsInput | number
    maxWallets?: IntFieldUpdateOperationsInput | number
    maxAiMessagesPerMonth?: IntFieldUpdateOperationsInput | number
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    siiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiChatEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiOcrEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoEnabled?: BoolFieldUpdateOperationsInput | boolean
    multiUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yearlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxCompanies?: IntFieldUpdateOperationsInput | number
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxInvoicesPerMonth?: IntFieldUpdateOperationsInput | number
    maxWallets?: IntFieldUpdateOperationsInput | number
    maxAiMessagesPerMonth?: IntFieldUpdateOperationsInput | number
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    siiEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiChatEnabled?: BoolFieldUpdateOperationsInput | boolean
    aiOcrEnabled?: BoolFieldUpdateOperationsInput | boolean
    cryptoEnabled?: BoolFieldUpdateOperationsInput | boolean
    multiUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    prioritySupport?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    subscriptionId?: UuidFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    id?: string
    companyId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    companyId: string
    planId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutOnboardingInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOnboardingInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    ssoProvider?: string | null
    ssoId?: string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: CompanyInvitationUncheckedCreateNestedManyWithoutInviterInput
    invitationsAccepted?: CompanyInvitationUncheckedCreateNestedManyWithoutAcceptedUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    oauthAppsCreated?: OAuthAppUncheckedCreateNestedManyWithoutCreatedByInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOnboardingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
  }

  export type UserUpsertWithoutOnboardingInput = {
    update: XOR<UserUpdateWithoutOnboardingInput, UserUncheckedUpdateWithoutOnboardingInput>
    create: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnboardingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnboardingInput, UserUncheckedUpdateWithoutOnboardingInput>
  }

  export type UserUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoId?: NullableStringFieldUpdateOperationsInput | string | null
    ssoMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: CompanyInvitationUncheckedUpdateManyWithoutInviterNestedInput
    invitationsAccepted?: CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    oauthAppsCreated?: OAuthAppUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutWebhookSubscriptionsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearCreateNestedManyWithoutCompanyInput
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    wallets?: WalletCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWebhookSubscriptionsInput = {
    id?: string
    name: string
    legalName?: string | null
    taxId: string
    taxIdType?: $Enums.TaxIdType
    address?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    country?: string
    region?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    currency?: string
    fiscalYearStart?: number
    logo?: string | null
    verifactuEnabled?: boolean
    verifactuId?: string | null
    verifactuLastHash?: string | null
    defaultCryptoClassification?: $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    companyUsers?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    fiscalYears?: FiscalYearUncheckedCreateNestedManyWithoutCompanyInput
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoiceSeries?: InvoiceSeriesUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    wallets?: WalletUncheckedCreateNestedManyWithoutCompanyInput
    cryptoAssets?: CryptoAssetUncheckedCreateNestedManyWithoutCompanyInput
    cryptoLots?: CryptoLotUncheckedCreateNestedManyWithoutCompanyInput
    exchangeAccounts?: ExchangeAccountUncheckedCreateNestedManyWithoutCompanyInput
    aiConversations?: AiConversationUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    invitations?: CompanyInvitationUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutCompanyInput
    oauthApps?: OAuthAppUncheckedCreateNestedManyWithoutCompanyInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutCompanyInput
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWebhookSubscriptionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWebhookSubscriptionsInput, CompanyUncheckedCreateWithoutWebhookSubscriptionsInput>
  }

  export type WebhookDeliveryCreateWithoutSubscriptionInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    payloadHash: string
    status?: $Enums.WebhookDeliveryStatus
    attemptCount?: number
    maxAttempts?: number
    responseStatus?: number | null
    responseBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    scheduledFor?: Date | string
    lastAttemptAt?: Date | string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookDeliveryUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    payloadHash: string
    status?: $Enums.WebhookDeliveryStatus
    attemptCount?: number
    maxAttempts?: number
    responseStatus?: number | null
    responseBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    scheduledFor?: Date | string
    lastAttemptAt?: Date | string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookDeliveryCreateOrConnectWithoutSubscriptionInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutSubscriptionInput, WebhookDeliveryUncheckedCreateWithoutSubscriptionInput>
  }

  export type WebhookDeliveryCreateManySubscriptionInputEnvelope = {
    data: WebhookDeliveryCreateManySubscriptionInput | WebhookDeliveryCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutWebhookSubscriptionsInput = {
    update: XOR<CompanyUpdateWithoutWebhookSubscriptionsInput, CompanyUncheckedUpdateWithoutWebhookSubscriptionsInput>
    create: XOR<CompanyCreateWithoutWebhookSubscriptionsInput, CompanyUncheckedCreateWithoutWebhookSubscriptionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWebhookSubscriptionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWebhookSubscriptionsInput, CompanyUncheckedUpdateWithoutWebhookSubscriptionsInput>
  }

  export type CompanyUpdateWithoutWebhookSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWebhookSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: StringFieldUpdateOperationsInput | string
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuEnabled?: BoolFieldUpdateOperationsInput | boolean
    verifactuId?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuLastHash?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCryptoClassification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyUsers?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    fiscalYears?: FiscalYearUncheckedUpdateManyWithoutCompanyNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoiceSeries?: InvoiceSeriesUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoAssets?: CryptoAssetUncheckedUpdateManyWithoutCompanyNestedInput
    cryptoLots?: CryptoLotUncheckedUpdateManyWithoutCompanyNestedInput
    exchangeAccounts?: ExchangeAccountUncheckedUpdateManyWithoutCompanyNestedInput
    aiConversations?: AiConversationUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    invitations?: CompanyInvitationUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutCompanyNestedInput
    oauthApps?: OAuthAppUncheckedUpdateManyWithoutCompanyNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutCompanyNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutSubscriptionInput, WebhookDeliveryUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<WebhookDeliveryCreateWithoutSubscriptionInput, WebhookDeliveryUncheckedCreateWithoutSubscriptionInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutSubscriptionInput, WebhookDeliveryUncheckedUpdateWithoutSubscriptionInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutSubscriptionInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: UuidFilter<"WebhookDelivery"> | string
    subscriptionId?: UuidFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    payloadHash?: StringFilter<"WebhookDelivery"> | string
    status?: EnumWebhookDeliveryStatusFilter<"WebhookDelivery"> | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFilter<"WebhookDelivery"> | number
    maxAttempts?: IntFilter<"WebhookDelivery"> | number
    responseStatus?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    responseHeaders?: JsonNullableFilter<"WebhookDelivery">
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    scheduledFor?: DateTimeFilter<"WebhookDelivery"> | Date | string
    lastAttemptAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    nextAttemptAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookSubscriptionCreateWithoutDeliveriesInput = {
    id?: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutWebhookSubscriptionsInput
  }

  export type WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    companyId: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookSubscriptionCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookSubscriptionWhereUniqueInput
    create: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookSubscriptionUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookSubscriptionUpdateWithoutDeliveriesInput, WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookSubscriptionWhereInput
  }

  export type WebhookSubscriptionUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookSubscriptionWhereInput
    data: XOR<WebhookSubscriptionUpdateWithoutDeliveriesInput, WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookSubscriptionUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWebhookSubscriptionsNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserCreateManyUserInput = {
    id?: string
    companyId: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type AiConversationCreateManyUserInput = {
    id?: string
    companyId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationCreateManyInviterInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    companyId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationCreateManyAcceptedUserInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    companyId: string
    inviterId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    companyId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventCreateManyUserInput = {
    id?: string
    companyId?: string | null
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type OAuthAppCreateManyCreatedByInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthTokenCreateManyUserInput = {
    id?: string
    appId: string
    companyId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type ApiUsageCreateManyUserInput = {
    id?: string
    appId?: string | null
    companyId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type CompanyUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanyUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAiConversationsNestedInput
    messages?: AiMessageUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvitationsNestedInput
    acceptedUser?: UserUpdateOneWithoutInvitationsAcceptedNestedInput
  }

  export type CompanyInvitationUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    companyId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    companyId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUpdateWithoutAcceptedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
  }

  export type CompanyInvitationUncheckedUpdateWithoutAcceptedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    companyId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutAcceptedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    companyId?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutAnalyticsEventsNestedInput
  }

  export type AnalyticsEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAppUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutOauthAppsNestedInput
    tokens?: OAuthTokenUpdateManyWithoutAppNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: OAuthTokenUncheckedUpdateManyWithoutAppNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app?: OAuthAppUpdateOneRequiredWithoutTokensNestedInput
    company?: CompanyUpdateOneRequiredWithoutOauthTokensNestedInput
  }

  export type OAuthTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    app?: OAuthAppUpdateOneWithoutApiUsageNestedInput
    company?: CompanyUpdateOneRequiredWithoutApiUsageNestedInput
  }

  export type ApiUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyUserCreateManyCompanyInput = {
    id?: string
    userId: string
    role?: $Enums.UserRole
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type FiscalYearCreateManyCompanyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    cryptoAssetId?: string | null
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateManyCompanyInput = {
    id?: string
    fiscalYearId: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyCompanyInput = {
    id?: string
    seriesId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceSeriesCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    type: $Enums.InvoiceType
    prefix?: string | null
    suffix?: string | null
    nextNumber?: number
    digitCount?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyCompanyInput = {
    id?: string
    type?: $Enums.ContactType
    name: string
    legalName?: string | null
    taxId?: string | null
    taxIdType?: $Enums.TaxIdType | null
    address?: string | null
    city?: string | null
    postalCode?: string | null
    country?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletCreateManyCompanyInput = {
    id?: string
    address: string
    chain: string
    label?: string | null
    type?: $Enums.WalletType
    lastSyncAt?: Date | string | null
    lastSyncBlock?: bigint | number | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    accountCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoAssetCreateManyCompanyInput = {
    id?: string
    symbol: string
    name: string
    decimals?: number
    contractAddress?: string | null
    classification?: $Enums.CryptoClassification
    coingeckoId?: string | null
    lastPrice?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoLotCreateManyCompanyInput = {
    id?: string
    cryptoAssetId: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangeAccountCreateManyCompanyInput = {
    id?: string
    exchange: string
    label?: string | null
    apiKey?: string | null
    apiSecret?: string | null
    isReadOnly?: boolean
    lastSyncAt?: Date | string | null
    syncStatus?: $Enums.SyncStatus
    syncError?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiConversationCreateManyCompanyInput = {
    id?: string
    userId: string
    title?: string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCompanyInput = {
    id?: string
    title: string
    content: string
    type: $Enums.DocumentType
    sourceUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvitationCreateManyCompanyInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token?: string
    status?: $Enums.InvitationStatus
    inviterId: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: string
    userId: string
    action: $Enums.AuditAction
    entity: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WebhookSubscriptionCreateManyCompanyInput = {
    id?: string
    url: string
    secret: string
    isActive?: boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: number
    timeout?: number
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsEventCreateManyCompanyInput = {
    id?: string
    userId?: string | null
    eventType: string
    category: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type OAuthAppCreateManyCompanyInput = {
    id?: string
    createdById: string
    name: string
    description?: string | null
    logoUrl?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris?: OAuthAppCreateredirectUrisInput | string[]
    scopes?: OAuthAppCreatescopesInput | string[]
    rateLimit?: number
    dailyQuota?: number
    isActive?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthTokenCreateManyCompanyInput = {
    id?: string
    appId: string
    userId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type ApiUsageCreateManyCompanyInput = {
    id?: string
    appId?: string | null
    userId?: string | null
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type CompanyUserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompanyUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalEntries?: JournalEntryUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoAsset?: CryptoAssetUpdateOneWithoutAccountsNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    cryptoAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    cryptoAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: FiscalYearUpdateOneRequiredWithoutJournalEntriesNestedInput
    lines?: JournalLineUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiscalYearId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: JournalLineUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiscalYearId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: InvoiceSeriesUpdateOneRequiredWithoutInvoicesNestedInput
    contact?: ContactUpdateOneWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUncheckedUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceSeriesUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutSeriesNestedInput
  }

  export type InvoiceSeriesUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type InvoiceSeriesUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    nextNumber?: IntFieldUpdateOperationsInput | number
    digitCount?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxIdType?: NullableEnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CryptoTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CryptoTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypeFieldUpdateOperationsInput | $Enums.WalletType
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncBlock?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoAssetUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutCryptoAssetNestedInput
    lots?: CryptoLotUpdateManyWithoutCryptoAssetNestedInput
  }

  export type CryptoAssetUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutCryptoAssetNestedInput
    lots?: CryptoLotUncheckedUpdateManyWithoutCryptoAssetNestedInput
  }

  export type CryptoAssetUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: EnumCryptoClassificationFieldUpdateOperationsInput | $Enums.CryptoClassification
    coingeckoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoLotUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoAsset?: CryptoAssetUpdateOneRequiredWithoutLotsNestedInput
  }

  export type CryptoLotUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cryptoAssetId?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoLotUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cryptoAssetId?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeAccountUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isReadOnly?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeAccountUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isReadOnly?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeAccountUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchange?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    isReadOnly?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiConversationUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiConversationsNestedInput
    messages?: AiMessageUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AiMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AiConversationUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
    acceptedUser?: UserUpdateOneWithoutInvitationsAcceptedNestedInput
  }

  export type CompanyInvitationUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    inviterId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvitationUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    inviterId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookSubscriptionUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUpdateManyWithoutSubscriptionNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAnalyticsEventsNestedInput
  }

  export type AnalyticsEventUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAppUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutOauthAppsCreatedNestedInput
    tokens?: OAuthTokenUpdateManyWithoutAppNestedInput
    apiUsage?: ApiUsageUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: OAuthTokenUncheckedUpdateManyWithoutAppNestedInput
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutAppNestedInput
  }

  export type OAuthAppUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthAppUpdateredirectUrisInput | string[]
    scopes?: OAuthAppUpdatescopesInput | string[]
    rateLimit?: IntFieldUpdateOperationsInput | number
    dailyQuota?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app?: OAuthAppUpdateOneRequiredWithoutTokensNestedInput
    user?: UserUpdateOneRequiredWithoutOauthTokensNestedInput
  }

  export type OAuthTokenUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthTokenUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiUsageUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    app?: OAuthAppUpdateOneWithoutApiUsageNestedInput
    user?: UserUpdateOneWithoutApiUsageNestedInput
  }

  export type ApiUsageUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiUsageUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateManyContactInput = {
    id?: string
    companyId: string
    seriesId: string
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    series?: InvoiceSeriesUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUncheckedUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateManyFiscalYearInput = {
    id?: string
    companyId: string
    number: number
    date: Date | string
    description: string
    reference?: string | null
    referenceType?: $Enums.ReferenceType | null
    sourceType?: $Enums.SourceType | null
    sourceId?: string | null
    status?: $Enums.JournalStatus
    isPosted?: boolean
    postedAt?: Date | string | null
    postedBy?: string | null
    isReversal?: boolean
    reversalOf?: string | null
    reversedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateWithoutFiscalYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
    lines?: JournalLineUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutFiscalYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: JournalLineUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateManyWithoutFiscalYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableEnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType | null
    sourceType?: NullableEnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJournalStatusFieldUpdateOperationsInput | $Enums.JournalStatus
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isReversal?: BoolFieldUpdateOperationsInput | boolean
    reversalOf?: NullableStringFieldUpdateOperationsInput | string | null
    reversedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateManyAccountInput = {
    id?: string
    journalEntryId: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
  }

  export type JournalLineUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalEntry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateManyJournalEntryInput = {
    id?: string
    accountId: string
    lineNumber: number
    description?: string | null
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: string | null
    cryptoPrice?: Decimal | DecimalJsLike | number | string | null
    costCenter?: string | null
    project?: string | null
    createdAt?: Date | string
  }

  export type JournalLineUpdateWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUncheckedUpdateManyWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManySeriesInput = {
    id?: string
    companyId: string
    contactId?: string | null
    number: number
    fullNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    direction: $Enums.InvoiceDirection
    issueDate: Date | string
    dueDate?: Date | string | null
    operationDate?: Date | string | null
    paidAt?: Date | string | null
    counterpartyName: string
    counterpartyTaxId?: string | null
    counterpartyAddress?: string | null
    counterpartyCity?: string | null
    counterpartyCountry?: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    totalTax: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    cryptoPayment?: boolean
    cryptoAsset?: string | null
    cryptoAmount?: Decimal | DecimalJsLike | number | string | null
    cryptoRate?: Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: string | null
    verifactuHash?: string | null
    verifactuPrevHash?: string | null
    verifactuQrData?: string | null
    verifactuSentAt?: Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: $Enums.VerifactuStatus | null
    notes?: string | null
    internalNotes?: string | null
    paymentTerms?: string | null
    paymentMethod?: string | null
    journalEntryId?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    contact?: ContactUpdateOneWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    taxes?: InvoiceTaxUncheckedUpdateManyWithoutInvoiceNestedInput
    verifactuRecords?: VerifactuRecordUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    fullNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    direction?: EnumInvoiceDirectionFieldUpdateOperationsInput | $Enums.InvoiceDirection
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    counterpartyName?: StringFieldUpdateOperationsInput | string
    counterpartyTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCity?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyCountry?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cryptoPayment?: BoolFieldUpdateOperationsInput | boolean
    cryptoAsset?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cryptoTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuPrevHash?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuQrData?: NullableStringFieldUpdateOperationsInput | string | null
    verifactuSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifactuResponse?: NullableJsonNullValueInput | InputJsonValue
    verifactuStatus?: NullableEnumVerifactuStatusFieldUpdateOperationsInput | $Enums.VerifactuStatus | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateManyInvoiceInput = {
    id?: string
    lineNumber: number
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    accountCode?: string | null
  }

  export type InvoiceTaxCreateManyInvoiceInput = {
    id?: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxableBase: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxType?: $Enums.TaxType
  }

  export type VerifactuRecordCreateManyInvoiceInput = {
    id?: string
    hash: string
    prevHash?: string | null
    xmlContent: string
    state?: $Enums.VerifactuRecordState
    csv?: string | null
    sentAt?: Date | string | null
    retryCount?: number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceTaxUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
  }

  export type InvoiceTaxUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
  }

  export type InvoiceTaxUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxableBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: EnumTaxTypeFieldUpdateOperationsInput | $Enums.TaxType
  }

  export type VerifactuRecordUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    prevHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlContent?: StringFieldUpdateOperationsInput | string
    state?: EnumVerifactuRecordStateFieldUpdateOperationsInput | $Enums.VerifactuRecordState
    csv?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerifactuRecordUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    prevHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlContent?: StringFieldUpdateOperationsInput | string
    state?: EnumVerifactuRecordStateFieldUpdateOperationsInput | $Enums.VerifactuRecordState
    csv?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerifactuRecordUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    prevHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlContent?: StringFieldUpdateOperationsInput | string
    state?: EnumVerifactuRecordStateFieldUpdateOperationsInput | $Enums.VerifactuRecordState
    csv?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    aeatResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyCryptoAssetInput = {
    id?: string
    companyId: string
    code: string
    name: string
    type: $Enums.AccountType
    parentCode?: string | null
    description?: string | null
    isCrypto?: boolean
    isActive?: boolean
    isSystem?: boolean
    allowDirectPosting?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoLotCreateManyCryptoAssetInput = {
    id?: string
    companyId: string
    acquiredAt: Date | string
    acquiredAmount: Decimal | DecimalJsLike | number | string
    costBasisEur: Decimal | DecimalJsLike | number | string
    costPerUnit: Decimal | DecimalJsLike | number | string
    remainingAmount: Decimal | DecimalJsLike | number | string
    sourceTxId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutCryptoAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCryptoAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutCryptoAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    allowDirectPosting?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoLotUpdateWithoutCryptoAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCryptoLotsNestedInput
  }

  export type CryptoLotUncheckedUpdateWithoutCryptoAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoLotUncheckedUpdateManyWithoutCryptoAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costBasisEur?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remainingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTransactionCreateManyWalletInput = {
    id?: string
    txHash: string
    blockNumber: bigint | number
    blockTimestamp: Date | string
    chain: string
    type: $Enums.CryptoTxType
    subtype?: string | null
    assetIn?: string | null
    amountIn?: Decimal | DecimalJsLike | number | string | null
    assetOut?: string | null
    amountOut?: Decimal | DecimalJsLike | number | string | null
    feeAsset?: string | null
    feeAmount?: Decimal | DecimalJsLike | number | string | null
    priceInEur?: Decimal | DecimalJsLike | number | string | null
    priceOutEur?: Decimal | DecimalJsLike | number | string | null
    feeEur?: Decimal | DecimalJsLike | number | string | null
    costBasis?: Decimal | DecimalJsLike | number | string | null
    realizedGain?: Decimal | DecimalJsLike | number | string | null
    aiCategorized?: boolean
    aiConfidence?: Decimal | DecimalJsLike | number | string | null
    aiReasoning?: string | null
    manualType?: $Enums.CryptoTxType | null
    manualNotes?: string | null
    journalEntryId?: string | null
    status?: $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoTransactionUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    blockTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: EnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    assetIn?: NullableStringFieldUpdateOperationsInput | string | null
    amountIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    assetOut?: NullableStringFieldUpdateOperationsInput | string | null
    amountOut?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeAsset?: NullableStringFieldUpdateOperationsInput | string | null
    feeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceInEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costBasis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    realizedGain?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    manualType?: NullableEnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType | null
    manualNotes?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTransactionUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    blockTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: EnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    assetIn?: NullableStringFieldUpdateOperationsInput | string | null
    amountIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    assetOut?: NullableStringFieldUpdateOperationsInput | string | null
    amountOut?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeAsset?: NullableStringFieldUpdateOperationsInput | string | null
    feeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceInEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costBasis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    realizedGain?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    manualType?: NullableEnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType | null
    manualNotes?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTransactionUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    blockTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: EnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    assetIn?: NullableStringFieldUpdateOperationsInput | string | null
    amountIn?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    assetOut?: NullableStringFieldUpdateOperationsInput | string | null
    amountOut?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeAsset?: NullableStringFieldUpdateOperationsInput | string | null
    feeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceInEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceOutEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeEur?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costBasis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    realizedGain?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiCategorized?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    manualType?: NullableEnumCryptoTxTypeFieldUpdateOperationsInput | $Enums.CryptoTxType | null
    manualNotes?: NullableStringFieldUpdateOperationsInput | string | null
    journalEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageCreateManyConversationInput = {
    id?: string
    role: $Enums.AiRole
    content: string
    inputTokens?: number | null
    outputTokens?: number | null
    provider?: string | null
    model?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type AiMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiRoleFieldUpdateOperationsInput | $Enums.AiRole
    content?: StringFieldUpdateOperationsInput | string
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiRoleFieldUpdateOperationsInput | $Enums.AiRole
    content?: StringFieldUpdateOperationsInput | string
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiRoleFieldUpdateOperationsInput | $Enums.AiRole
    content?: StringFieldUpdateOperationsInput | string
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenCreateManyAppInput = {
    id?: string
    userId: string
    companyId: string
    accessToken: string
    refreshToken?: string | null
    scopes?: OAuthTokenCreatescopesInput | string[]
    expiresAt: Date | string
    refreshExpiresAt?: Date | string | null
    authorizationCode?: string | null
    codeExpiresAt?: Date | string | null
    isRevoked?: boolean
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type ApiUsageCreateManyAppInput = {
    id?: string
    companyId: string
    userId?: string | null
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestCount?: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type OAuthTokenUpdateWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutOauthTokensNestedInput
    company?: CompanyUpdateOneRequiredWithoutOauthTokensNestedInput
  }

  export type OAuthTokenUncheckedUpdateWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthTokenUncheckedUpdateManyWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: OAuthTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    codeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiUsageUpdateWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutApiUsageNestedInput
    user?: UserUpdateOneWithoutApiUsageNestedInput
  }

  export type ApiUsageUncheckedUpdateWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiUsageUncheckedUpdateManyWithoutAppInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    companyId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    trialEndsAt?: Date | string | null
    invoicesThisMonth?: number
    aiMessagesThisMonth?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesThisMonth?: IntFieldUpdateOperationsInput | number
    aiMessagesThisMonth?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManySubscriptionInput = {
    id?: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    description?: string | null
    failureReason?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManySubscriptionInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    payloadHash: string
    status?: $Enums.WebhookDeliveryStatus
    attemptCount?: number
    maxAttempts?: number
    responseStatus?: number | null
    responseBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    scheduledFor?: Date | string
    lastAttemptAt?: Date | string | null
    nextAttemptAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookDeliveryUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    payloadHash?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookDeliveryStatusFieldUpdateOperationsInput | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    responseStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    payloadHash?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookDeliveryStatusFieldUpdateOperationsInput | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    responseStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    payloadHash?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookDeliveryStatusFieldUpdateOperationsInput | $Enums.WebhookDeliveryStatus
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    responseStatus?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiscalYearCountOutputTypeDefaultArgs instead
     */
    export type FiscalYearCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalEntryCountOutputTypeDefaultArgs instead
     */
    export type JournalEntryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceSeriesCountOutputTypeDefaultArgs instead
     */
    export type InvoiceSeriesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceSeriesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoAssetCountOutputTypeDefaultArgs instead
     */
    export type CryptoAssetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoAssetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletCountOutputTypeDefaultArgs instead
     */
    export type WalletCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiConversationCountOutputTypeDefaultArgs instead
     */
    export type AiConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthAppCountOutputTypeDefaultArgs instead
     */
    export type OAuthAppCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthAppCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type WebhookSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyUserDefaultArgs instead
     */
    export type CompanyUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiscalYearDefaultArgs instead
     */
    export type FiscalYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FiscalYearDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalEntryDefaultArgs instead
     */
    export type JournalEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalLineDefaultArgs instead
     */
    export type JournalLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceSeriesDefaultArgs instead
     */
    export type InvoiceSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceSeriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceLineDefaultArgs instead
     */
    export type InvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceTaxDefaultArgs instead
     */
    export type InvoiceTaxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceTaxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoAssetDefaultArgs instead
     */
    export type CryptoAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletDefaultArgs instead
     */
    export type WalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExchangeAccountDefaultArgs instead
     */
    export type ExchangeAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExchangeAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoTransactionDefaultArgs instead
     */
    export type CryptoTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoLotDefaultArgs instead
     */
    export type CryptoLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoLotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceHistoryDefaultArgs instead
     */
    export type PriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerifactuRecordDefaultArgs instead
     */
    export type VerifactuRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerifactuRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiConversationDefaultArgs instead
     */
    export type AiConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiMessageDefaultArgs instead
     */
    export type AiMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyInvitationDefaultArgs instead
     */
    export type CompanyInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsEventDefaultArgs instead
     */
    export type AnalyticsEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthAppDefaultArgs instead
     */
    export type OAuthAppArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthAppDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthTokenDefaultArgs instead
     */
    export type OAuthTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiUsageDefaultArgs instead
     */
    export type ApiUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiUsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlanDefaultArgs instead
     */
    export type SubscriptionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOnboardingDefaultArgs instead
     */
    export type UserOnboardingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserOnboardingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookSubscriptionDefaultArgs instead
     */
    export type WebhookSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDeliveryDefaultArgs instead
     */
    export type WebhookDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookEventDefaultArgs instead
     */
    export type WebhookEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookEventDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}