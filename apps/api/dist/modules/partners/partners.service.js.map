{"version":3,"sources":["../../../src/modules/partners/partners.service.ts"],"sourcesContent":["import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { CreatePartnerDto } from './dto/create-partner.dto.js';\nimport { UpdatePartnerDto } from './dto/update-partner.dto.js';\nimport { CreateCommissionDto } from './dto/create-commission.dto.js';\nimport * as bcrypt from 'bcrypt';\nimport * as crypto from 'crypto';\n\n/**\n * Partners Service\n *\n * Manages the partner/reseller program:\n * - Partner registration and management\n * - Customer assignment to partners\n * - Commission tracking\n * - Payout management\n * - Partner analytics\n */\n@Injectable()\nexport class PartnersService {\n  private readonly logger = new Logger(PartnersService.name);\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  /**\n   * Create a new partner\n   */\n  async createPartner(dto: CreatePartnerDto) {\n    // Check if partner with email already exists\n    const existing = await this.prisma.partner.findUnique({\n      where: { email: dto.email },\n    });\n\n    if (existing) {\n      throw new BadRequestException('Partner with this email already exists');\n    }\n\n    // Generate API key for partner\n    const apiKey = this.generateApiKey();\n    const apiKeyHash = await bcrypt.hash(apiKey, 10);\n\n    const partner = await this.prisma.partner.create({\n      data: {\n        ...dto,\n        apiKey,\n        apiKeyHash,\n        status: 'PENDING', // Requires approval\n      },\n    });\n\n    this.logger.log(`Created new partner: ${partner.name} (${partner.id})`);\n\n    return {\n      id: partner.id,\n      name: partner.name,\n      email: partner.email,\n      apiKey, // Return API key only once\n      status: partner.status,\n      commissionRate: partner.commissionRate,\n      createdAt: partner.createdAt,\n    };\n  }\n\n  /**\n   * List all partners\n   */\n  async listPartners(filters?: { status?: string; isActive?: boolean }) {\n    const partners = await this.prisma.partner.findMany({\n      where: {\n        ...(filters?.status && { status: filters.status as any }),\n        ...(filters?.isActive !== undefined && { isActive: filters.isActive }),\n      },\n      include: {\n        _count: {\n          select: {\n            customers: true,\n            commissions: true,\n            payouts: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return partners;\n  }\n\n  /**\n   * Get partner by ID\n   */\n  async getPartnerById(partnerId: string) {\n    const partner = await this.prisma.partner.findUnique({\n      where: { id: partnerId },\n      include: {\n        customers: {\n          include: {\n            company: {\n              select: {\n                id: true,\n                name: true,\n                email: true,\n              },\n            },\n          },\n        },\n        _count: {\n          select: {\n            commissions: true,\n            payouts: true,\n          },\n        },\n      },\n    });\n\n    if (!partner) {\n      throw new NotFoundException(`Partner not found: ${partnerId}`);\n    }\n\n    return partner;\n  }\n\n  /**\n   * Update partner\n   */\n  async updatePartner(partnerId: string, dto: UpdatePartnerDto) {\n    const partner = await this.prisma.partner.update({\n      where: { id: partnerId },\n      data: dto,\n    });\n\n    this.logger.log(`Updated partner: ${partner.name} (${partnerId})`);\n    return partner;\n  }\n\n  /**\n   * Assign a company to a partner\n   */\n  async assignCustomerToPartner(partnerId: string, companyId: string) {\n    // Check if partner exists\n    const partner = await this.prisma.partner.findUnique({\n      where: { id: partnerId },\n    });\n\n    if (!partner) {\n      throw new NotFoundException(`Partner not found: ${partnerId}`);\n    }\n\n    if (partner.status !== 'ACTIVE') {\n      throw new BadRequestException('Partner is not active');\n    }\n\n    // Check if company already assigned to another partner\n    const existing = await this.prisma.partnerCustomer.findUnique({\n      where: { companyId },\n    });\n\n    if (existing) {\n      throw new BadRequestException('Company is already assigned to a partner');\n    }\n\n    const partnerCustomer = await this.prisma.partnerCustomer.create({\n      data: {\n        partnerId,\n        companyId,\n        status: 'ACTIVE',\n        activatedAt: new Date(),\n      },\n      include: {\n        company: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n      },\n    });\n\n    this.logger.log(`Assigned company ${companyId} to partner ${partnerId}`);\n    return partnerCustomer;\n  }\n\n  /**\n   * Record a commission for a partner\n   */\n  async createCommission(dto: CreateCommissionDto) {\n    const commission = await this.prisma.partnerCommission.create({\n      data: {\n        partnerId: dto.partnerId,\n        companyId: dto.companyId,\n        transactionType: dto.transactionType,\n        transactionId: dto.transactionId,\n        baseAmount: dto.baseAmount,\n        commissionRate: dto.commissionRate,\n        commissionAmount: dto.commissionAmount,\n        currency: dto.currency || 'EUR',\n        status: dto.status || 'PENDING',\n        periodStart: new Date(),\n        periodEnd: new Date(),\n      },\n    });\n\n    this.logger.log(\n      `Created commission ${commission.id} for partner ${dto.partnerId}: €${dto.commissionAmount}`,\n    );\n\n    return commission;\n  }\n\n  /**\n   * Calculate commission for a transaction\n   */\n  async calculateCommission(\n    companyId: string,\n    transactionType: string,\n    baseAmount: number,\n  ): Promise<{ shouldCreateCommission: boolean; commission?: CreateCommissionDto }> {\n    // Check if company has a partner\n    const partnerCustomer = await this.prisma.partnerCustomer.findUnique({\n      where: { companyId },\n      include: { partner: true },\n    });\n\n    if (!partnerCustomer || partnerCustomer.status !== 'ACTIVE') {\n      return { shouldCreateCommission: false };\n    }\n\n    const partner = partnerCustomer.partner;\n\n    if (partner.status !== 'ACTIVE' || !partner.isActive) {\n      return { shouldCreateCommission: false };\n    }\n\n    // Use custom rate if set, otherwise partner's default\n    const commissionRate = partnerCustomer.customCommissionRate || partner.commissionRate;\n    const commissionAmount = (baseAmount * commissionRate) / 100;\n\n    return {\n      shouldCreateCommission: true,\n      commission: {\n        partnerId: partner.id,\n        companyId,\n        transactionType,\n        baseAmount,\n        commissionRate,\n        commissionAmount,\n        currency: 'EUR',\n        status: 'PENDING' as any,\n      },\n    };\n  }\n\n  /**\n   * Get partner commissions\n   */\n  async getPartnerCommissions(\n    partnerId: string,\n    filters?: {\n      status?: string;\n      startDate?: Date;\n      endDate?: Date;\n    },\n  ) {\n    const commissions = await this.prisma.partnerCommission.findMany({\n      where: {\n        partnerId,\n        ...(filters?.status && { status: filters.status as any }),\n        ...(filters?.startDate &&\n          filters?.endDate && {\n            periodStart: { gte: filters.startDate },\n            periodEnd: { lte: filters.endDate },\n          }),\n      },\n      include: {\n        payout: true,\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    // Calculate total\n    const totalCommission = commissions.reduce((sum, c) => sum + c.commissionAmount, 0);\n    const totalPending = commissions\n      .filter((c) => c.status === 'PENDING')\n      .reduce((sum, c) => sum + c.commissionAmount, 0);\n    const totalPaid = commissions\n      .filter((c) => c.status === 'PAID')\n      .reduce((sum, c) => sum + c.commissionAmount, 0);\n\n    return {\n      commissions,\n      summary: {\n        total: totalCommission,\n        pending: totalPending,\n        paid: totalPaid,\n        count: commissions.length,\n      },\n    };\n  }\n\n  /**\n   * Create a payout for partner\n   */\n  async createPayout(\n    partnerId: string,\n    periodStart: Date,\n    periodEnd: Date,\n    paymentMethod?: string,\n  ) {\n    // Get all approved but unpaid commissions\n    const commissions = await this.prisma.partnerCommission.findMany({\n      where: {\n        partnerId,\n        status: 'APPROVED',\n        payoutId: null,\n        periodStart: { gte: periodStart },\n        periodEnd: { lte: periodEnd },\n      },\n    });\n\n    if (commissions.length === 0) {\n      throw new BadRequestException('No approved commissions found for this period');\n    }\n\n    const totalAmount = commissions.reduce((sum, c) => sum + c.commissionAmount, 0);\n\n    // Create payout\n    const payout = await this.prisma.partnerPayout.create({\n      data: {\n        partnerId,\n        amount: totalAmount,\n        currency: 'EUR',\n        periodStart,\n        periodEnd,\n        paymentMethod,\n        status: 'PENDING',\n        scheduledAt: new Date(),\n      },\n    });\n\n    // Link commissions to payout\n    await this.prisma.partnerCommission.updateMany({\n      where: {\n        id: { in: commissions.map((c) => c.id) },\n      },\n      data: {\n        payoutId: payout.id,\n      },\n    });\n\n    this.logger.log(\n      `Created payout ${payout.id} for partner ${partnerId}: €${totalAmount} (${commissions.length} commissions)`,\n    );\n\n    return payout;\n  }\n\n  /**\n   * Mark payout as paid\n   */\n  async markPayoutAsPaid(payoutId: string, paymentReference?: string) {\n    const payout = await this.prisma.partnerPayout.update({\n      where: { id: payoutId },\n      data: {\n        status: 'PAID',\n        paidAt: new Date(),\n        paymentReference,\n      },\n    });\n\n    // Mark all associated commissions as paid\n    await this.prisma.partnerCommission.updateMany({\n      where: { payoutId },\n      data: {\n        status: 'PAID',\n        paidAt: new Date(),\n      },\n    });\n\n    this.logger.log(`Marked payout ${payoutId} as paid`);\n    return payout;\n  }\n\n  /**\n   * Get partner analytics\n   */\n  async getPartnerAnalytics(partnerId: string) {\n    const [partner, customers, commissions, payouts] = await Promise.all([\n      this.prisma.partner.findUnique({ where: { id: partnerId } }),\n      this.prisma.partnerCustomer.count({ where: { partnerId, status: 'ACTIVE' } }),\n      this.prisma.partnerCommission.aggregate({\n        where: { partnerId },\n        _sum: { commissionAmount: true },\n        _count: true,\n      }),\n      this.prisma.partnerPayout.aggregate({\n        where: { partnerId, status: 'PAID' },\n        _sum: { amount: true },\n        _count: true,\n      }),\n    ]);\n\n    if (!partner) {\n      throw new NotFoundException(`Partner not found: ${partnerId}`);\n    }\n\n    return {\n      partnerId: partner.id,\n      partnerName: partner.name,\n      activeCustomers: customers,\n      totalCommissions: commissions._sum.commissionAmount || 0,\n      commissionCount: commissions._count,\n      totalPayouts: payouts._sum.amount || 0,\n      payoutCount: payouts._count,\n      pendingCommissions:\n        (commissions._sum.commissionAmount || 0) - (payouts._sum.amount || 0),\n    };\n  }\n\n  /**\n   * Helper: Generate API key\n   */\n  private generateApiKey(): string {\n    return 'pk_' + crypto.randomBytes(32).toString('hex');\n  }\n}\n"],"names":["PartnersService","createPartner","dto","existing","prisma","partner","findUnique","where","email","BadRequestException","apiKey","generateApiKey","apiKeyHash","bcrypt","hash","create","data","status","logger","log","name","id","commissionRate","createdAt","listPartners","filters","partners","findMany","isActive","undefined","include","_count","select","customers","commissions","payouts","orderBy","getPartnerById","partnerId","company","NotFoundException","updatePartner","update","assignCustomerToPartner","companyId","partnerCustomer","activatedAt","Date","createCommission","commission","partnerCommission","transactionType","transactionId","baseAmount","commissionAmount","currency","periodStart","periodEnd","calculateCommission","shouldCreateCommission","customCommissionRate","getPartnerCommissions","startDate","endDate","gte","lte","payout","totalCommission","reduce","sum","c","totalPending","filter","totalPaid","summary","total","pending","paid","count","length","createPayout","paymentMethod","payoutId","totalAmount","partnerPayout","amount","scheduledAt","updateMany","in","map","markPayoutAsPaid","paymentReference","paidAt","getPartnerAnalytics","Promise","all","aggregate","_sum","partnerName","activeCustomers","totalCommissions","commissionCount","totalPayouts","payoutCount","pendingCommissions","crypto","randomBytes","toString","Logger"],"mappings":"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"}