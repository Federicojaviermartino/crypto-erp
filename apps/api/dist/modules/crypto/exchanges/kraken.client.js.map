{"version":3,"sources":["../../../../src/modules/crypto/exchanges/kraken.client.ts"],"sourcesContent":["import { Logger } from '@nestjs/common';\nimport * as crypto from 'crypto';\nimport {\n  ExchangeClient,\n  ExchangeCredentials,\n  ExchangeBalance,\n  ExchangeTrade,\n  ExchangeDeposit,\n  ExchangeWithdrawal,\n} from './exchange.interface.js';\n\nexport class KrakenClient implements ExchangeClient {\n  readonly name = 'Kraken';\n  readonly country = 'US';\n  private readonly logger = new Logger(KrakenClient.name);\n  private readonly baseUrl = 'https://api.kraken.com';\n\n  constructor(private readonly credentials: ExchangeCredentials) {}\n\n  private getSignature(path: string, nonce: number, postData: string): string {\n    const message = nonce + postData;\n    const hash = crypto.createHash('sha256').update(message).digest();\n    const secret = Buffer.from(this.credentials.apiSecret, 'base64');\n    const hmac = crypto.createHmac('sha512', secret);\n    hmac.update(path);\n    hmac.update(hash);\n    return hmac.digest('base64');\n  }\n\n  private async request<T>(\n    endpoint: string,\n    params: Record<string, string | number> = {},\n    isPrivate = false,\n  ): Promise<T> {\n    const url = `${this.baseUrl}${endpoint}`;\n\n    if (isPrivate) {\n      const nonce = Date.now() * 1000;\n      params.nonce = nonce;\n\n      const postParams = new URLSearchParams();\n      for (const [key, value] of Object.entries(params)) {\n        postParams.append(key, String(value));\n      }\n      const postData = postParams.toString();\n\n      const signature = this.getSignature(endpoint, nonce, postData);\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'API-Key': this.credentials.apiKey,\n          'API-Sign': signature,\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: postData,\n      });\n\n      const data = await response.json() as { error: string[]; result: T };\n\n      if (data.error && data.error.length > 0) {\n        this.logger.error(`Kraken API error: ${data.error.join(', ')}`);\n        throw new Error(`Kraken API error: ${data.error.join(', ')}`);\n      }\n\n      return data.result;\n    } else {\n      const queryParams = new URLSearchParams();\n      for (const [key, value] of Object.entries(params)) {\n        queryParams.append(key, String(value));\n      }\n      const queryString = queryParams.toString();\n\n      const response = await fetch(`${url}?${queryString}`);\n      const data = await response.json() as { error: string[]; result: T };\n\n      if (data.error && data.error.length > 0) {\n        throw new Error(`Kraken API error: ${data.error.join(', ')}`);\n      }\n\n      return data.result;\n    }\n  }\n\n  async testConnection(): Promise<boolean> {\n    try {\n      await this.request('/0/private/Balance', {}, true);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getBalances(): Promise<ExchangeBalance[]> {\n    const balances = await this.request<Record<string, string>>('/0/private/Balance', {}, true);\n\n    return Object.entries(balances)\n      .filter(([_, value]) => parseFloat(value) > 0)\n      .map(([asset, value]) => ({\n        asset: this.normalizeAsset(asset),\n        free: value,\n        locked: '0',\n        total: value,\n      }));\n  }\n\n  async getTrades(options: {\n    symbol?: string;\n    startTime?: Date;\n    endTime?: Date;\n    limit?: number;\n  } = {}): Promise<ExchangeTrade[]> {\n    interface KrakenTradesResponse {\n      trades: Record<string, {\n        ordertxid: string;\n        pair: string;\n        time: number;\n        type: string;\n        ordertype: string;\n        price: string;\n        cost: string;\n        fee: string;\n        vol: string;\n      }>;\n    }\n\n    const params: Record<string, string | number> = {};\n\n    if (options.startTime) {\n      params.start = Math.floor(options.startTime.getTime() / 1000);\n    }\n    if (options.endTime) {\n      params.end = Math.floor(options.endTime.getTime() / 1000);\n    }\n\n    const result = await this.request<KrakenTradesResponse>('/0/private/TradesHistory', params, true);\n\n    return Object.entries(result.trades || {}).map(([id, trade]) => ({\n      id,\n      symbol: trade.pair,\n      orderId: trade.ordertxid,\n      side: trade.type.toUpperCase() as 'BUY' | 'SELL',\n      price: trade.price,\n      quantity: trade.vol,\n      quoteQuantity: trade.cost,\n      commission: trade.fee,\n      commissionAsset: this.getQuoteAsset(trade.pair),\n      timestamp: new Date(trade.time * 1000),\n      isMaker: trade.ordertype === 'limit',\n    }));\n  }\n\n  async getDeposits(options: {\n    asset?: string;\n    startTime?: Date;\n    endTime?: Date;\n  } = {}): Promise<ExchangeDeposit[]> {\n    interface KrakenDeposit {\n      method: string;\n      aclass: string;\n      asset: string;\n      refid: string;\n      txid: string;\n      info: string;\n      amount: string;\n      fee: string;\n      time: number;\n      status: string;\n    }\n\n    const params: Record<string, string | number> = {};\n\n    if (options.asset) {\n      params.asset = options.asset;\n    }\n\n    const deposits = await this.request<KrakenDeposit[]>('/0/private/DepositStatus', params, true);\n\n    return (deposits || []).map(d => ({\n      id: d.refid,\n      asset: this.normalizeAsset(d.asset),\n      amount: d.amount,\n      status: this.mapDepositStatus(d.status),\n      txHash: d.txid,\n      timestamp: new Date(d.time * 1000),\n    }));\n  }\n\n  async getWithdrawals(options: {\n    asset?: string;\n    startTime?: Date;\n    endTime?: Date;\n  } = {}): Promise<ExchangeWithdrawal[]> {\n    interface KrakenWithdrawal {\n      method: string;\n      aclass: string;\n      asset: string;\n      refid: string;\n      txid: string;\n      info: string;\n      amount: string;\n      fee: string;\n      time: number;\n      status: string;\n    }\n\n    const params: Record<string, string | number> = {};\n\n    if (options.asset) {\n      params.asset = options.asset;\n    }\n\n    const withdrawals = await this.request<KrakenWithdrawal[]>('/0/private/WithdrawStatus', params, true);\n\n    return (withdrawals || []).map(w => ({\n      id: w.refid,\n      asset: this.normalizeAsset(w.asset),\n      amount: w.amount,\n      fee: w.fee,\n      status: this.mapWithdrawalStatus(w.status),\n      txHash: w.txid,\n      address: w.info,\n      timestamp: new Date(w.time * 1000),\n    }));\n  }\n\n  private normalizeAsset(asset: string): string {\n    // Kraken uses X/Z prefixes for some assets\n    const normalized = asset.replace(/^[XZ]/, '');\n    const mapping: Record<string, string> = {\n      'BTC': 'BTC',\n      'XBT': 'BTC',\n      'ETH': 'ETH',\n      'EUR': 'EUR',\n      'USD': 'USD',\n    };\n    return mapping[normalized] || normalized;\n  }\n\n  private getQuoteAsset(pair: string): string {\n    // Simple heuristic for quote asset\n    if (pair.endsWith('EUR')) return 'EUR';\n    if (pair.endsWith('USD')) return 'USD';\n    if (pair.endsWith('USDT')) return 'USDT';\n    if (pair.endsWith('BTC') || pair.endsWith('XBT')) return 'BTC';\n    return 'EUR';\n  }\n\n  private mapDepositStatus(status: string): ExchangeDeposit['status'] {\n    const statusMap: Record<string, ExchangeDeposit['status']> = {\n      'Success': 'COMPLETED',\n      'Settled': 'COMPLETED',\n      'Pending': 'PENDING',\n      'Initial': 'PENDING',\n      'Failure': 'FAILED',\n    };\n    return statusMap[status] || 'PENDING';\n  }\n\n  private mapWithdrawalStatus(status: string): ExchangeWithdrawal['status'] {\n    const statusMap: Record<string, ExchangeWithdrawal['status']> = {\n      'Success': 'COMPLETED',\n      'Pending': 'PENDING',\n      'Initial': 'PENDING',\n      'Failure': 'FAILED',\n      'Canceled': 'CANCELLED',\n    };\n    return statusMap[status] || 'PENDING';\n  }\n}\n"],"names":["KrakenClient","getSignature","path","nonce","postData","message","hash","crypto","createHash","update","digest","secret","Buffer","from","credentials","apiSecret","hmac","createHmac","request","endpoint","params","isPrivate","url","baseUrl","Date","now","postParams","URLSearchParams","key","value","Object","entries","append","String","toString","signature","response","fetch","method","headers","apiKey","body","data","json","error","length","logger","join","Error","result","queryParams","queryString","testConnection","getBalances","balances","filter","_","parseFloat","map","asset","normalizeAsset","free","locked","total","getTrades","options","startTime","start","Math","floor","getTime","endTime","end","trades","id","trade","symbol","pair","orderId","ordertxid","side","type","toUpperCase","price","quantity","vol","quoteQuantity","cost","commission","fee","commissionAsset","getQuoteAsset","timestamp","time","isMaker","ordertype","getDeposits","deposits","d","refid","amount","status","mapDepositStatus","txHash","txid","getWithdrawals","withdrawals","w","mapWithdrawalStatus","address","info","normalized","replace","mapping","endsWith","statusMap","name","country","Logger"],"mappings":"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"}