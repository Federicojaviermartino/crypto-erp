{"version":3,"sources":["../../../../src/modules/crypto/exchanges/exchange-accounts.service.ts"],"sourcesContent":["import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { ExchangeFactory } from './exchange.factory.js';\nimport { ExchangeName, EXCHANGE_INFO, ExchangeBalance, ExchangeTrade } from './exchange.interface.js';\nimport * as crypto from 'crypto';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'crypto-erp-default-key-32bytes!';\n\n@Injectable()\nexport class ExchangeAccountsService {\n  private readonly logger = new Logger(ExchangeAccountsService.name);\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly exchangeFactory: ExchangeFactory,\n  ) {}\n\n  private encrypt(text: string): string {\n    const iv = crypto.randomBytes(16);\n    const key = crypto.scryptSync(ENCRYPTION_KEY, 'salt', 32);\n    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return iv.toString('hex') + ':' + encrypted;\n  }\n\n  private decrypt(text: string): string {\n    const [ivHex, encrypted] = text.split(':');\n    const iv = Buffer.from(ivHex, 'hex');\n    const key = crypto.scryptSync(ENCRYPTION_KEY, 'salt', 32);\n    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n  }\n\n  async findAll(companyId: string) {\n    const accounts = await this.prisma.exchangeAccount.findMany({\n      where: { companyId },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return accounts.map(account => ({\n      ...account,\n      apiKey: account.apiKey ? '***' + account.apiKey.slice(-4) : null,\n      apiSecret: '********',\n    }));\n  }\n\n  async findOne(companyId: string, id: string) {\n    const account = await this.prisma.exchangeAccount.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!account) {\n      throw new NotFoundException(`Exchange account ${id} not found`);\n    }\n\n    return {\n      ...account,\n      apiKey: account.apiKey ? '***' + account.apiKey.slice(-4) : null,\n      apiSecret: '********',\n    };\n  }\n\n  async create(\n    companyId: string,\n    data: {\n      exchange: string;\n      label?: string;\n      apiKey: string;\n      apiSecret: string;\n    },\n  ) {\n    const exchange = data.exchange as ExchangeName;\n\n    if (!EXCHANGE_INFO[exchange]) {\n      throw new BadRequestException(`Unsupported exchange: ${data.exchange}`);\n    }\n\n    // Test connection before saving\n    const credentials = {\n      apiKey: data.apiKey,\n      apiSecret: data.apiSecret,\n    };\n\n    try {\n      const client = this.exchangeFactory.createClient(exchange, credentials);\n      const isValid = await client.testConnection();\n\n      if (!isValid) {\n        throw new BadRequestException('Invalid API credentials - connection test failed');\n      }\n    } catch (error) {\n      if (error instanceof BadRequestException) throw error;\n      throw new BadRequestException(`Failed to connect to ${exchange}: ${error.message}`);\n    }\n\n    const exchangeInfo = EXCHANGE_INFO[exchange];\n\n    const account = await this.prisma.exchangeAccount.create({\n      data: {\n        companyId,\n        exchange,\n        label: data.label || exchangeInfo.name,\n        apiKey: this.encrypt(data.apiKey),\n        apiSecret: this.encrypt(data.apiSecret),\n        country: exchangeInfo.country,\n        syncStatus: 'PENDING',\n      },\n    });\n\n    return {\n      ...account,\n      apiKey: '***' + data.apiKey.slice(-4),\n      apiSecret: '********',\n    };\n  }\n\n  async update(\n    companyId: string,\n    id: string,\n    data: {\n      label?: string;\n      apiKey?: string;\n      apiSecret?: string;\n    },\n  ) {\n    const existing = await this.prisma.exchangeAccount.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!existing) {\n      throw new NotFoundException(`Exchange account ${id} not found`);\n    }\n\n    const updateData: Record<string, string> = {};\n\n    if (data.label) {\n      updateData.label = data.label;\n    }\n\n    if (data.apiKey && data.apiSecret) {\n      // Test new credentials\n      const credentials = {\n        apiKey: data.apiKey,\n        apiSecret: data.apiSecret,\n      };\n\n      try {\n        const client = this.exchangeFactory.createClient(\n          existing.exchange as ExchangeName,\n          credentials,\n        );\n        const isValid = await client.testConnection();\n\n        if (!isValid) {\n          throw new BadRequestException('Invalid API credentials - connection test failed');\n        }\n      } catch (error) {\n        if (error instanceof BadRequestException) throw error;\n        throw new BadRequestException(`Failed to connect: ${error.message}`);\n      }\n\n      updateData.apiKey = this.encrypt(data.apiKey);\n      updateData.apiSecret = this.encrypt(data.apiSecret);\n    }\n\n    const account = await this.prisma.exchangeAccount.update({\n      where: { id },\n      data: updateData,\n    });\n\n    return {\n      ...account,\n      apiKey: account.apiKey ? '***' + this.decrypt(account.apiKey).slice(-4) : null,\n      apiSecret: '********',\n    };\n  }\n\n  async delete(companyId: string, id: string) {\n    const existing = await this.prisma.exchangeAccount.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!existing) {\n      throw new NotFoundException(`Exchange account ${id} not found`);\n    }\n\n    await this.prisma.exchangeAccount.delete({\n      where: { id },\n    });\n\n    return { success: true };\n  }\n\n  async testConnection(companyId: string, id: string): Promise<boolean> {\n    const account = await this.prisma.exchangeAccount.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!account || !account.apiKey || !account.apiSecret) {\n      throw new NotFoundException(`Exchange account ${id} not found or missing credentials`);\n    }\n\n    const credentials = {\n      apiKey: this.decrypt(account.apiKey),\n      apiSecret: this.decrypt(account.apiSecret),\n    };\n\n    const client = this.exchangeFactory.createClient(\n      account.exchange as ExchangeName,\n      credentials,\n    );\n\n    return client.testConnection();\n  }\n\n  async getBalances(companyId: string, id: string): Promise<ExchangeBalance[]> {\n    const account = await this.prisma.exchangeAccount.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!account || !account.apiKey || !account.apiSecret) {\n      throw new NotFoundException(`Exchange account ${id} not found`);\n    }\n\n    const credentials = {\n      apiKey: this.decrypt(account.apiKey),\n      apiSecret: this.decrypt(account.apiSecret),\n    };\n\n    const client = this.exchangeFactory.createClient(\n      account.exchange as ExchangeName,\n      credentials,\n    );\n\n    return client.getBalances();\n  }\n\n  async syncTrades(\n    companyId: string,\n    id: string,\n    options: { startTime?: Date; endTime?: Date } = {},\n  ): Promise<{ imported: number }> {\n    const account = await this.prisma.exchangeAccount.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!account || !account.apiKey || !account.apiSecret) {\n      throw new NotFoundException(`Exchange account ${id} not found`);\n    }\n\n    // Update sync status\n    await this.prisma.exchangeAccount.update({\n      where: { id },\n      data: { syncStatus: 'SYNCING' },\n    });\n\n    try {\n      const credentials = {\n        apiKey: this.decrypt(account.apiKey),\n        apiSecret: this.decrypt(account.apiSecret),\n      };\n\n      const client = this.exchangeFactory.createClient(\n        account.exchange as ExchangeName,\n        credentials,\n      );\n\n      // Get trades from exchange\n      const trades = await client.getTrades({\n        startTime: options.startTime,\n        endTime: options.endTime,\n      });\n\n      let imported = 0;\n\n      // Get or create exchange wallet for this account\n      let exchangeWallet = await this.prisma.wallet.findFirst({\n        where: {\n          companyId,\n          label: `Exchange: ${account.label || account.exchange}`,\n        },\n      });\n\n      if (!exchangeWallet) {\n        exchangeWallet = await this.prisma.wallet.create({\n          data: {\n            companyId,\n            label: `Exchange: ${account.label || account.exchange}`,\n            chain: 'EXCHANGE',\n            address: account.id,\n            isActive: true,\n          },\n        });\n      }\n\n      // Import trades as crypto transactions\n      for (const trade of trades) {\n        const baseAsset = this.extractBaseAsset(trade.symbol);\n        const externalId = `${account.exchange}:${trade.id}`;\n\n        // Check if trade already exists\n        const existingTx = await this.prisma.cryptoTransaction.findFirst({\n          where: {\n            walletId: exchangeWallet.id,\n            txHash: externalId,\n          },\n        });\n\n        if (!existingTx) {\n          const isBuy = trade.side === 'BUY';\n          await this.prisma.cryptoTransaction.create({\n            data: {\n              walletId: exchangeWallet.id,\n              type: isBuy ? 'TRANSFER_IN' : 'TRANSFER_OUT',\n              subtype: 'EXCHANGE_TRADE',\n              txHash: externalId,\n              blockNumber: 0,\n              chain: 'EXCHANGE',\n              blockTimestamp: trade.timestamp,\n              assetIn: isBuy ? baseAsset : undefined,\n              amountIn: isBuy ? trade.quantity : undefined,\n              assetOut: !isBuy ? baseAsset : undefined,\n              amountOut: !isBuy ? trade.quantity : undefined,\n            },\n          });\n          imported++;\n        }\n      }\n\n      // Update sync status\n      await this.prisma.exchangeAccount.update({\n        where: { id },\n        data: {\n          syncStatus: 'SYNCED',\n          lastSyncAt: new Date(),\n        },\n      });\n\n      this.logger.log(`Synced ${imported} trades from ${account.exchange} for company ${companyId}`);\n\n      return { imported };\n    } catch (error) {\n      await this.prisma.exchangeAccount.update({\n        where: { id },\n        data: { syncStatus: 'ERROR' },\n      });\n      throw error;\n    }\n  }\n\n  async syncDepositsWithdrawals(\n    companyId: string,\n    id: string,\n    options: { startTime?: Date; endTime?: Date } = {},\n  ): Promise<{ deposits: number; withdrawals: number }> {\n    const account = await this.prisma.exchangeAccount.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!account || !account.apiKey || !account.apiSecret) {\n      throw new NotFoundException(`Exchange account ${id} not found`);\n    }\n\n    const credentials = {\n      apiKey: this.decrypt(account.apiKey),\n      apiSecret: this.decrypt(account.apiSecret),\n    };\n\n    const client = this.exchangeFactory.createClient(\n      account.exchange as ExchangeName,\n      credentials,\n    );\n\n    const [deposits, withdrawals] = await Promise.all([\n      client.getDeposits(options),\n      client.getWithdrawals(options),\n    ]);\n\n    // Get or create exchange wallet for this account\n    let exchangeWallet = await this.prisma.wallet.findFirst({\n      where: {\n        companyId,\n        label: `Exchange: ${account.label || account.exchange}`,\n      },\n    });\n\n    if (!exchangeWallet) {\n      exchangeWallet = await this.prisma.wallet.create({\n        data: {\n          companyId,\n          label: `Exchange: ${account.label || account.exchange}`,\n          chain: 'EXCHANGE',\n          address: account.id,\n          isActive: true,\n        },\n      });\n    }\n\n    let depositCount = 0;\n    let withdrawalCount = 0;\n\n    // Import deposits\n    for (const deposit of deposits) {\n      if (deposit.status !== 'COMPLETED') continue;\n\n      const externalId = `${account.exchange}:deposit:${deposit.id}`;\n\n      const existingTx = await this.prisma.cryptoTransaction.findFirst({\n        where: {\n          walletId: exchangeWallet.id,\n          txHash: externalId,\n        },\n      });\n\n      if (!existingTx) {\n        await this.prisma.cryptoTransaction.create({\n          data: {\n            walletId: exchangeWallet.id,\n            type: 'TRANSFER_IN',\n            subtype: 'DEPOSIT',\n            txHash: externalId,\n            blockNumber: 0,\n            chain: 'EXCHANGE',\n            blockTimestamp: deposit.timestamp,\n            assetIn: deposit.asset,\n            amountIn: deposit.amount,\n          },\n        });\n        depositCount++;\n      }\n    }\n\n    // Import withdrawals\n    for (const withdrawal of withdrawals) {\n      if (withdrawal.status !== 'COMPLETED') continue;\n\n      const externalId = `${account.exchange}:withdrawal:${withdrawal.id}`;\n\n      const existingTx = await this.prisma.cryptoTransaction.findFirst({\n        where: {\n          walletId: exchangeWallet.id,\n          txHash: externalId,\n        },\n      });\n\n      if (!existingTx) {\n        await this.prisma.cryptoTransaction.create({\n          data: {\n            walletId: exchangeWallet.id,\n            type: 'TRANSFER_OUT',\n            subtype: 'WITHDRAWAL',\n            txHash: externalId,\n            blockNumber: 0,\n            chain: 'EXCHANGE',\n            blockTimestamp: withdrawal.timestamp,\n            assetOut: withdrawal.asset,\n            amountOut: withdrawal.amount,\n          },\n        });\n        withdrawalCount++;\n      }\n    }\n\n    return { deposits: depositCount, withdrawals: withdrawalCount };\n  }\n\n  private extractBaseAsset(symbol: string): string {\n    // Common quote currencies\n    const quotes = ['EUR', 'USD', 'USDT', 'USDC', 'BTC', 'ETH', 'BUSD'];\n\n    for (const quote of quotes) {\n      if (symbol.endsWith(quote)) {\n        return symbol.slice(0, -quote.length);\n      }\n    }\n\n    return symbol;\n  }\n\n  getSupportedExchanges() {\n    return Object.entries(EXCHANGE_INFO).map(([key, info]) => ({\n      id: key,\n      ...info,\n      supported: this.exchangeFactory.getSupportedExchanges().includes(key as ExchangeName),\n    }));\n  }\n}\n"],"names":["ExchangeAccountsService","ENCRYPTION_KEY","process","env","encrypt","text","iv","crypto","randomBytes","key","scryptSync","cipher","createCipheriv","encrypted","update","final","toString","decrypt","ivHex","split","Buffer","from","decipher","createDecipheriv","decrypted","findAll","companyId","accounts","prisma","exchangeAccount","findMany","where","orderBy","createdAt","map","account","apiKey","slice","apiSecret","findOne","id","findFirst","NotFoundException","create","data","exchange","EXCHANGE_INFO","BadRequestException","credentials","client","exchangeFactory","createClient","isValid","testConnection","error","message","exchangeInfo","label","name","country","syncStatus","existing","updateData","delete","success","getBalances","syncTrades","options","trades","getTrades","startTime","endTime","imported","exchangeWallet","wallet","chain","address","isActive","trade","baseAsset","extractBaseAsset","symbol","externalId","existingTx","cryptoTransaction","walletId","txHash","isBuy","side","type","subtype","blockNumber","blockTimestamp","timestamp","assetIn","undefined","amountIn","quantity","assetOut","amountOut","lastSyncAt","Date","logger","log","syncDepositsWithdrawals","deposits","withdrawals","Promise","all","getDeposits","getWithdrawals","depositCount","withdrawalCount","deposit","status","asset","amount","withdrawal","quotes","quote","endsWith","length","getSupportedExchanges","Object","entries","info","supported","includes","Logger"],"mappings":"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"}