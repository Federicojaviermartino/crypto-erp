{"version":3,"sources":["../../../../src/modules/crypto/services/cost-basis.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { CryptoLot } from '@prisma/client';\n\ninterface CostBasisResult {\n  costBasis: number;\n  realizedGain: number;\n  lotsUsed: {\n    lotId: string;\n    amountUsed: number;\n    costBasis: number;\n    acquiredAt: Date;\n    holdingPeriod: number; // days\n  }[];\n}\n\ninterface PortfolioPosition {\n  assetId: string;\n  symbol: string;\n  name: string;\n  totalAmount: number;\n  averageCostBasis: number;\n  totalCostBasis: number;\n  currentPrice?: number;\n  currentValue?: number;\n  unrealizedGain?: number;\n}\n\nexport interface TaxReportEntry {\n  transactionId: string;\n  date: Date;\n  type: string;\n  assetSymbol: string;\n  amount: number;\n  proceeds: number;\n  costBasis: number;\n  gainLoss: number;\n  holdingPeriod: 'SHORT' | 'LONG';\n}\n\n@Injectable()\nexport class CostBasisService {\n  private readonly logger = new Logger(CostBasisService.name);\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  /**\n   * Create a new cost basis lot for an acquisition (BUY, TRANSFER_IN, STAKING_REWARD, etc.)\n   */\n  async createLot(\n    companyId: string,\n    sourceTxId: string,\n    cryptoAssetId: string,\n    amount: number,\n    costBasisEur: number,\n    acquiredAt: Date,\n  ): Promise<CryptoLot> {\n    return this.prisma.cryptoLot.create({\n      data: {\n        companyId,\n        cryptoAssetId,\n        sourceTxId,\n        sourceType: 'purchase',\n        acquiredAmount: amount,\n        remainingAmount: amount,\n        costBasisEur,\n        costPerUnit: amount > 0 ? costBasisEur / amount : 0,\n        acquiredAt,\n      },\n    });\n  }\n\n  /**\n   * Calculate cost basis for a disposal using FIFO method\n   * Returns the cost basis and realized gain/loss\n   */\n  async calculateFIFO(\n    companyId: string,\n    cryptoAssetId: string,\n    amountToSell: number,\n    saleDate: Date,\n    saleProceeds: number,\n  ): Promise<CostBasisResult> {\n    // Get available lots in FIFO order (oldest first)\n    const lots = await this.prisma.cryptoLot.findMany({\n      where: {\n        companyId,\n        cryptoAssetId,\n        remainingAmount: { gt: 0 },\n      },\n      orderBy: { acquiredAt: 'asc' },\n    });\n\n    let remainingToSell = amountToSell;\n    let totalCostBasis = 0;\n    const lotsUsed: CostBasisResult['lotsUsed'] = [];\n\n    for (const lot of lots) {\n      if (remainingToSell <= 0) break;\n\n      const remaining = lot.remainingAmount.toNumber();\n      const amountFromThisLot = Math.min(remaining, remainingToSell);\n      const costBasisFromThisLot = amountFromThisLot * lot.costPerUnit.toNumber();\n\n      totalCostBasis += costBasisFromThisLot;\n      remainingToSell -= amountFromThisLot;\n\n      const holdingPeriod = Math.floor(\n        (saleDate.getTime() - lot.acquiredAt.getTime()) / (1000 * 60 * 60 * 24),\n      );\n\n      lotsUsed.push({\n        lotId: lot.id,\n        amountUsed: amountFromThisLot,\n        costBasis: costBasisFromThisLot,\n        acquiredAt: lot.acquiredAt,\n        holdingPeriod,\n      });\n\n      // Update the lot's remaining amount\n      await this.prisma.cryptoLot.update({\n        where: { id: lot.id },\n        data: {\n          remainingAmount: remaining - amountFromThisLot,\n        },\n      });\n    }\n\n    if (remainingToSell > 0.00000001) {\n      this.logger.warn(\n        `Insufficient lots to cover sale of ${amountToSell}. Remaining: ${remainingToSell}`,\n      );\n    }\n\n    const realizedGain = saleProceeds - totalCostBasis;\n\n    return {\n      costBasis: totalCostBasis,\n      realizedGain,\n      lotsUsed,\n    };\n  }\n\n  /**\n   * Get current portfolio positions with cost basis\n   */\n  async getPortfolioPositions(companyId: string): Promise<PortfolioPosition[]> {\n    const assets = await this.prisma.cryptoAsset.findMany({\n      where: { companyId, isActive: true },\n    });\n\n    const positions: PortfolioPosition[] = [];\n\n    for (const asset of assets) {\n      const lots = await this.prisma.cryptoLot.findMany({\n        where: {\n          companyId,\n          cryptoAssetId: asset.id,\n          remainingAmount: { gt: 0 },\n        },\n      });\n\n      if (lots.length === 0) continue;\n\n      const totalAmount = lots.reduce((sum, lot) => sum + lot.remainingAmount.toNumber(), 0);\n      const totalCostBasis = lots.reduce(\n        (sum, lot) => sum + lot.remainingAmount.toNumber() * lot.costPerUnit.toNumber(),\n        0,\n      );\n\n      positions.push({\n        assetId: asset.id,\n        symbol: asset.symbol,\n        name: asset.name,\n        totalAmount,\n        averageCostBasis: totalAmount > 0 ? totalCostBasis / totalAmount : 0,\n        totalCostBasis,\n      });\n    }\n\n    return positions;\n  }\n\n  /**\n   * Get cost basis lots for a specific asset\n   */\n  async getLotsForAsset(\n    companyId: string,\n    cryptoAssetId: string,\n    includeExhausted: boolean = false,\n  ): Promise<CryptoLot[]> {\n    return this.prisma.cryptoLot.findMany({\n      where: {\n        companyId,\n        cryptoAssetId,\n        ...(includeExhausted ? {} : { remainingAmount: { gt: 0 } }),\n      },\n      orderBy: { acquiredAt: 'asc' },\n    });\n  }\n\n  /**\n   * Generate tax report for realized gains/losses\n   * Based on SWAP and TRANSFER_OUT transactions\n   */\n  async generateTaxReport(\n    companyId: string,\n    startDate: Date,\n    endDate: Date,\n  ): Promise<{\n    entries: TaxReportEntry[];\n    summary: {\n      totalProceeds: number;\n      totalCostBasis: number;\n      totalGainLoss: number;\n      shortTermGainLoss: number;\n      longTermGainLoss: number;\n    };\n  }> {\n    // Get wallets for this company\n    const wallets = await this.prisma.wallet.findMany({\n      where: { companyId },\n      select: { id: true },\n    });\n    const walletIds = wallets.map(w => w.id);\n\n    // Get disposal transactions (SWAP, TRANSFER_OUT) in the period\n    const transactions = await this.prisma.cryptoTransaction.findMany({\n      where: {\n        walletId: { in: walletIds },\n        type: { in: ['SWAP', 'TRANSFER_OUT'] },\n        blockTimestamp: { gte: startDate, lte: endDate },\n      },\n      orderBy: { blockTimestamp: 'asc' },\n    });\n\n    const entries: TaxReportEntry[] = [];\n    let totalProceeds = 0;\n    let totalCostBasis = 0;\n    let shortTermGainLoss = 0;\n    let longTermGainLoss = 0;\n\n    for (const tx of transactions) {\n      const costBasisData = tx.costBasis?.toNumber() || 0;\n      const gainLoss = tx.realizedGain?.toNumber() || 0;\n      const amount = tx.amountOut?.toNumber() || 0;\n      const proceeds = tx.priceOutEur?.toNumber() || 0;\n\n      // Simplified holding period calculation\n      const isLongTerm = false; // Would need lot tracking for accurate calculation\n\n      entries.push({\n        transactionId: tx.id,\n        date: tx.blockTimestamp,\n        type: tx.type,\n        assetSymbol: tx.assetOut || 'UNKNOWN',\n        amount,\n        proceeds,\n        costBasis: costBasisData,\n        gainLoss,\n        holdingPeriod: isLongTerm ? 'LONG' : 'SHORT',\n      });\n\n      totalProceeds += proceeds;\n      totalCostBasis += costBasisData;\n\n      if (isLongTerm) {\n        longTermGainLoss += gainLoss;\n      } else {\n        shortTermGainLoss += gainLoss;\n      }\n    }\n\n    return {\n      entries,\n      summary: {\n        totalProceeds,\n        totalCostBasis,\n        totalGainLoss: shortTermGainLoss + longTermGainLoss,\n        shortTermGainLoss,\n        longTermGainLoss,\n      },\n    };\n  }\n\n  /**\n   * Recalculate all cost basis lots for an asset (use with caution)\n   */\n  async recalculateForAsset(companyId: string, cryptoAssetId: string): Promise<void> {\n    this.logger.log(`Recalculating cost basis for asset ${cryptoAssetId}`);\n\n    // Delete all existing lots for this asset\n    await this.prisma.cryptoLot.deleteMany({\n      where: { companyId, cryptoAssetId },\n    });\n\n    // Get wallets for this company\n    const wallets = await this.prisma.wallet.findMany({\n      where: { companyId },\n      select: { id: true },\n    });\n    const walletIds = wallets.map(w => w.id);\n\n    // Get crypto asset info\n    const asset = await this.prisma.cryptoAsset.findUnique({\n      where: { id: cryptoAssetId },\n    });\n\n    if (!asset) {\n      this.logger.warn(`Asset ${cryptoAssetId} not found`);\n      return;\n    }\n\n    // Get all transactions for this asset in chronological order\n    const transactions = await this.prisma.cryptoTransaction.findMany({\n      where: {\n        walletId: { in: walletIds },\n        OR: [\n          { assetIn: asset.symbol },\n          { assetOut: asset.symbol },\n        ],\n      },\n      orderBy: { blockTimestamp: 'asc' },\n    });\n\n    for (const tx of transactions) {\n      const txType = tx.type;\n\n      // Acquisitions - assetIn is the received asset\n      if (tx.assetIn === asset.symbol && ['TRANSFER_IN', 'SWAP', 'CLAIM_REWARD', 'AIRDROP'].includes(txType)) {\n        const amount = tx.amountIn?.toNumber() || 0;\n        const costBasisEur = tx.priceInEur?.toNumber() || 0;\n        if (amount > 0) {\n          await this.createLot(companyId, tx.id, cryptoAssetId, amount, costBasisEur, tx.blockTimestamp);\n        }\n      }\n\n      // Disposals - assetOut is the sold asset\n      if (tx.assetOut === asset.symbol && ['TRANSFER_OUT', 'SWAP'].includes(txType)) {\n        const amount = tx.amountOut?.toNumber() || 0;\n        const proceeds = tx.priceOutEur?.toNumber() || 0;\n        if (amount > 0) {\n          const result = await this.calculateFIFO(companyId, cryptoAssetId, amount, tx.blockTimestamp, proceeds);\n\n          // Update transaction with cost basis info\n          await this.prisma.cryptoTransaction.update({\n            where: { id: tx.id },\n            data: {\n              costBasis: result.costBasis,\n              realizedGain: result.realizedGain,\n            },\n          });\n        }\n      }\n    }\n\n    this.logger.log(`Completed cost basis recalculation for asset ${cryptoAssetId}`);\n  }\n}\n"],"names":["CostBasisService","createLot","companyId","sourceTxId","cryptoAssetId","amount","costBasisEur","acquiredAt","prisma","cryptoLot","create","data","sourceType","acquiredAmount","remainingAmount","costPerUnit","calculateFIFO","amountToSell","saleDate","saleProceeds","lots","findMany","where","gt","orderBy","remainingToSell","totalCostBasis","lotsUsed","lot","remaining","toNumber","amountFromThisLot","Math","min","costBasisFromThisLot","holdingPeriod","floor","getTime","push","lotId","id","amountUsed","costBasis","update","logger","warn","realizedGain","getPortfolioPositions","assets","cryptoAsset","isActive","positions","asset","length","totalAmount","reduce","sum","assetId","symbol","name","averageCostBasis","getLotsForAsset","includeExhausted","generateTaxReport","startDate","endDate","wallets","wallet","select","walletIds","map","w","transactions","cryptoTransaction","walletId","in","type","blockTimestamp","gte","lte","entries","totalProceeds","shortTermGainLoss","longTermGainLoss","tx","costBasisData","gainLoss","amountOut","proceeds","priceOutEur","isLongTerm","transactionId","date","assetSymbol","assetOut","summary","totalGainLoss","recalculateForAsset","log","deleteMany","findUnique","OR","assetIn","txType","includes","amountIn","priceInEur","result","Logger"],"mappings":"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"}