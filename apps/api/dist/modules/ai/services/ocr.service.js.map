{"version":3,"sources":["../../../../src/modules/ai/services/ocr.service.ts"],"sourcesContent":["import { Injectable, Logger, Optional } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { AIProviderService } from './ai-provider.service.js';\nimport { PaddleOcrClient } from './paddle-ocr.client.js';\n\n/**\n * OCR Service for Invoice Data Extraction\n * Supports multiple OCR backends with fallback chain:\n * 1. Google Cloud Vision API (if configured)\n * 2. PaddleOCR self-hosted (if running)\n * 3. AI-based extraction using LLM (always available)\n */\n\nexport interface ExtractedInvoiceData {\n  // Issuer\n  issuerName: string | null;\n  issuerTaxId: string | null;\n  issuerAddress: string | null;\n\n  // Recipient\n  recipientName: string | null;\n  recipientTaxId: string | null;\n  recipientAddress: string | null;\n\n  // Invoice details\n  invoiceNumber: string | null;\n  invoiceDate: string | null;\n  dueDate: string | null;\n\n  // Amounts\n  subtotal: number | null;\n  taxRate: number | null;\n  taxAmount: number | null;\n  total: number | null;\n  currency: string;\n\n  // Line items\n  lineItems: Array<{\n    description: string;\n    quantity: number | null;\n    unitPrice: number | null;\n    amount: number | null;\n  }>;\n\n  // Metadata\n  confidence: number;\n  rawText: string;\n  provider: 'google-vision' | 'paddleocr' | 'ai-extraction';\n  processingTimeMs: number;\n}\n\nexport interface OcrResult {\n  success: boolean;\n  data: ExtractedInvoiceData | null;\n  error?: string;\n}\n\n@Injectable()\nexport class OcrService {\n  private readonly logger = new Logger(OcrService.name);\n  private googleVisionEnabled = false;\n  private googleApiKey: string | null = null;\n\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly aiProvider: AIProviderService,\n    @Optional() private readonly paddleOcr?: PaddleOcrClient,\n  ) {\n    this.googleApiKey = this.configService.get<string>('GOOGLE_CLOUD_API_KEY') || null;\n    this.googleVisionEnabled = !!this.googleApiKey;\n\n    if (this.googleVisionEnabled) {\n      this.logger.log('Google Cloud Vision API enabled for OCR');\n    }\n\n    if (this.paddleOcr) {\n      this.logger.log('PaddleOCR client available for self-hosted OCR');\n    }\n\n    this.logger.log('OCR fallback chain: Google Vision → PaddleOCR → AI extraction');\n  }\n\n  /**\n   * Extract invoice data from an image or PDF\n   * @param fileBuffer - File content as Buffer\n   * @param mimeType - MIME type (image/jpeg, image/png, application/pdf)\n   */\n  async extractInvoiceData(\n    fileBuffer: Buffer,\n    mimeType: string,\n  ): Promise<OcrResult> {\n    const startTime = Date.now();\n\n    try {\n      // 1. Try Google Vision first if available\n      if (this.googleVisionEnabled) {\n        try {\n          const result = await this.extractWithGoogleVision(fileBuffer, mimeType);\n          result.processingTimeMs = Date.now() - startTime;\n          return { success: true, data: result };\n        } catch (error) {\n          this.logger.warn(\n            `Google Vision failed, trying PaddleOCR: ${(error as Error).message}`,\n          );\n        }\n      }\n\n      // 2. Try PaddleOCR if available\n      if (this.paddleOcr) {\n        try {\n          const paddleResult = await this.paddleOcr.extractText(fileBuffer);\n          if (paddleResult.success && paddleResult.text) {\n            this.logger.log('PaddleOCR extracted text successfully, parsing with AI');\n            const result = await this.parseInvoiceText(paddleResult.text, 'paddleocr');\n            result.processingTimeMs = Date.now() - startTime;\n            return { success: true, data: result };\n          } else {\n            this.logger.warn(`PaddleOCR failed: ${paddleResult.error}, falling back to AI extraction`);\n          }\n        } catch (error) {\n          this.logger.warn(\n            `PaddleOCR extraction error, falling back to AI: ${(error as Error).message}`,\n          );\n        }\n      }\n\n      // 3. Fallback to AI-based extraction\n      const result = await this.extractWithAI(fileBuffer, mimeType);\n      result.processingTimeMs = Date.now() - startTime;\n      return { success: true, data: result };\n    } catch (error) {\n      this.logger.error(`All OCR methods failed: ${(error as Error).message}`);\n      return {\n        success: false,\n        data: null,\n        error: (error as Error).message,\n      };\n    }\n  }\n\n  /**\n   * Extract text using Google Cloud Vision API\n   */\n  private async extractWithGoogleVision(\n    fileBuffer: Buffer,\n    mimeType: string,\n  ): Promise<ExtractedInvoiceData> {\n    const base64Content = fileBuffer.toString('base64');\n\n    const requestBody = {\n      requests: [\n        {\n          image: {\n            content: base64Content,\n          },\n          features: [\n            { type: 'TEXT_DETECTION', maxResults: 1 },\n            { type: 'DOCUMENT_TEXT_DETECTION', maxResults: 1 },\n          ],\n        },\n      ],\n    };\n\n    const response = await fetch(\n      `https://vision.googleapis.com/v1/images:annotate?key=${this.googleApiKey}`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody),\n      },\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Google Vision API error: ${response.status} - ${error}`);\n    }\n\n    const data = (await response.json()) as {\n      responses: Array<{\n        fullTextAnnotation?: { text: string };\n        textAnnotations?: Array<{ description: string }>;\n        error?: { message: string };\n      }>;\n    };\n\n    if (data.responses[0]?.error) {\n      throw new Error(data.responses[0].error.message);\n    }\n\n    const rawText =\n      data.responses[0]?.fullTextAnnotation?.text ||\n      data.responses[0]?.textAnnotations?.[0]?.description ||\n      '';\n\n    if (!rawText) {\n      throw new Error('No text detected in image');\n    }\n\n    // Parse the raw text using AI\n    return this.parseInvoiceText(rawText, 'google-vision');\n  }\n\n  /**\n   * Extract text using AI-based OCR (for images sent as base64 to vision-capable models)\n   */\n  private async extractWithAI(\n    fileBuffer: Buffer,\n    mimeType: string,\n  ): Promise<ExtractedInvoiceData> {\n    const base64Content = fileBuffer.toString('base64');\n\n    // Use AI to describe and extract data from the image\n    const prompt = `Analiza esta imagen de una factura y extrae los siguientes datos en formato JSON.\nSi no puedes ver claramente un campo, usa null.\n\nLa respuesta DEBE ser SOLO un objeto JSON válido con esta estructura exacta:\n{\n  \"issuerName\": \"nombre del emisor\",\n  \"issuerTaxId\": \"NIF/CIF del emisor\",\n  \"issuerAddress\": \"dirección del emisor\",\n  \"recipientName\": \"nombre del destinatario\",\n  \"recipientTaxId\": \"NIF/CIF del destinatario\",\n  \"recipientAddress\": \"dirección del destinatario\",\n  \"invoiceNumber\": \"número de factura\",\n  \"invoiceDate\": \"fecha de emisión en formato YYYY-MM-DD\",\n  \"dueDate\": \"fecha de vencimiento en formato YYYY-MM-DD o null\",\n  \"subtotal\": numero_base_imponible,\n  \"taxRate\": porcentaje_iva,\n  \"taxAmount\": importe_iva,\n  \"total\": importe_total,\n  \"currency\": \"EUR\",\n  \"lineItems\": [\n    {\n      \"description\": \"descripción\",\n      \"quantity\": cantidad,\n      \"unitPrice\": precio_unitario,\n      \"amount\": importe\n    }\n  ],\n  \"confidence\": 0.0 a 1.0\n}`;\n\n    // For AI extraction, we'll try to use the AI provider to analyze the invoice\n    // Since most models support vision, we can send the image\n    try {\n      const response = await this.aiProvider.chat(\n        [\n          {\n            role: 'user',\n            content: `${prompt}\\n\\n[Imagen de factura en base64: ${base64Content.substring(0, 100)}... (${mimeType})]`,\n          },\n        ],\n        {\n          systemPrompt:\n            'Eres un experto en procesamiento de facturas. Extrae datos de facturas con precisión. Responde SOLO con JSON válido, sin markdown ni explicaciones.',\n          maxTokens: 2000,\n          temperature: 0.1,\n        },\n      );\n\n      // Try to parse the JSON response\n      const jsonMatch = response.content.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('AI response did not contain valid JSON');\n      }\n\n      const parsed = JSON.parse(jsonMatch[0]);\n      return this.normalizeExtractedData(parsed, 'ai-extraction', response.content);\n    } catch (error) {\n      this.logger.error(`AI extraction failed: ${(error as Error).message}`);\n      // Return empty result with low confidence\n      return this.createEmptyResult('ai-extraction', '');\n    }\n  }\n\n  /**\n   * Parse raw text from OCR into structured invoice data\n   */\n  private async parseInvoiceText(\n    rawText: string,\n    provider: 'google-vision' | 'paddleocr' | 'ai-extraction',\n  ): Promise<ExtractedInvoiceData> {\n    const prompt = `Analiza el siguiente texto extraído de una factura española y extrae los datos estructurados.\n\nTEXTO DE LA FACTURA:\n${rawText}\n\nExtrae los datos en formato JSON con esta estructura exacta:\n{\n  \"issuerName\": \"nombre del emisor o null\",\n  \"issuerTaxId\": \"NIF/CIF del emisor (formato español: letra+8digitos o 8digitos+letra) o null\",\n  \"issuerAddress\": \"dirección completa del emisor o null\",\n  \"recipientName\": \"nombre del destinatario o null\",\n  \"recipientTaxId\": \"NIF/CIF del destinatario o null\",\n  \"recipientAddress\": \"dirección del destinatario o null\",\n  \"invoiceNumber\": \"número de factura (puede incluir serie) o null\",\n  \"invoiceDate\": \"fecha en formato YYYY-MM-DD o null\",\n  \"dueDate\": \"fecha vencimiento YYYY-MM-DD o null\",\n  \"subtotal\": numero_decimal_base_imponible o null,\n  \"taxRate\": porcentaje_iva_como_numero (ej: 21) o null,\n  \"taxAmount\": numero_decimal_cuota_iva o null,\n  \"total\": numero_decimal_total o null,\n  \"currency\": \"EUR\" o la moneda detectada,\n  \"lineItems\": [\n    {\n      \"description\": \"descripción del concepto\",\n      \"quantity\": numero o null,\n      \"unitPrice\": numero o null,\n      \"amount\": numero o null\n    }\n  ],\n  \"confidence\": numero de 0.0 a 1.0 indicando confianza en la extracción\n}\n\nIMPORTANTE:\n- Los importes deben ser números decimales (ej: 1234.56), no strings\n- Las fechas deben estar en formato YYYY-MM-DD\n- Si un campo no se encuentra claramente, usa null\n- La confianza debe reflejar qué tan seguros estamos de los datos extraídos\n\nResponde SOLO con el JSON, sin explicaciones adicionales.`;\n\n    try {\n      const response = await this.aiProvider.chat(\n        [{ role: 'user', content: prompt }],\n        {\n          systemPrompt:\n            'Eres un experto en procesamiento de facturas españolas. Tu tarea es extraer datos estructurados del texto de facturas. Responde SOLO con JSON válido.',\n          maxTokens: 2000,\n          temperature: 0.1,\n        },\n      );\n\n      // Extract JSON from response\n      const jsonMatch = response.content.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('Response did not contain valid JSON');\n      }\n\n      const parsed = JSON.parse(jsonMatch[0]);\n      return this.normalizeExtractedData(parsed, provider, rawText);\n    } catch (error) {\n      this.logger.warn(\n        `Failed to parse invoice text with AI: ${(error as Error).message}`,\n      );\n      // Return with raw text but low confidence\n      return this.createEmptyResult(provider, rawText);\n    }\n  }\n\n  /**\n   * Normalize and validate extracted data\n   */\n  private normalizeExtractedData(\n    data: Record<string, unknown>,\n    provider: 'google-vision' | 'paddleocr' | 'ai-extraction',\n    rawText: string,\n  ): ExtractedInvoiceData {\n    return {\n      issuerName: this.normalizeString(data.issuerName),\n      issuerTaxId: this.normalizeTaxId(data.issuerTaxId),\n      issuerAddress: this.normalizeString(data.issuerAddress),\n      recipientName: this.normalizeString(data.recipientName),\n      recipientTaxId: this.normalizeTaxId(data.recipientTaxId),\n      recipientAddress: this.normalizeString(data.recipientAddress),\n      invoiceNumber: this.normalizeString(data.invoiceNumber),\n      invoiceDate: this.normalizeDate(data.invoiceDate),\n      dueDate: this.normalizeDate(data.dueDate),\n      subtotal: this.normalizeNumber(data.subtotal),\n      taxRate: this.normalizeNumber(data.taxRate),\n      taxAmount: this.normalizeNumber(data.taxAmount),\n      total: this.normalizeNumber(data.total),\n      currency: this.normalizeString(data.currency) || 'EUR',\n      lineItems: this.normalizeLineItems(data.lineItems),\n      confidence: this.normalizeNumber(data.confidence) || 0.5,\n      rawText,\n      provider,\n      processingTimeMs: 0,\n    };\n  }\n\n  private normalizeString(value: unknown): string | null {\n    if (typeof value === 'string' && value.trim()) {\n      return value.trim();\n    }\n    return null;\n  }\n\n  private normalizeNumber(value: unknown): number | null {\n    if (typeof value === 'number' && !isNaN(value)) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      const parsed = parseFloat(value.replace(',', '.').replace(/[^\\d.-]/g, ''));\n      if (!isNaN(parsed)) {\n        return parsed;\n      }\n    }\n    return null;\n  }\n\n  private normalizeDate(value: unknown): string | null {\n    if (typeof value === 'string' && value.trim()) {\n      // Try to parse and format as YYYY-MM-DD\n      const dateStr = value.trim();\n      // Check if already in YYYY-MM-DD format\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n        return dateStr;\n      }\n      // Try to parse common Spanish formats (DD/MM/YYYY, DD-MM-YYYY)\n      const match = dateStr.match(/^(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})$/);\n      if (match) {\n        const [, day, month, year] = match;\n        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n      }\n    }\n    return null;\n  }\n\n  private normalizeTaxId(value: unknown): string | null {\n    if (typeof value === 'string' && value.trim()) {\n      // Clean and uppercase Spanish tax ID\n      const cleaned = value.trim().toUpperCase().replace(/[^A-Z0-9]/g, '');\n      // Basic Spanish NIF/CIF validation (8 digits + letter or letter + 8 chars)\n      if (/^[A-Z]\\d{8}$/.test(cleaned) || /^\\d{8}[A-Z]$/.test(cleaned) || /^[A-Z]\\d{7}[A-Z0-9]$/.test(cleaned)) {\n        return cleaned;\n      }\n      // Return as-is if it looks like a tax ID\n      if (cleaned.length >= 8 && cleaned.length <= 12) {\n        return cleaned;\n      }\n    }\n    return null;\n  }\n\n  private normalizeLineItems(\n    value: unknown,\n  ): ExtractedInvoiceData['lineItems'] {\n    if (!Array.isArray(value)) {\n      return [];\n    }\n    return value\n      .filter((item): item is Record<string, unknown> => typeof item === 'object' && item !== null)\n      .map((item) => ({\n        description: this.normalizeString(item.description) || '',\n        quantity: this.normalizeNumber(item.quantity),\n        unitPrice: this.normalizeNumber(item.unitPrice),\n        amount: this.normalizeNumber(item.amount),\n      }))\n      .filter((item) => item.description);\n  }\n\n  private createEmptyResult(\n    provider: 'google-vision' | 'paddleocr' | 'ai-extraction',\n    rawText: string,\n  ): ExtractedInvoiceData {\n    return {\n      issuerName: null,\n      issuerTaxId: null,\n      issuerAddress: null,\n      recipientName: null,\n      recipientTaxId: null,\n      recipientAddress: null,\n      invoiceNumber: null,\n      invoiceDate: null,\n      dueDate: null,\n      subtotal: null,\n      taxRate: null,\n      taxAmount: null,\n      total: null,\n      currency: 'EUR',\n      lineItems: [],\n      confidence: 0.1,\n      rawText,\n      provider,\n      processingTimeMs: 0,\n    };\n  }\n\n  /**\n   * Check OCR service status\n   */\n  getStatus(): {\n    googleVisionEnabled: boolean;\n    paddleOcrEnabled: boolean;\n    paddleOcrUrl?: string;\n    aiExtractionEnabled: boolean;\n  } {\n    const paddleStatus = this.paddleOcr?.getStatus();\n\n    return {\n      googleVisionEnabled: this.googleVisionEnabled,\n      paddleOcrEnabled: paddleStatus?.enabled || false,\n      paddleOcrUrl: paddleStatus?.url,\n      aiExtractionEnabled: true, // Always available via AI provider\n    };\n  }\n}\n"],"names":["OcrService","extractInvoiceData","fileBuffer","mimeType","startTime","Date","now","googleVisionEnabled","result","extractWithGoogleVision","processingTimeMs","success","data","error","logger","warn","message","paddleOcr","paddleResult","extractText","text","log","parseInvoiceText","extractWithAI","base64Content","toString","requestBody","requests","image","content","features","type","maxResults","response","fetch","googleApiKey","method","headers","body","JSON","stringify","ok","Error","status","json","responses","rawText","fullTextAnnotation","textAnnotations","description","prompt","aiProvider","chat","role","substring","systemPrompt","maxTokens","temperature","jsonMatch","match","parsed","parse","normalizeExtractedData","createEmptyResult","provider","issuerName","normalizeString","issuerTaxId","normalizeTaxId","issuerAddress","recipientName","recipientTaxId","recipientAddress","invoiceNumber","invoiceDate","normalizeDate","dueDate","subtotal","normalizeNumber","taxRate","taxAmount","total","currency","lineItems","normalizeLineItems","confidence","value","trim","isNaN","parseFloat","replace","dateStr","test","day","month","year","padStart","cleaned","toUpperCase","length","Array","isArray","filter","item","map","quantity","unitPrice","amount","getStatus","paddleStatus","paddleOcrEnabled","enabled","paddleOcrUrl","url","aiExtractionEnabled","configService","Logger","name","get"],"mappings":"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"}