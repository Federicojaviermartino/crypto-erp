{"version":3,"sources":["../../../src/modules/auth/auth.service.ts"],"sourcesContent":["import {\n  Injectable,\n  ConflictException,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport * as bcrypt from 'bcrypt';\nimport { PrismaService } from '@crypto-erp/database';\nimport { RegisterDto, LoginDto, TokenResponseDto } from './dto/index.js';\nimport type { JwtPayload } from '../../common/decorators/current-user.decorator.js';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private prisma: PrismaService,\n    private jwtService: JwtService,\n    private configService: ConfigService,\n  ) {}\n\n  async register(dto: RegisterDto): Promise<TokenResponseDto> {\n    // Check if user exists\n    const existingUser = await this.prisma.user.findUnique({\n      where: { email: dto.email.toLowerCase() },\n    });\n\n    if (existingUser) {\n      throw new ConflictException('Email already registered');\n    }\n\n    // Hash password\n    const passwordHash = await bcrypt.hash(dto.password, 12);\n\n    // Create user\n    const user = await this.prisma.user.create({\n      data: {\n        email: dto.email.toLowerCase(),\n        passwordHash,\n        firstName: dto.firstName,\n        lastName: dto.lastName,\n      },\n    });\n\n    return this.generateTokens(user);\n  }\n\n  async login(dto: LoginDto): Promise<TokenResponseDto> {\n    const user = await this.validateUser(dto.email, dto.password);\n    if (!user) {\n      throw new UnauthorizedException('Invalid email or password');\n    }\n\n    // Get full user to check 2FA status\n    const fullUser = await this.prisma.user.findUniqueOrThrow({\n      where: { id: user.id },\n    });\n\n    // Check if 2FA is enabled\n    if (fullUser.twoFactorEnabled) {\n      if (!dto.twoFactorToken) {\n        throw new UnauthorizedException({\n          code: 'TWO_FACTOR_REQUIRED',\n          message: '2FA token required',\n        });\n      }\n\n      // Verify 2FA token (will be injected via TwoFactorService)\n      // For now, we'll add the service in the next step\n      const { TwoFactorService } = await import('./services/two-factor.service.js');\n      const twoFactorService = new TwoFactorService(this.prisma, null as any);\n\n      const isValid2FA = await twoFactorService.verifyUserToken(\n        fullUser.id,\n        dto.twoFactorToken,\n      );\n\n      if (!isValid2FA) {\n        throw new UnauthorizedException('Invalid 2FA token');\n      }\n    }\n\n    // Update last login\n    await this.prisma.user.update({\n      where: { id: user.id },\n      data: { lastLoginAt: new Date() },\n    });\n\n    return this.generateTokens(fullUser);\n  }\n\n  async validateUser(\n    email: string,\n    password: string,\n  ): Promise<{ id: string; email: string } | null> {\n    const user = await this.prisma.user.findUnique({\n      where: { email: email.toLowerCase() },\n    });\n\n    if (!user || !user.isActive) {\n      return null;\n    }\n\n    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);\n    if (!isPasswordValid) {\n      return null;\n    }\n\n    return { id: user.id, email: user.email };\n  }\n\n  async refreshTokens(refreshToken: string): Promise<TokenResponseDto> {\n    try {\n      const payload = this.jwtService.verify<JwtPayload>(refreshToken, {\n        secret: this.configService.get<string>('jwt.refreshSecret'),\n      });\n\n      const user = await this.prisma.user.findUnique({\n        where: { id: payload.sub },\n      });\n\n      if (!user || !user.isActive) {\n        throw new UnauthorizedException('User not found or inactive');\n      }\n\n      return this.generateTokens(user);\n    } catch {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n  }\n\n  async getMe(userId: string) {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        firstName: true,\n        lastName: true,\n        avatarUrl: true,\n        createdAt: true,\n        companyUsers: {\n          include: {\n            company: {\n              select: {\n                id: true,\n                name: true,\n                taxId: true,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (!user) {\n      throw new UnauthorizedException('User not found');\n    }\n\n    return {\n      ...user,\n      companies: user.companyUsers.map((cu) => ({\n        ...cu.company,\n        role: cu.role,\n        isDefault: cu.isDefault,\n      })),\n      companyUsers: undefined,\n    };\n  }\n\n  async findOrCreateSSOUser(ssoData: {\n    ssoProvider: string;\n    ssoId: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n    avatarUrl?: string;\n    ssoMetadata?: any;\n  }) {\n    // Try to find existing SSO user\n    let user = await this.prisma.user.findUnique({\n      where: {\n        ssoProvider_ssoId: {\n          ssoProvider: ssoData.ssoProvider,\n          ssoId: ssoData.ssoId,\n        },\n      },\n    });\n\n    if (!user) {\n      // Check if email already exists (link existing account)\n      const existingEmailUser = await this.prisma.user.findUnique({\n        where: { email: ssoData.email.toLowerCase() },\n      });\n\n      if (existingEmailUser) {\n        // Link SSO to existing account\n        user = await this.prisma.user.update({\n          where: { id: existingEmailUser.id },\n          data: {\n            ssoProvider: ssoData.ssoProvider,\n            ssoId: ssoData.ssoId,\n            ssoMetadata: ssoData.ssoMetadata || {},\n            avatarUrl: ssoData.avatarUrl || existingEmailUser.avatarUrl,\n          },\n        });\n      } else {\n        // Create new user (auto-provisioning)\n        user = await this.prisma.user.create({\n          data: {\n            email: ssoData.email.toLowerCase(),\n            passwordHash: '', // No password for SSO users\n            firstName: ssoData.firstName,\n            lastName: ssoData.lastName,\n            avatarUrl: ssoData.avatarUrl,\n            ssoProvider: ssoData.ssoProvider,\n            ssoId: ssoData.ssoId,\n            ssoMetadata: ssoData.ssoMetadata || {},\n            isActive: true,\n          },\n        });\n      }\n    } else {\n      // Update last login and metadata\n      user = await this.prisma.user.update({\n        where: { id: user.id },\n        data: {\n          lastLoginAt: new Date(),\n          ssoMetadata: ssoData.ssoMetadata || user.ssoMetadata,\n        },\n      });\n    }\n\n    return user;\n  }\n\n  getSamlMetadata(): string {\n    const issuer = this.configService.get<string>('SAML_ISSUER');\n    const callbackUrl = this.configService.get<string>('SAML_CALLBACK_URL');\n\n    return `<?xml version=\"1.0\"?>\n<EntityDescriptor xmlns=\"urn:oasis:names:tc:SAML:2.0:metadata\" entityID=\"${issuer}\">\n  <SPSSODescriptor protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\">\n    <AssertionConsumerService\n      Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\n      Location=\"${callbackUrl}\"\n      index=\"1\"/>\n  </SPSSODescriptor>\n</EntityDescriptor>`;\n  }\n\n  generateTokens(user: {\n    id: string;\n    email: string;\n    firstName: string;\n    lastName: string;\n  }): TokenResponseDto {\n    const payload: JwtPayload = { sub: user.id, email: user.email };\n\n    const accessToken = this.jwtService.sign(payload, {\n      secret: this.configService.get<string>('jwt.secret'),\n      expiresIn: this.configService.get<string>('jwt.accessExpiresIn') || '15m',\n    });\n\n    const refreshToken = this.jwtService.sign(payload, {\n      secret: this.configService.get<string>('jwt.refreshSecret'),\n      expiresIn: this.configService.get<string>('jwt.refreshExpiresIn') || '7d',\n    });\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: 900, // 15 minutes in seconds\n      user: {\n        id: user.id,\n        email: user.email,\n        firstName: user.firstName,\n        lastName: user.lastName,\n      },\n    };\n  }\n}\n"],"names":["AuthService","register","dto","existingUser","prisma","user","findUnique","where","email","toLowerCase","ConflictException","passwordHash","bcrypt","hash","password","create","data","firstName","lastName","generateTokens","login","validateUser","UnauthorizedException","fullUser","findUniqueOrThrow","id","twoFactorEnabled","twoFactorToken","code","message","TwoFactorService","twoFactorService","isValid2FA","verifyUserToken","update","lastLoginAt","Date","isActive","isPasswordValid","compare","refreshTokens","refreshToken","payload","jwtService","verify","secret","configService","get","sub","getMe","userId","select","avatarUrl","createdAt","companyUsers","include","company","name","taxId","companies","map","cu","role","isDefault","undefined","findOrCreateSSOUser","ssoData","ssoProvider_ssoId","ssoProvider","ssoId","existingEmailUser","ssoMetadata","getSamlMetadata","issuer","callbackUrl","accessToken","sign","expiresIn"],"mappings":"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"}