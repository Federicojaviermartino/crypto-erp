{"version":3,"sources":["../../../../src/modules/auth/services/two-factor.service.ts"],"sourcesContent":["import { Injectable, BadRequestException, UnauthorizedException } from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { CryptoService } from './crypto.service';\nimport * as speakeasy from 'speakeasy';\nimport * as QRCode from 'qrcode';\nimport * as crypto from 'crypto';\n\n@Injectable()\nexport class TwoFactorService {\n  constructor(\n    private prisma: PrismaService,\n    private cryptoService: CryptoService,\n  ) {}\n\n  /**\n   * Generate 2FA secret and QR code for user\n   */\n  async generateSecret(userId: string): Promise<{ secret: string; qrCode: string; backupCodes: string[] }> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user) {\n      throw new BadRequestException('User not found');\n    }\n\n    if (user.twoFactorEnabled) {\n      throw new BadRequestException('2FA is already enabled for this user');\n    }\n\n    // Generate TOTP secret\n    const secret = speakeasy.generateSecret({\n      name: `Crypto-ERP (${user.email})`,\n      issuer: 'Crypto-ERP',\n      length: 32,\n    });\n\n    // Generate QR code\n    const qrCode = await QRCode.toDataURL(secret.otpauth_url!);\n\n    // Generate backup codes (10 codes)\n    const backupCodes = Array.from({ length: 10 }, () =>\n      crypto.randomBytes(4).toString('hex').toUpperCase(),\n    );\n\n    return {\n      secret: secret.base32,\n      qrCode,\n      backupCodes,\n    };\n  }\n\n  /**\n   * Enable 2FA for user after verifying the first token\n   */\n  async enable2FA(\n    userId: string,\n    secret: string,\n    token: string,\n    backupCodes: string[],\n  ): Promise<void> {\n    // Verify the token first\n    const isValid = this.verifyToken(secret, token);\n\n    if (!isValid) {\n      throw new BadRequestException('Invalid 2FA token. Please check your authenticator app.');\n    }\n\n    // Encrypt secret and backup codes before storing\n    const encryptedSecret = await this.cryptoService.encrypt(secret);\n    const encryptedBackupCodes = await this.cryptoService.encrypt(\n      JSON.stringify(backupCodes),\n    );\n\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: {\n        twoFactorEnabled: true,\n        twoFactorSecret: encryptedSecret,\n        twoFactorBackupCodes: encryptedBackupCodes,\n      },\n    });\n  }\n\n  /**\n   * Disable 2FA for user (requires password verification in controller)\n   */\n  async disable2FA(userId: string): Promise<void> {\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: {\n        twoFactorEnabled: false,\n        twoFactorSecret: null,\n        twoFactorBackupCodes: null,\n      },\n    });\n  }\n\n  /**\n   * Verify a TOTP token\n   */\n  verifyToken(secret: string, token: string): boolean {\n    return speakeasy.totp.verify({\n      secret,\n      encoding: 'base32',\n      token,\n      window: 2, // Allow 2 time steps before/after for clock drift (60 seconds)\n    });\n  }\n\n  /**\n   * Verify user's 2FA token (TOTP or backup code)\n   */\n  async verifyUserToken(userId: string, token: string): Promise<boolean> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user || !user.twoFactorEnabled || !user.twoFactorSecret) {\n      return true; // 2FA not enabled, allow through\n    }\n\n    // Decrypt the secret\n    const secret = await this.cryptoService.decrypt(user.twoFactorSecret);\n\n    // Try TOTP token first\n    if (this.verifyToken(secret, token)) {\n      return true;\n    }\n\n    // Try backup codes\n    if (user.twoFactorBackupCodes) {\n      const backupCodes = JSON.parse(\n        await this.cryptoService.decrypt(user.twoFactorBackupCodes),\n      );\n\n      if (backupCodes.includes(token)) {\n        // Remove the used backup code\n        const updatedCodes = backupCodes.filter((code: string) => code !== token);\n\n        await this.prisma.user.update({\n          where: { id: userId },\n          data: {\n            twoFactorBackupCodes: await this.cryptoService.encrypt(\n              JSON.stringify(updatedCodes),\n            ),\n          },\n        });\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get remaining backup codes count\n   */\n  async getRemainingBackupCodes(userId: string): Promise<number> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user || !user.twoFactorBackupCodes) {\n      return 0;\n    }\n\n    const backupCodes = JSON.parse(\n      await this.cryptoService.decrypt(user.twoFactorBackupCodes),\n    );\n\n    return backupCodes.length;\n  }\n\n  /**\n   * Regenerate backup codes\n   */\n  async regenerateBackupCodes(userId: string): Promise<string[]> {\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user || !user.twoFactorEnabled) {\n      throw new BadRequestException('2FA is not enabled for this user');\n    }\n\n    // Generate new backup codes\n    const backupCodes = Array.from({ length: 10 }, () =>\n      crypto.randomBytes(4).toString('hex').toUpperCase(),\n    );\n\n    const encryptedBackupCodes = await this.cryptoService.encrypt(\n      JSON.stringify(backupCodes),\n    );\n\n    await this.prisma.user.update({\n      where: { id: userId },\n      data: {\n        twoFactorBackupCodes: encryptedBackupCodes,\n      },\n    });\n\n    return backupCodes;\n  }\n}\n"],"names":["TwoFactorService","generateSecret","userId","user","prisma","findUnique","where","id","BadRequestException","twoFactorEnabled","secret","speakeasy","name","email","issuer","length","qrCode","QRCode","toDataURL","otpauth_url","backupCodes","Array","from","crypto","randomBytes","toString","toUpperCase","base32","enable2FA","token","isValid","verifyToken","encryptedSecret","cryptoService","encrypt","encryptedBackupCodes","JSON","stringify","update","data","twoFactorSecret","twoFactorBackupCodes","disable2FA","totp","verify","encoding","window","verifyUserToken","decrypt","parse","includes","updatedCodes","filter","code","getRemainingBackupCodes","regenerateBackupCodes"],"mappings":"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"}