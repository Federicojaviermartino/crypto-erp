{"version":3,"sources":["../../../../src/modules/integrations/quickbooks/quickbooks.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { IntegrationProvider, SyncResult, PushResult } from '../base/integration.interface.js';\nimport { BaseIntegrationService } from '../base/base-integration.service.js';\nimport axios from 'axios';\n\n/**\n * QuickBooks Online Integration\n *\n * Provides bi-directional sync with QuickBooks Online:\n * - Sync invoices from QuickBooks to Crypto ERP\n * - Push invoices from Crypto ERP to QuickBooks\n * - Sync customers/contacts\n * - Sync payments\n *\n * OAuth 2.0 Flow:\n * 1. User clicks \"Connect QuickBooks\"\n * 2. Redirect to QuickBooks authorization URL\n * 3. User authorizes app\n * 4. QuickBooks redirects back with authorization code\n * 5. Exchange code for access token and refresh token\n * 6. Store encrypted tokens in database\n */\n@Injectable()\nexport class QuickBooksService implements IntegrationProvider {\n  readonly provider = 'quickbooks';\n  private readonly logger = new Logger(QuickBooksService.name);\n\n  private readonly authUrl = 'https://appcenter.intuit.com/connect/oauth2';\n  private readonly tokenUrl = 'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer';\n  private readonly apiBaseUrl = 'https://quickbooks.api.intuit.com/v3/company';\n  private readonly revokeUrl = 'https://developer.api.intuit.com/v2/oauth2/tokens/revoke';\n\n  private readonly clientId: string;\n  private readonly clientSecret: string;\n  private readonly scopes = [\n    'com.intuit.quickbooks.accounting',\n  ];\n\n  constructor(\n    private readonly baseService: BaseIntegrationService,\n    private readonly config: ConfigService,\n  ) {\n    this.clientId = this.config.get<string>('QUICKBOOKS_CLIENT_ID') || '';\n    this.clientSecret = this.config.get<string>('QUICKBOOKS_CLIENT_SECRET') || '';\n  }\n\n  /**\n   * Get QuickBooks OAuth authorization URL\n   */\n  getAuthorizationUrl(companyId: string, redirectUri: string, state: string): string {\n    const params = new URLSearchParams({\n      client_id: this.clientId,\n      redirect_uri: redirectUri,\n      response_type: 'code',\n      scope: this.scopes.join(' '),\n      state,\n    });\n\n    return `${this.authUrl}?${params.toString()}`;\n  }\n\n  /**\n   * Exchange authorization code for access token\n   */\n  async exchangeCodeForToken(code: string, redirectUri: string) {\n    const auth = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString('base64');\n\n    const response = await axios.post(\n      this.tokenUrl,\n      new URLSearchParams({\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: redirectUri,\n      }),\n      {\n        headers: {\n          Accept: 'application/json',\n          Authorization: `Basic ${auth}`,\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    );\n\n    return {\n      accessToken: response.data.access_token,\n      refreshToken: response.data.refresh_token,\n      expiresIn: response.data.expires_in, // 3600 seconds (1 hour)\n      metadata: {\n        realmId: response.data.realmId, // QuickBooks company ID\n      },\n    };\n  }\n\n  /**\n   * Refresh access token\n   */\n  async refreshAccessToken(refreshToken: string) {\n    const auth = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString('base64');\n\n    const response = await axios.post(\n      this.tokenUrl,\n      new URLSearchParams({\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n      }),\n      {\n        headers: {\n          Accept: 'application/json',\n          Authorization: `Basic ${auth}`,\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n      },\n    );\n\n    return {\n      accessToken: response.data.access_token,\n      refreshToken: response.data.refresh_token,\n      expiresIn: response.data.expires_in,\n    };\n  }\n\n  /**\n   * Test connection by fetching company info\n   */\n  async testConnection(accessToken: string): Promise<boolean> {\n    try {\n      // Get company info to test connection\n      const integration = await this.baseService.getIntegration('', this.provider);\n      if (!integration?.metadata?.['realmId']) {\n        return false;\n      }\n\n      const realmId = integration.metadata['realmId'] as string;\n\n      await axios.get(\n        `${this.apiBaseUrl}/${realmId}/companyinfo/${realmId}`,\n        {\n          headers: {\n            Accept: 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        },\n      );\n\n      return true;\n    } catch (error) {\n      this.logger.error('QuickBooks connection test failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Sync invoices from QuickBooks to Crypto ERP\n   */\n  async syncData(integrationId: string, accessToken: string): Promise<SyncResult> {\n    try {\n      const integration = await this.baseService.prisma.integration.findUnique({\n        where: { id: integrationId },\n      });\n\n      if (!integration?.metadata?.['realmId']) {\n        throw new Error('QuickBooks realm ID not found');\n      }\n\n      const realmId = integration.metadata['realmId'] as string;\n\n      // Fetch invoices from QuickBooks\n      const response = await axios.get(\n        `${this.apiBaseUrl}/${realmId}/query?query=SELECT * FROM Invoice WHERE TxnDate > '2025-01-01' MAXRESULTS 100`,\n        {\n          headers: {\n            Accept: 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        },\n      );\n\n      const invoices = response.data.QueryResponse?.Invoice || [];\n      let syncedCount = 0;\n      const errors: Array<{ item: string; error: string }> = [];\n\n      // Sync each invoice to Crypto ERP\n      for (const qbInvoice of invoices) {\n        try {\n          await this.syncInvoice(integration.companyId, qbInvoice);\n          syncedCount++;\n        } catch (error: any) {\n          errors.push({\n            item: `Invoice ${qbInvoice.DocNumber}`,\n            error: error.message,\n          });\n        }\n      }\n\n      await this.baseService.updateSyncStatus(\n        integrationId,\n        errors.length === 0 ? 'success' : 'partial',\n        errors.length > 0 ? JSON.stringify(errors) : undefined,\n      );\n\n      return {\n        success: true,\n        itemsSynced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined,\n      };\n    } catch (error: any) {\n      this.logger.error('QuickBooks sync failed:', error);\n\n      await this.baseService.updateSyncStatus(\n        integrationId,\n        'error',\n        error.message,\n      );\n\n      return {\n        success: false,\n        itemsSynced: 0,\n        errors: [{ item: 'Sync', error: error.message }],\n      };\n    }\n  }\n\n  /**\n   * Push invoice from Crypto ERP to QuickBooks\n   */\n  async pushData(integrationId: string, accessToken: string, data: any): Promise<PushResult> {\n    try {\n      const integration = await this.baseService.prisma.integration.findUnique({\n        where: { id: integrationId },\n      });\n\n      if (!integration?.metadata?.['realmId']) {\n        throw new Error('QuickBooks realm ID not found');\n      }\n\n      const realmId = integration.metadata['realmId'] as string;\n\n      // Convert Crypto ERP invoice to QuickBooks format\n      const qbInvoice = this.mapToQuickBooksInvoice(data);\n\n      // Create or update invoice in QuickBooks\n      const response = await axios.post(\n        `${this.apiBaseUrl}/${realmId}/invoice`,\n        qbInvoice,\n        {\n          headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        },\n      );\n\n      return {\n        success: true,\n        externalId: response.data.Invoice.Id,\n        metadata: {\n          docNumber: response.data.Invoice.DocNumber,\n          syncToken: response.data.Invoice.SyncToken,\n        },\n      };\n    } catch (error: any) {\n      this.logger.error('QuickBooks push failed:', error);\n\n      return {\n        success: false,\n        error: error.message,\n      };\n    }\n  }\n\n  /**\n   * Sync single invoice from QuickBooks to Crypto ERP\n   */\n  private async syncInvoice(companyId: string, qbInvoice: any) {\n    // Map QuickBooks invoice to Crypto ERP format\n    const invoice = {\n      companyId,\n      contactId: await this.getOrCreateContact(companyId, qbInvoice.CustomerRef),\n      number: qbInvoice.DocNumber,\n      issueDate: new Date(qbInvoice.TxnDate),\n      dueDate: qbInvoice.DueDate ? new Date(qbInvoice.DueDate) : null,\n      subtotal: parseFloat(qbInvoice.TotalAmt || '0'),\n      totalAmount: parseFloat(qbInvoice.TotalAmt || '0'),\n      currency: qbInvoice.CurrencyRef?.value || 'USD',\n      status: this.mapQuickBooksStatus(qbInvoice.Balance),\n      metadata: {\n        quickbooksId: qbInvoice.Id,\n        syncToken: qbInvoice.SyncToken,\n      },\n    };\n\n    // Upsert invoice in Crypto ERP\n    // This is a placeholder - actual implementation would use InvoicesService\n    this.logger.log(`Would sync invoice ${invoice.number} to Crypto ERP`);\n  }\n\n  /**\n   * Map QuickBooks invoice to Crypto ERP format\n   */\n  private mapToQuickBooksInvoice(invoice: any) {\n    return {\n      CustomerRef: {\n        value: invoice.quickbooksCustomerId,\n      },\n      Line: invoice.lines.map((line: any) => ({\n        Amount: line.total,\n        DetailType: 'SalesItemLineDetail',\n        SalesItemLineDetail: {\n          ItemRef: {\n            value: line.quickbooksItemId || '1', // Default item\n          },\n          Qty: line.quantity,\n          UnitPrice: line.unitPrice,\n        },\n        Description: line.description,\n      })),\n      TxnDate: invoice.issueDate,\n      DueDate: invoice.dueDate,\n    };\n  }\n\n  /**\n   * Map QuickBooks invoice status to Crypto ERP status\n   */\n  private mapQuickBooksStatus(balance: number): string {\n    if (balance === 0) {\n      return 'PAID';\n    } else if (balance > 0) {\n      return 'PENDING';\n    }\n    return 'DRAFT';\n  }\n\n  /**\n   * Get or create contact from QuickBooks customer\n   */\n  private async getOrCreateContact(companyId: string, customerRef: any): Promise<string> {\n    // Placeholder - would actually query/create contact\n    return 'contact-uuid';\n  }\n}\n"],"names":["QuickBooksService","getAuthorizationUrl","companyId","redirectUri","state","params","URLSearchParams","client_id","clientId","redirect_uri","response_type","scope","scopes","join","authUrl","toString","exchangeCodeForToken","code","auth","Buffer","from","clientSecret","response","axios","post","tokenUrl","grant_type","headers","Accept","Authorization","accessToken","data","access_token","refreshToken","refresh_token","expiresIn","expires_in","metadata","realmId","refreshAccessToken","testConnection","integration","baseService","getIntegration","provider","get","apiBaseUrl","error","logger","syncData","integrationId","prisma","findUnique","where","id","Error","invoices","QueryResponse","Invoice","syncedCount","errors","qbInvoice","syncInvoice","push","item","DocNumber","message","updateSyncStatus","length","JSON","stringify","undefined","success","itemsSynced","pushData","mapToQuickBooksInvoice","externalId","Id","docNumber","syncToken","SyncToken","invoice","contactId","getOrCreateContact","CustomerRef","number","issueDate","Date","TxnDate","dueDate","DueDate","subtotal","parseFloat","TotalAmt","totalAmount","currency","CurrencyRef","value","status","mapQuickBooksStatus","Balance","quickbooksId","log","quickbooksCustomerId","Line","lines","map","line","Amount","total","DetailType","SalesItemLineDetail","ItemRef","quickbooksItemId","Qty","quantity","UnitPrice","unitPrice","Description","description","balance","customerRef","config","Logger","name","revokeUrl"],"mappings":"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"}