{"version":3,"sources":["../../../../src/modules/ai/services/paddle-ocr.client.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport FormData from 'form-data';\n\nexport interface PaddleOcrLine {\n  text: string;\n  bbox: number[][];\n  confidence: number;\n}\n\nexport interface PaddleOcrResponse {\n  success: boolean;\n  text?: string;\n  lines?: PaddleOcrLine[];\n  provider?: string;\n  stats?: {\n    total_lines: number;\n    avg_confidence: number;\n  };\n  error?: string;\n}\n\n/**\n * Client for PaddleOCR self-hosted service\n *\n * PaddleOCR is an open-source OCR toolkit supporting 80+ languages.\n * This client connects to the PaddleOCR Flask API running in Docker.\n *\n * Usage:\n * - Start PaddleOCR: docker-compose --profile ocr up -d paddleocr\n * - Set PADDLE_OCR_URL in .env (default: http://paddleocr:8866)\n *\n * Features:\n * - Multi-language support (Spanish, English, French, etc.)\n * - Bounding box detection for layout analysis\n * - Confidence scores per line\n * - Optimized for invoice processing\n *\n * @see docker/paddleocr/app.py\n */\n@Injectable()\nexport class PaddleOcrClient {\n  private readonly logger = new Logger(PaddleOcrClient.name);\n  private readonly baseUrl: string;\n  private readonly timeout: number = 30000; // 30 seconds\n  private isAvailable: boolean | null = null;\n  private lastHealthCheck: number = 0;\n  private readonly healthCheckInterval = 60000; // 1 minute\n\n  constructor(private readonly configService: ConfigService) {\n    this.baseUrl = this.configService.get<string>(\n      'PADDLE_OCR_URL',\n      'http://localhost:8866',\n    );\n\n    this.logger.log(`PaddleOCR client initialized (URL: ${this.baseUrl})`);\n  }\n\n  /**\n   * Check if PaddleOCR service is available\n   */\n  async checkHealth(): Promise<boolean> {\n    const now = Date.now();\n\n    // Use cached result if checked recently\n    if (this.isAvailable !== null && now - this.lastHealthCheck < this.healthCheckInterval) {\n      return this.isAvailable;\n    }\n\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n      const response = await fetch(`${this.baseUrl}/health`, {\n        method: 'GET',\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      this.isAvailable = response.ok;\n      this.lastHealthCheck = now;\n\n      if (this.isAvailable) {\n        const data = await response.json();\n        this.logger.log(`PaddleOCR health check: ${data.status} (v${data.version})`);\n      }\n\n      return this.isAvailable;\n    } catch (error) {\n      this.isAvailable = false;\n      this.lastHealthCheck = now;\n      this.logger.warn(`PaddleOCR not available: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Extract text from image using PaddleOCR\n   *\n   * @param imageBuffer - Image buffer (JPEG, PNG)\n   * @param language - Language code (es, en, fr, de, etc.)\n   * @returns Extracted text and line details\n   */\n  async extractText(\n    imageBuffer: Buffer,\n    language: string = 'es',\n  ): Promise<PaddleOcrResponse> {\n    try {\n      // Check if service is available\n      const isHealthy = await this.checkHealth();\n      if (!isHealthy) {\n        return {\n          success: false,\n          error: 'PaddleOCR service not available',\n        };\n      }\n\n      // Prepare form data\n      const formData = new FormData();\n      formData.append('file', imageBuffer, {\n        filename: 'invoice.jpg',\n        contentType: 'image/jpeg',\n      });\n      formData.append('lang', language);\n\n      this.logger.debug(`Sending OCR request (lang: ${language}, size: ${imageBuffer.length} bytes)`);\n\n      // Send request\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const response = await fetch(`${this.baseUrl}/predict`, {\n        method: 'POST',\n        body: formData as any,\n        headers: formData.getHeaders(),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        this.logger.error(`PaddleOCR API error: ${response.status} - ${errorText}`);\n        return {\n          success: false,\n          error: `PaddleOCR API error: ${response.status}`,\n        };\n      }\n\n      const result: PaddleOcrResponse = await response.json();\n\n      if (result.success) {\n        this.logger.log(\n          `OCR extracted ${result.stats?.total_lines || 0} lines ` +\n          `(avg confidence: ${((result.stats?.avg_confidence || 0) * 100).toFixed(1)}%)`,\n        );\n      }\n\n      return result;\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        this.logger.error('PaddleOCR request timeout');\n        return {\n          success: false,\n          error: 'OCR request timeout',\n        };\n      }\n\n      this.logger.error(`PaddleOCR extraction failed: ${error.message}`, error.stack);\n      return {\n        success: false,\n        error: error.message,\n      };\n    }\n  }\n\n  /**\n   * Get list of supported languages\n   */\n  async getSupportedLanguages(): Promise<string[]> {\n    try {\n      const response = await fetch(`${this.baseUrl}/languages`);\n      if (!response.ok) {\n        return ['es', 'en']; // Fallback\n      }\n\n      const data = await response.json();\n      return data.languages.map((lang: any) => lang.code);\n    } catch (error) {\n      this.logger.warn('Failed to fetch supported languages', error);\n      return ['es', 'en'];\n    }\n  }\n\n  /**\n   * Get current status\n   */\n  getStatus(): { enabled: boolean; url: string; lastCheck: Date | null } {\n    return {\n      enabled: this.isAvailable === true,\n      url: this.baseUrl,\n      lastCheck: this.lastHealthCheck > 0 ? new Date(this.lastHealthCheck) : null,\n    };\n  }\n}\n"],"names":["PaddleOcrClient","checkHealth","now","Date","isAvailable","lastHealthCheck","healthCheckInterval","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","baseUrl","method","signal","clearTimeout","ok","data","json","logger","log","status","version","error","warn","message","extractText","imageBuffer","language","isHealthy","success","formData","FormData","append","filename","contentType","debug","length","timeout","body","headers","getHeaders","errorText","text","result","stats","total_lines","avg_confidence","toFixed","name","stack","getSupportedLanguages","languages","map","lang","code","getStatus","enabled","url","lastCheck","configService","Logger","get"],"mappings":"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"}