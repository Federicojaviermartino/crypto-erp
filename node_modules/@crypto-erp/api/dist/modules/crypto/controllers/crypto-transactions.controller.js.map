{"version":3,"sources":["../../../../src/modules/crypto/controllers/crypto-transactions.controller.ts"],"sourcesContent":["import {\n  Controller,\n  Get,\n  Post,\n  Patch,\n  Param,\n  Query,\n  Body,\n  UseGuards,\n  HttpCode,\n  HttpStatus,\n  BadRequestException,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiParam,\n  ApiQuery,\n} from '@nestjs/swagger';\nimport { InjectQueue } from '@nestjs/bullmq';\nimport { Queue } from 'bullmq';\nimport { JwtAuthGuard, TenantGuard } from '../../../common/guards/index.js';\nimport { CurrentCompany } from '../../../common/decorators/index.js';\nimport { CryptoTransactionsService, CostBasisService, TaxReportEntry } from '../services/index.js';\nimport { CryptoTxType } from '@prisma/client';\nimport {\n  BatchCategorizeDto,\n  BatchCategorizeResponseDto,\n  BatchJobStatusResponseDto,\n} from '../dto/batch-categorize.dto.js';\n\n@ApiTags('Crypto Transactions')\n@ApiBearerAuth()\n@UseGuards(JwtAuthGuard, TenantGuard)\n@Controller('crypto/transactions')\nexport class CryptoTransactionsController {\n  constructor(\n    private readonly transactionsService: CryptoTransactionsService,\n    private readonly costBasisService: CostBasisService,\n    @InjectQueue('ai-categorize') private readonly categorizeQueue: Queue,\n  ) {}\n\n  @Get()\n  @ApiOperation({ summary: 'List all crypto transactions' })\n  @ApiResponse({ status: 200, description: 'Returns paginated list of transactions' })\n  @ApiQuery({ name: 'type', required: false, description: 'Transaction type filter' })\n  @ApiQuery({ name: 'walletId', required: false, description: 'Wallet ID filter' })\n  @ApiQuery({ name: 'chain', required: false, description: 'Blockchain filter' })\n  @ApiQuery({ name: 'startDate', required: false, description: 'Start date filter' })\n  @ApiQuery({ name: 'endDate', required: false, description: 'End date filter' })\n  @ApiQuery({ name: 'skip', required: false, description: 'Pagination offset' })\n  @ApiQuery({ name: 'take', required: false, description: 'Pagination limit' })\n  async findAll(\n    @CurrentCompany() companyId: string,\n    @Query('type') type?: string,\n    @Query('walletId') walletId?: string,\n    @Query('chain') chain?: string,\n    @Query('startDate') startDate?: string,\n    @Query('endDate') endDate?: string,\n    @Query('skip') skip?: string,\n    @Query('take') take?: string,\n  ) {\n    return this.transactionsService.findAll(companyId, {\n      type,\n      walletId,\n      chain,\n      startDate,\n      endDate,\n      skip: skip ? parseInt(skip, 10) : undefined,\n      take: take ? parseInt(take, 10) : undefined,\n    });\n  }\n\n  @Get('portfolio')\n  @ApiOperation({ summary: 'Get portfolio summary with cost basis' })\n  @ApiResponse({ status: 200, description: 'Returns portfolio positions' })\n  async getPortfolioSummary(@CurrentCompany() companyId: string) {\n    return this.transactionsService.getPortfolioSummary(companyId);\n  }\n\n  @Get('stats')\n  @ApiOperation({ summary: 'Get transaction statistics' })\n  @ApiResponse({ status: 200, description: 'Returns transaction statistics' })\n  async getStats(@CurrentCompany() companyId: string) {\n    return this.transactionsService.getTransactionStats(companyId);\n  }\n\n  @Get('tax-report')\n  @ApiOperation({ summary: 'Generate tax report for realized gains/losses' })\n  @ApiQuery({ name: 'startDate', required: true, description: 'Start date (YYYY-MM-DD)' })\n  @ApiQuery({ name: 'endDate', required: true, description: 'End date (YYYY-MM-DD)' })\n  @ApiResponse({ status: 200, description: 'Returns tax report' })\n  async getTaxReport(\n    @CurrentCompany() companyId: string,\n    @Query('startDate') startDate: string,\n    @Query('endDate') endDate: string,\n  ): Promise<{\n    entries: TaxReportEntry[];\n    summary: {\n      totalProceeds: number;\n      totalCostBasis: number;\n      totalGainLoss: number;\n      shortTermGainLoss: number;\n      longTermGainLoss: number;\n    };\n  }> {\n    if (!startDate || !endDate) {\n      return {\n        entries: [],\n        summary: {\n          totalProceeds: 0,\n          totalCostBasis: 0,\n          totalGainLoss: 0,\n          shortTermGainLoss: 0,\n          longTermGainLoss: 0,\n        },\n      };\n    }\n    return this.transactionsService.getTaxReport(companyId, startDate, endDate);\n  }\n\n  @Get('lots/:assetId')\n  @ApiOperation({ summary: 'Get cost basis lots for an asset' })\n  @ApiParam({ name: 'assetId', description: 'Asset ID' })\n  @ApiQuery({ name: 'includeExhausted', required: false, description: 'Include exhausted lots' })\n  @ApiResponse({ status: 200, description: 'Returns cost basis lots' })\n  async getLots(\n    @CurrentCompany() companyId: string,\n    @Param('assetId') assetId: string,\n    @Query('includeExhausted') includeExhausted?: string,\n  ) {\n    return this.costBasisService.getLotsForAsset(\n      companyId,\n      assetId,\n      includeExhausted === 'true',\n    );\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get transaction by ID' })\n  @ApiParam({ name: 'id', description: 'Transaction ID' })\n  @ApiResponse({ status: 200, description: 'Returns transaction details' })\n  @ApiResponse({ status: 404, description: 'Transaction not found' })\n  async findById(\n    @CurrentCompany() companyId: string,\n    @Param('id') id: string,\n  ) {\n    return this.transactionsService.findById(companyId, id);\n  }\n\n  @Post('recalculate/:assetId')\n  @ApiOperation({ summary: 'Recalculate cost basis for an asset' })\n  @ApiParam({ name: 'assetId', description: 'Asset ID' })\n  @ApiResponse({ status: 200, description: 'Cost basis recalculated' })\n  @HttpCode(HttpStatus.OK)\n  async recalculateCostBasis(\n    @CurrentCompany() companyId: string,\n    @Param('assetId') assetId: string,\n  ) {\n    await this.costBasisService.recalculateForAsset(companyId, assetId);\n    return { success: true, message: 'Cost basis recalculated' };\n  }\n\n  @Patch(':id/recategorize')\n  @ApiOperation({ summary: 'Recategorize a transaction' })\n  @ApiParam({ name: 'id', description: 'Transaction ID' })\n  @ApiResponse({ status: 200, description: 'Transaction recategorized' })\n  async recategorize(\n    @CurrentCompany() companyId: string,\n    @Param('id') id: string,\n    @Body() body: { type: CryptoTxType; notes?: string },\n  ) {\n    return this.transactionsService.recategorizeTransaction(companyId, id, body.type, body.notes);\n  }\n\n  @Post('batch-categorize')\n  @ApiOperation({\n    summary: 'Batch categorize transactions with AI',\n    description:\n      'Queues transactions for AI categorization. Provide either specific transaction IDs, ' +\n      'a wallet ID to categorize all uncategorized transactions, or a date range.',\n  })\n  @ApiResponse({\n    status: 201,\n    description: 'Batch categorization job created',\n    type: BatchCategorizeResponseDto,\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Invalid request - must provide transactionIds, walletId, or date range',\n  })\n  @HttpCode(HttpStatus.CREATED)\n  async batchCategorize(\n    @CurrentCompany() companyId: string,\n    @Body() dto: BatchCategorizeDto,\n  ): Promise<BatchCategorizeResponseDto> {\n    let transactionIds: string[] = [];\n\n    // Option 1: Specific transaction IDs provided\n    if (dto.transactionIds && dto.transactionIds.length > 0) {\n      transactionIds = dto.transactionIds;\n    }\n    // Option 2: All uncategorized transactions for a wallet\n    else if (dto.walletId) {\n      const where: any = {\n        walletId: dto.walletId,\n        aiCategorized: false,\n      };\n\n      if (dto.startDate || dto.endDate) {\n        where.blockTimestamp = {};\n        if (dto.startDate) where.blockTimestamp.gte = new Date(dto.startDate);\n        if (dto.endDate) where.blockTimestamp.lte = new Date(dto.endDate);\n      }\n\n      const transactions = await this.transactionsService.findAllForBatch(companyId, where);\n      transactionIds = transactions.map((tx: any) => tx.id);\n    }\n    // Option 3: Date range for all wallets\n    else if (dto.startDate || dto.endDate) {\n      const where: any = {\n        aiCategorized: false,\n        blockTimestamp: {},\n      };\n\n      if (dto.startDate) where.blockTimestamp.gte = new Date(dto.startDate);\n      if (dto.endDate) where.blockTimestamp.lte = new Date(dto.endDate);\n\n      const transactions = await this.transactionsService.findAllForBatch(companyId, where);\n      transactionIds = transactions.map((tx: any) => tx.id);\n    } else {\n      throw new BadRequestException(\n        'Must provide either transactionIds, walletId, or date range (startDate/endDate)',\n      );\n    }\n\n    if (transactionIds.length === 0) {\n      throw new BadRequestException('No transactions found matching criteria');\n    }\n\n    // Queue the job\n    const jobId = `batch-cat-${Date.now()}-${companyId}`;\n    await this.categorizeQueue.add(\n      'categorize-batch',\n      {\n        transactionIds,\n        companyId,\n      },\n      {\n        jobId,\n        priority: 10,\n      },\n    );\n\n    // Estimate time: ~3 seconds per transaction (AI calls can be slow)\n    const estimatedTime = transactionIds.length * 3;\n\n    return {\n      jobId,\n      transactionCount: transactionIds.length,\n      estimatedTime,\n    };\n  }\n\n  @Get('batch-categorize/:jobId/status')\n  @ApiOperation({ summary: 'Get batch categorization job status' })\n  @ApiParam({ name: 'jobId', description: 'Job ID returned from batch-categorize' })\n  @ApiResponse({\n    status: 200,\n    description: 'Job status retrieved',\n    type: BatchJobStatusResponseDto,\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Job not found',\n  })\n  async getBatchStatus(\n    @Param('jobId') jobId: string,\n  ): Promise<BatchJobStatusResponseDto> {\n    const job = await this.categorizeQueue.getJob(jobId);\n\n    if (!job) {\n      throw new BadRequestException(`Job ${jobId} not found`);\n    }\n\n    const state = await job.getState();\n    const progress = job.progress as number || 0;\n\n    const response: BatchJobStatusResponseDto = {\n      jobId,\n      state,\n      progress,\n    };\n\n    // Include result if completed\n    if (state === 'completed') {\n      response.result = job.returnvalue;\n    }\n\n    // Include error if failed\n    if (state === 'failed') {\n      response.error = job.failedReason;\n    }\n\n    return response;\n  }\n}\n"],"names":["CryptoTransactionsController","findAll","companyId","type","walletId","chain","startDate","endDate","skip","take","transactionsService","parseInt","undefined","getPortfolioSummary","getStats","getTransactionStats","getTaxReport","entries","summary","totalProceeds","totalCostBasis","totalGainLoss","shortTermGainLoss","longTermGainLoss","getLots","assetId","includeExhausted","costBasisService","getLotsForAsset","findById","id","recalculateCostBasis","recalculateForAsset","success","message","recategorize","body","recategorizeTransaction","notes","batchCategorize","dto","transactionIds","length","where","aiCategorized","blockTimestamp","gte","Date","lte","transactions","findAllForBatch","map","tx","BadRequestException","jobId","now","categorizeQueue","add","priority","estimatedTime","transactionCount","getBatchStatus","job","getJob","state","getState","progress","response","result","returnvalue","error","failedReason","status","description","name","required","OK","BatchCategorizeResponseDto","CREATED","BatchJobStatusResponseDto"],"mappings":"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"}