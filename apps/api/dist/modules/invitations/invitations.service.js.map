{"version":3,"sources":["../../../src/modules/invitations/invitations.service.ts"],"sourcesContent":["import {\n  Injectable,\n  NotFoundException,\n  ConflictException,\n  BadRequestException,\n  ForbiddenException,\n  Logger,\n} from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { InvitationStatus, UserRole } from '@prisma/client';\nimport { NotificationsService } from '../notifications/notifications.service';\nimport { CreateInvitationDto } from './dto/create-invitation.dto';\n\n@Injectable()\nexport class InvitationsService {\n  private readonly logger = new Logger(InvitationsService.name);\n\n  constructor(\n    private prisma: PrismaService,\n    private notifications: NotificationsService,\n  ) {}\n\n  /**\n   * Create a new team invitation\n   */\n  async createInvitation(\n    companyId: string,\n    inviterId: string,\n    dto: CreateInvitationDto,\n  ) {\n    // Check if user already exists in the company\n    const existingMember = await this.prisma.companyUser.findFirst({\n      where: {\n        companyId,\n        user: {\n          email: dto.email,\n        },\n      },\n    });\n\n    if (existingMember) {\n      throw new ConflictException('User is already a member of this company');\n    }\n\n    // Check for existing pending invitation\n    const existingInvitation = await this.prisma.companyInvitation.findUnique({\n      where: {\n        email_companyId: {\n          email: dto.email,\n          companyId,\n        },\n      },\n    });\n\n    if (existingInvitation && existingInvitation.status === InvitationStatus.PENDING) {\n      throw new ConflictException('An invitation has already been sent to this email');\n    }\n\n    // Create invitation with 7 days expiry\n    const expiresAt = new Date();\n    expiresAt.setDate(expiresAt.getDate() + 7);\n\n    const invitation = await this.prisma.companyInvitation.create({\n      data: {\n        email: dto.email,\n        role: dto.role,\n        companyId,\n        inviterId,\n        expiresAt,\n      },\n      include: {\n        company: true,\n        inviter: true,\n      },\n    });\n\n    // Send invitation email\n    try {\n      await this.notifications.sendTeamInvitation(invitation as any);\n    } catch (error) {\n      this.logger.error(`Failed to send invitation email to ${dto.email}:`, error);\n      // Don't fail the invitation creation if email fails\n    }\n\n    this.logger.log(\n      `Invitation created for ${dto.email} to company ${companyId} by user ${inviterId}`,\n    );\n\n    return invitation;\n  }\n\n  /**\n   * Accept an invitation\n   */\n  async acceptInvitation(token: string, userId: string) {\n    const invitation = await this.prisma.companyInvitation.findUnique({\n      where: { token },\n      include: { company: true },\n    });\n\n    if (!invitation) {\n      throw new NotFoundException('Invitation not found');\n    }\n\n    if (invitation.status !== InvitationStatus.PENDING) {\n      throw new BadRequestException('This invitation has already been processed');\n    }\n\n    if (invitation.expiresAt < new Date()) {\n      // Mark as expired\n      await this.prisma.companyInvitation.update({\n        where: { id: invitation.id },\n        data: { status: InvitationStatus.EXPIRED },\n      });\n      throw new BadRequestException('This invitation has expired');\n    }\n\n    // Check if user is already a member\n    const existingMember = await this.prisma.companyUser.findUnique({\n      where: {\n        userId_companyId: {\n          userId,\n          companyId: invitation.companyId,\n        },\n      },\n    });\n\n    if (existingMember) {\n      throw new ConflictException('You are already a member of this company');\n    }\n\n    // Add user to company and mark invitation as accepted\n    await this.prisma.$transaction([\n      this.prisma.companyUser.create({\n        data: {\n          userId,\n          companyId: invitation.companyId,\n          role: invitation.role,\n          isDefault: false,\n        },\n      }),\n      this.prisma.companyInvitation.update({\n        where: { id: invitation.id },\n        data: {\n          status: InvitationStatus.ACCEPTED,\n          acceptedAt: new Date(),\n          acceptedBy: userId,\n        },\n      }),\n    ]);\n\n    this.logger.log(\n      `Invitation ${invitation.id} accepted by user ${userId} for company ${invitation.companyId}`,\n    );\n\n    return {\n      message: 'Invitation accepted successfully',\n      company: invitation.company,\n    };\n  }\n\n  /**\n   * Cancel an invitation\n   */\n  async cancelInvitation(invitationId: string, userId: string, companyId: string) {\n    const invitation = await this.prisma.companyInvitation.findUnique({\n      where: { id: invitationId },\n    });\n\n    if (!invitation) {\n      throw new NotFoundException('Invitation not found');\n    }\n\n    if (invitation.companyId !== companyId) {\n      throw new ForbiddenException('You do not have access to this invitation');\n    }\n\n    // Check if user is the inviter or has admin rights\n    const isInviter = invitation.inviterId === userId;\n    const userRole = await this.getUserRole(userId, companyId);\n    const isAdmin = userRole === UserRole.ADMIN || userRole === UserRole.OWNER;\n\n    if (!isInviter && !isAdmin) {\n      throw new ForbiddenException('You do not have permission to cancel this invitation');\n    }\n\n    await this.prisma.companyInvitation.update({\n      where: { id: invitationId },\n      data: { status: InvitationStatus.CANCELLED },\n    });\n\n    this.logger.log(`Invitation ${invitationId} cancelled by user ${userId}`);\n\n    return { message: 'Invitation cancelled successfully' };\n  }\n\n  /**\n   * List invitations for a company\n   */\n  async findByCompany(companyId: string, status?: InvitationStatus) {\n    const where: any = { companyId };\n    if (status) {\n      where.status = status;\n    }\n\n    return this.prisma.companyInvitation.findMany({\n      where,\n      include: {\n        inviter: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  /**\n   * Get invitation by token\n   */\n  async findByToken(token: string) {\n    const invitation = await this.prisma.companyInvitation.findUnique({\n      where: { token },\n      include: {\n        company: {\n          select: {\n            id: true,\n            name: true,\n            legalName: true,\n          },\n        },\n        inviter: {\n          select: {\n            firstName: true,\n            lastName: true,\n          },\n        },\n      },\n    });\n\n    if (!invitation) {\n      throw new NotFoundException('Invitation not found');\n    }\n\n    // Don't return expired invitations\n    if (invitation.status === InvitationStatus.EXPIRED || invitation.expiresAt < new Date()) {\n      throw new BadRequestException('This invitation has expired');\n    }\n\n    if (invitation.status !== InvitationStatus.PENDING) {\n      throw new BadRequestException('This invitation has already been processed');\n    }\n\n    return invitation;\n  }\n\n  /**\n   * Get user role in company\n   */\n  private async getUserRole(userId: string, companyId: string): Promise<UserRole | null> {\n    const companyUser = await this.prisma.companyUser.findUnique({\n      where: {\n        userId_companyId: {\n          userId,\n          companyId,\n        },\n      },\n    });\n\n    return companyUser?.role || null;\n  }\n\n  /**\n   * Clean up expired invitations (can be run as a cron job)\n   */\n  async cleanupExpiredInvitations() {\n    const result = await this.prisma.companyInvitation.updateMany({\n      where: {\n        status: InvitationStatus.PENDING,\n        expiresAt: {\n          lt: new Date(),\n        },\n      },\n      data: {\n        status: InvitationStatus.EXPIRED,\n      },\n    });\n\n    this.logger.log(`Marked ${result.count} invitations as expired`);\n    return result;\n  }\n}\n"],"names":["InvitationsService","createInvitation","companyId","inviterId","dto","existingMember","prisma","companyUser","findFirst","where","user","email","ConflictException","existingInvitation","companyInvitation","findUnique","email_companyId","status","InvitationStatus","PENDING","expiresAt","Date","setDate","getDate","invitation","create","data","role","include","company","inviter","notifications","sendTeamInvitation","error","logger","log","acceptInvitation","token","userId","NotFoundException","BadRequestException","update","id","EXPIRED","userId_companyId","$transaction","isDefault","ACCEPTED","acceptedAt","acceptedBy","message","cancelInvitation","invitationId","ForbiddenException","isInviter","userRole","getUserRole","isAdmin","UserRole","ADMIN","OWNER","CANCELLED","findByCompany","findMany","select","firstName","lastName","orderBy","createdAt","findByToken","name","legalName","cleanupExpiredInvitations","result","updateMany","lt","count","Logger"],"mappings":"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"}