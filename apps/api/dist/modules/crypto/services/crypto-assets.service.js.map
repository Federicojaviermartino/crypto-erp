{"version":3,"sources":["../../../../src/modules/crypto/services/crypto-assets.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { CreateCryptoAssetDto } from '../dto/index.js';\nimport { CryptoAsset } from '@prisma/client';\n\n@Injectable()\nexport class CryptoAssetsService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async findAll(companyId: string): Promise<CryptoAsset[]> {\n    return this.prisma.cryptoAsset.findMany({\n      where: { companyId },\n      orderBy: { symbol: 'asc' },\n    });\n  }\n\n  async findById(companyId: string, id: string): Promise<CryptoAsset> {\n    const asset = await this.prisma.cryptoAsset.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!asset) {\n      throw new NotFoundException(`Crypto asset with ID ${id} not found`);\n    }\n\n    return asset;\n  }\n\n  async findBySymbol(companyId: string, symbol: string): Promise<CryptoAsset | null> {\n    return this.prisma.cryptoAsset.findFirst({\n      where: { companyId, symbol: symbol.toUpperCase() },\n    });\n  }\n\n  async create(companyId: string, dto: CreateCryptoAssetDto): Promise<CryptoAsset> {\n    // Check for duplicate symbol\n    const existing = await this.findBySymbol(companyId, dto.symbol);\n    if (existing) {\n      throw new ConflictException(`Crypto asset with symbol ${dto.symbol} already exists`);\n    }\n\n    return this.prisma.cryptoAsset.create({\n      data: {\n        symbol: dto.symbol.toUpperCase(),\n        name: dto.name,\n        decimals: dto.decimals ?? 8,\n        coingeckoId: dto.coingeckoId,\n        isActive: dto.isActive ?? true,\n        companyId,\n      },\n    });\n  }\n\n  async update(\n    companyId: string,\n    id: string,\n    dto: Partial<CreateCryptoAssetDto>,\n  ): Promise<CryptoAsset> {\n    await this.findById(companyId, id);\n\n    // Check for duplicate symbol if changing\n    if (dto.symbol) {\n      const existing = await this.prisma.cryptoAsset.findFirst({\n        where: {\n          companyId,\n          symbol: dto.symbol.toUpperCase(),\n          NOT: { id },\n        },\n      });\n      if (existing) {\n        throw new ConflictException(`Crypto asset with symbol ${dto.symbol} already exists`);\n      }\n    }\n\n    return this.prisma.cryptoAsset.update({\n      where: { id },\n      data: {\n        ...(dto.symbol && { symbol: dto.symbol.toUpperCase() }),\n        ...(dto.name && { name: dto.name }),\n        ...(dto.decimals !== undefined && { decimals: dto.decimals }),\n        ...(dto.coingeckoId !== undefined && { coingeckoId: dto.coingeckoId }),\n        ...(dto.isActive !== undefined && { isActive: dto.isActive }),\n      },\n    });\n  }\n\n  async delete(companyId: string, id: string): Promise<void> {\n    const asset = await this.findById(companyId, id);\n\n    // Check for cost basis lots referencing this asset\n    const lotCount = await this.prisma.cryptoLot.count({\n      where: { cryptoAssetId: id },\n    });\n\n    if (lotCount > 0) {\n      throw new ConflictException(\n        `Cannot delete asset with ${lotCount} cost basis lots. Deactivate instead.`,\n      );\n    }\n\n    await this.prisma.cryptoAsset.delete({ where: { id } });\n  }\n}\n"],"names":["CryptoAssetsService","findAll","companyId","prisma","cryptoAsset","findMany","where","orderBy","symbol","findById","id","asset","findFirst","NotFoundException","findBySymbol","toUpperCase","create","dto","existing","ConflictException","data","name","decimals","coingeckoId","isActive","update","NOT","undefined","delete","lotCount","cryptoLot","count","cryptoAssetId"],"mappings":"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"}