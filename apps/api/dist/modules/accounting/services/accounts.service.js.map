{"version":3,"sources":["../../../../src/modules/accounting/services/accounts.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { CreateAccountDto, QueryAccountsDto } from '../dto/index.js';\nimport { Account, AccountType, Prisma } from '@prisma/client';\n\nexport interface AccountWithChildren extends Account {\n  children?: AccountWithChildren[];\n}\n\n@Injectable()\nexport class AccountsService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async findAll(companyId: string, query: QueryAccountsDto): Promise<Account[]> {\n    const where: Prisma.AccountWhereInput = {\n      companyId,\n      ...(query.type && { type: query.type as AccountType }),\n      ...(query.isActive !== undefined && { isActive: query.isActive }),\n      ...(query.search && {\n        OR: [\n          { code: { contains: query.search, mode: 'insensitive' as const } },\n          { name: { contains: query.search, mode: 'insensitive' as const } },\n        ],\n      }),\n    };\n\n    return this.prisma.account.findMany({\n      where,\n      orderBy: { code: 'asc' },\n    });\n  }\n\n  async findById(companyId: string, id: string): Promise<Account> {\n    const account = await this.prisma.account.findFirst({\n      where: { id, companyId },\n    });\n\n    if (!account) {\n      throw new NotFoundException(`Account with ID ${id} not found`);\n    }\n\n    return account;\n  }\n\n  async findByCode(companyId: string, code: string): Promise<Account | null> {\n    return this.prisma.account.findFirst({\n      where: { companyId, code },\n    });\n  }\n\n  async findTree(companyId: string): Promise<AccountWithChildren[]> {\n    const accounts = await this.prisma.account.findMany({\n      where: { companyId, isActive: true },\n      orderBy: { code: 'asc' },\n    });\n\n    // Build tree structure using parentCode\n    const accountByCode = new Map<string, AccountWithChildren>();\n    const rootAccounts: AccountWithChildren[] = [];\n\n    // First pass: create map by code\n    for (const account of accounts) {\n      accountByCode.set(account.code, { ...account, children: [] });\n    }\n\n    // Second pass: build tree using parentCode\n    for (const account of accounts) {\n      const node = accountByCode.get(account.code)!;\n      if (account.parentCode) {\n        const parent = accountByCode.get(account.parentCode);\n        if (parent) {\n          parent.children = parent.children || [];\n          parent.children.push(node);\n        } else {\n          rootAccounts.push(node);\n        }\n      } else {\n        rootAccounts.push(node);\n      }\n    }\n\n    return rootAccounts;\n  }\n\n  async getBalance(\n    companyId: string,\n    accountId: string,\n    startDate?: Date,\n    endDate?: Date,\n  ): Promise<{ debit: number; credit: number; balance: number }> {\n    const account = await this.findById(companyId, accountId);\n\n    const where: Prisma.JournalLineWhereInput = {\n      accountId,\n      journalEntry: {\n        companyId,\n        status: 'POSTED',\n        ...(startDate && { date: { gte: startDate } }),\n        ...(endDate && { date: { lte: endDate } }),\n      },\n    };\n\n    const result = await this.prisma.journalLine.aggregate({\n      where,\n      _sum: {\n        debit: true,\n        credit: true,\n      },\n    });\n\n    const debit = result._sum.debit?.toNumber() || 0;\n    const credit = result._sum.credit?.toNumber() || 0;\n\n    // Calculate balance based on account type\n    // ASSET and EXPENSE accounts: debit increases, credit decreases\n    // LIABILITY, EQUITY, and INCOME accounts: credit increases, debit decreases\n    const isDebitNormal = ['ASSET', 'EXPENSE'].includes(account.type);\n    const balance = isDebitNormal ? debit - credit : credit - debit;\n\n    return { debit, credit, balance };\n  }\n\n  async getBalanceForMultiple(\n    companyId: string,\n    accountIds: string[],\n    startDate?: Date,\n    endDate?: Date,\n  ): Promise<Map<string, { debit: number; credit: number; balance: number }>> {\n    const accounts = await this.prisma.account.findMany({\n      where: { id: { in: accountIds }, companyId },\n    });\n\n    const accountTypeMap = new Map(accounts.map((a) => [a.id, a.type]));\n\n    const lines = await this.prisma.journalLine.groupBy({\n      by: ['accountId'],\n      where: {\n        accountId: { in: accountIds },\n        journalEntry: {\n          companyId,\n          status: 'POSTED',\n          ...(startDate && { date: { gte: startDate } }),\n          ...(endDate && { date: { lte: endDate } }),\n        },\n      },\n      _sum: {\n        debit: true,\n        credit: true,\n      },\n    });\n\n    const result = new Map<string, { debit: number; credit: number; balance: number }>();\n\n    for (const line of lines) {\n      const debit = line._sum.debit?.toNumber() || 0;\n      const credit = line._sum.credit?.toNumber() || 0;\n      const accountType = accountTypeMap.get(line.accountId);\n      const isDebitNormal = accountType && ['ASSET', 'EXPENSE'].includes(accountType);\n      const balance = isDebitNormal ? debit - credit : credit - debit;\n\n      result.set(line.accountId, { debit, credit, balance });\n    }\n\n    // Add zero balances for accounts with no entries\n    for (const accountId of accountIds) {\n      if (!result.has(accountId)) {\n        result.set(accountId, { debit: 0, credit: 0, balance: 0 });\n      }\n    }\n\n    return result;\n  }\n\n  async create(companyId: string, dto: CreateAccountDto): Promise<Account> {\n    // Check if code already exists\n    const existing = await this.findByCode(companyId, dto.code);\n    if (existing) {\n      throw new ConflictException(`Account with code ${dto.code} already exists`);\n    }\n\n    // Validate parent if provided\n    if (dto.parentCode) {\n      const parent = await this.findByCode(companyId, dto.parentCode);\n      if (!parent) {\n        throw new NotFoundException(`Parent account with code ${dto.parentCode} not found`);\n      }\n    }\n\n    return this.prisma.account.create({\n      data: {\n        code: dto.code,\n        name: dto.name,\n        type: dto.type as AccountType,\n        parentCode: dto.parentCode || null,\n        companyId,\n        isActive: true,\n      },\n    });\n  }\n\n  async update(\n    companyId: string,\n    id: string,\n    dto: Partial<CreateAccountDto>,\n  ): Promise<Account> {\n    await this.findById(companyId, id);\n\n    const updateData: Prisma.AccountUpdateInput = {};\n\n    if (dto.name) updateData.name = dto.name;\n    if (dto.type) updateData.type = dto.type as AccountType;\n\n    if (dto.parentCode !== undefined) {\n      if (dto.parentCode) {\n        const parent = await this.findByCode(companyId, dto.parentCode);\n        if (!parent) {\n          throw new NotFoundException(`Parent account with code ${dto.parentCode} not found`);\n        }\n      }\n      updateData.parentCode = dto.parentCode || null;\n    }\n\n    return this.prisma.account.update({\n      where: { id },\n      data: updateData,\n    });\n  }\n\n  async deactivate(companyId: string, id: string): Promise<Account> {\n    await this.findById(companyId, id);\n\n    return this.prisma.account.update({\n      where: { id },\n      data: { isActive: false },\n    });\n  }\n\n  async activate(companyId: string, id: string): Promise<Account> {\n    await this.findById(companyId, id);\n\n    return this.prisma.account.update({\n      where: { id },\n      data: { isActive: true },\n    });\n  }\n}\n"],"names":["AccountsService","findAll","companyId","query","where","type","isActive","undefined","search","OR","code","contains","mode","name","prisma","account","findMany","orderBy","findById","id","findFirst","NotFoundException","findByCode","findTree","accounts","accountByCode","Map","rootAccounts","set","children","node","get","parentCode","parent","push","getBalance","accountId","startDate","endDate","journalEntry","status","date","gte","lte","result","journalLine","aggregate","_sum","debit","credit","toNumber","isDebitNormal","includes","balance","getBalanceForMultiple","accountIds","in","accountTypeMap","map","a","lines","groupBy","by","line","accountType","has","create","dto","existing","ConflictException","data","update","updateData","deactivate","activate"],"mappings":"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"}