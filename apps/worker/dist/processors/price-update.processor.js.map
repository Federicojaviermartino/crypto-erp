{"version":3,"sources":["../../src/processors/price-update.processor.ts"],"sourcesContent":["import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';\nimport { Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { InjectQueue } from '@nestjs/bullmq';\nimport { Job, Queue } from 'bullmq';\nimport { PrismaService } from '@crypto-erp/database';\n\ninterface PriceUpdateJobData {\n  assets?: string[]; // If empty, update all assets\n  source?: 'coingecko' | 'manual';\n}\n\ninterface PriceUpdateResult {\n  updated: number;\n  failed: number;\n  prices: Record<string, number>;\n  errors: string[];\n}\n\n// CoinGecko ID mapping for common assets\nconst COINGECKO_IDS: Record<string, string> = {\n  BTC: 'bitcoin',\n  ETH: 'ethereum',\n  USDT: 'tether',\n  USDC: 'usd-coin',\n  BNB: 'binancecoin',\n  XRP: 'ripple',\n  ADA: 'cardano',\n  SOL: 'solana',\n  DOGE: 'dogecoin',\n  DOT: 'polkadot',\n  MATIC: 'matic-network',\n  SHIB: 'shiba-inu',\n  TRX: 'tron',\n  AVAX: 'avalanche-2',\n  LINK: 'chainlink',\n  UNI: 'uniswap',\n  ATOM: 'cosmos',\n  LTC: 'litecoin',\n  ETC: 'ethereum-classic',\n  XLM: 'stellar',\n  NEAR: 'near',\n  APT: 'aptos',\n  ARB: 'arbitrum',\n  OP: 'optimism',\n  MKR: 'maker',\n  AAVE: 'aave',\n  CRV: 'curve-dao-token',\n  LDO: 'lido-dao',\n  SNX: 'havven',\n  COMP: 'compound-governance-token',\n};\n\nconst QUEUE_NAME = 'price-update';\n\n@Processor(QUEUE_NAME)\nexport class PriceUpdateProcessor extends WorkerHost {\n  private readonly logger = new Logger(PriceUpdateProcessor.name);\n  private readonly coingeckoApiKey: string | undefined;\n  private readonly coingeckoBaseUrl = 'https://api.coingecko.com/api/v3';\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly configService: ConfigService,\n    @InjectQueue(QUEUE_NAME) private readonly priceQueue: Queue,\n  ) {\n    super();\n    this.coingeckoApiKey = this.configService.get('COINGECKO_API_KEY');\n  }\n\n  /**\n   * Cron job: Update prices every 5 minutes\n   */\n  @Cron(CronExpression.EVERY_5_MINUTES)\n  async scheduledPriceUpdate() {\n    this.logger.log('Scheduled price update started');\n\n    await this.priceQueue.add(\n      'scheduled-update',\n      { source: 'coingecko' },\n      {\n        jobId: `price-update-${Date.now()}`,\n        priority: 5,\n      },\n    );\n  }\n\n  async process(job: Job<PriceUpdateJobData>): Promise<PriceUpdateResult> {\n    const { assets, source = 'coingecko' } = job.data;\n\n    this.logger.log(`Processing price update for ${assets?.length || 'all'} assets via ${source}`);\n\n    const result: PriceUpdateResult = {\n      updated: 0,\n      failed: 0,\n      prices: {},\n      errors: [],\n    };\n\n    try {\n      // Get assets to update\n      let assetsToUpdate: string[];\n\n      if (assets && assets.length > 0) {\n        assetsToUpdate = assets;\n      } else {\n        // Get all unique assets from the database\n        const dbAssets = await this.prisma.cryptoAsset.findMany({\n          select: { symbol: true },\n          distinct: ['symbol'],\n        });\n        assetsToUpdate = dbAssets.map((a) => a.symbol);\n      }\n\n      if (assetsToUpdate.length === 0) {\n        this.logger.warn('No assets to update');\n        return result;\n      }\n\n      // Fetch prices from CoinGecko\n      const prices = await this.fetchPricesFromCoinGecko(assetsToUpdate);\n\n      // Update each asset in the database\n      for (const symbol of assetsToUpdate) {\n        try {\n          const price = prices[symbol];\n\n          if (price !== undefined) {\n            await this.prisma.cryptoAsset.updateMany({\n              where: { symbol },\n              data: {\n                lastPrice: price.toString(),\n                lastPriceAt: new Date(),\n              },\n            });\n\n            // Also store in price history for FIFO calculations\n            await this.prisma.priceHistory.create({\n              data: {\n                symbol,\n                priceEur: price.toString(),\n                source: 'coingecko',\n                timestamp: new Date(),\n              },\n            });\n\n            result.updated++;\n            result.prices[symbol] = price;\n          } else {\n            result.failed++;\n            result.errors.push(`No price found for ${symbol}`);\n          }\n        } catch (assetError) {\n          result.failed++;\n          const errorMessage = assetError instanceof Error ? assetError.message : 'Unknown error';\n          result.errors.push(`Failed to update ${symbol}: ${errorMessage}`);\n        }\n      }\n\n      this.logger.log(\n        `Price update completed: ${result.updated} updated, ${result.failed} failed`,\n      );\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      result.errors.push(errorMessage);\n      this.logger.error(`Price update failed: ${errorMessage}`);\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Fetch prices from CoinGecko API\n   */\n  private async fetchPricesFromCoinGecko(symbols: string[]): Promise<Record<string, number>> {\n    const prices: Record<string, number> = {};\n\n    // Map symbols to CoinGecko IDs\n    const coingeckoIds: string[] = [];\n    const symbolToId: Record<string, string> = {};\n\n    for (const symbol of symbols) {\n      const id = COINGECKO_IDS[symbol.toUpperCase()];\n      if (id) {\n        coingeckoIds.push(id);\n        symbolToId[id] = symbol;\n      }\n    }\n\n    if (coingeckoIds.length === 0) {\n      return prices;\n    }\n\n    // CoinGecko allows up to 250 IDs per request\n    const batchSize = 250;\n    for (let i = 0; i < coingeckoIds.length; i += batchSize) {\n      const batch = coingeckoIds.slice(i, i + batchSize);\n      const idsParam = batch.join(',');\n\n      try {\n        const url = `${this.coingeckoBaseUrl}/simple/price?ids=${idsParam}&vs_currencies=eur`;\n        const headers: Record<string, string> = {\n          Accept: 'application/json',\n        };\n\n        // Add API key if available (for higher rate limits)\n        if (this.coingeckoApiKey) {\n          headers['x-cg-demo-api-key'] = this.coingeckoApiKey;\n        }\n\n        const response = await fetch(url, { headers });\n\n        if (!response.ok) {\n          throw new Error(`CoinGecko API error: ${response.status} ${response.statusText}`);\n        }\n\n        const data = await response.json() as Record<string, { eur?: number }>;\n\n        // Map back to symbols\n        for (const [id, priceData] of Object.entries(data)) {\n          const symbol = symbolToId[id];\n          if (symbol && priceData.eur) {\n            prices[symbol] = priceData.eur;\n          }\n        }\n\n        // Rate limiting: wait 1 second between batches (free tier: 10-30 calls/min)\n        if (i + batchSize < coingeckoIds.length) {\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        this.logger.error(`CoinGecko batch request failed: ${errorMessage}`);\n      }\n    }\n\n    return prices;\n  }\n\n  @OnWorkerEvent('completed')\n  onCompleted(job: Job<PriceUpdateJobData>) {\n    this.logger.debug(`Price update job ${job.id} completed`);\n  }\n\n  @OnWorkerEvent('failed')\n  onFailed(job: Job<PriceUpdateJobData> | undefined, error: Error) {\n    this.logger.error(`Price update job failed: ${error.message}`);\n  }\n}\n"],"names":["PriceUpdateProcessor","COINGECKO_IDS","BTC","ETH","USDT","USDC","BNB","XRP","ADA","SOL","DOGE","DOT","MATIC","SHIB","TRX","AVAX","LINK","UNI","ATOM","LTC","ETC","XLM","NEAR","APT","ARB","OP","MKR","AAVE","CRV","LDO","SNX","COMP","QUEUE_NAME","WorkerHost","scheduledPriceUpdate","logger","log","priceQueue","add","source","jobId","Date","now","priority","process","job","assets","data","length","result","updated","failed","prices","errors","assetsToUpdate","dbAssets","prisma","cryptoAsset","findMany","select","symbol","distinct","map","a","warn","fetchPricesFromCoinGecko","price","undefined","updateMany","where","lastPrice","toString","lastPriceAt","priceHistory","create","priceEur","timestamp","push","assetError","errorMessage","Error","message","error","symbols","coingeckoIds","symbolToId","id","toUpperCase","batchSize","i","batch","slice","idsParam","join","url","coingeckoBaseUrl","headers","Accept","coingeckoApiKey","response","fetch","ok","status","statusText","json","priceData","Object","entries","eur","Promise","resolve","setTimeout","onCompleted","debug","onFailed","configService","Logger","name","get","EVERY_5_MINUTES"],"mappings":"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"}