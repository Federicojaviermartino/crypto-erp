{"version":3,"sources":["../../../src/modules/payments/stripe.service.ts"],"sourcesContent":["import { Injectable, Logger, BadRequestException } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { PrismaService } from '@crypto-erp/database';\nimport Stripe from 'stripe';\n\n@Injectable()\nexport class StripeService {\n  private readonly logger = new Logger(StripeService.name);\n  private stripe: Stripe;\n  private readonly webhookSecret: string;\n\n  constructor(\n    private readonly config: ConfigService,\n    private readonly prisma: PrismaService,\n  ) {\n    const apiKey = this.config.get<string>('STRIPE_SECRET_KEY');\n    if (!apiKey) {\n      this.logger.warn('STRIPE_SECRET_KEY not configured - payments disabled');\n      return;\n    }\n\n    this.stripe = new Stripe(apiKey, {\n      apiVersion: '2024-12-18.acacia',\n      typescript: true,\n    });\n\n    this.webhookSecret = this.config.get<string>('STRIPE_WEBHOOK_SECRET') || '';\n    this.logger.log('Stripe initialized successfully');\n  }\n\n  /**\n   * Create or retrieve a Stripe customer for a company\n   */\n  async createOrGetCustomer(companyId: string): Promise<string> {\n    const company = await this.prisma.company.findUniqueOrThrow({\n      where: { id: companyId },\n    });\n\n    // Check if subscription already has a Stripe customer\n    const subscription = await this.prisma.subscription.findUnique({\n      where: { companyId },\n    });\n\n    if (subscription?.stripeCustomerId) {\n      this.logger.log(`Using existing Stripe customer: ${subscription.stripeCustomerId}`);\n      return subscription.stripeCustomerId;\n    }\n\n    // Create new Stripe customer\n    const customer = await this.stripe.customers.create({\n      name: company.name,\n      email: company.email || undefined,\n      metadata: {\n        companyId,\n        taxId: company.taxId,\n      },\n    });\n\n    this.logger.log(`Created Stripe customer: ${customer.id} for company ${companyId}`);\n\n    // Update subscription with customer ID\n    if (subscription) {\n      await this.prisma.subscription.update({\n        where: { companyId },\n        data: { stripeCustomerId: customer.id },\n      });\n    }\n\n    return customer.id;\n  }\n\n  /**\n   * Create a checkout session for subscription\n   */\n  async createCheckoutSession(params: {\n    companyId: string;\n    planId: string;\n    successUrl: string;\n    cancelUrl: string;\n  }): Promise<Stripe.Checkout.Session> {\n    const { companyId, planId, successUrl, cancelUrl } = params;\n\n    const plan = await this.prisma.subscriptionPlan.findUniqueOrThrow({\n      where: { id: planId },\n    });\n\n    if (!plan.stripePriceId) {\n      throw new BadRequestException('Plan does not have a Stripe price configured');\n    }\n\n    const customerId = await this.createOrGetCustomer(companyId);\n\n    const session = await this.stripe.checkout.sessions.create({\n      customer: customerId,\n      mode: 'subscription',\n      line_items: [\n        {\n          price: plan.stripePriceId,\n          quantity: 1,\n        },\n      ],\n      success_url: successUrl,\n      cancel_url: cancelUrl,\n      metadata: {\n        companyId,\n        planId,\n      },\n      subscription_data: {\n        metadata: {\n          companyId,\n          planId,\n        },\n        trial_period_days: 14, // 14-day trial\n      },\n    });\n\n    this.logger.log(`Created checkout session ${session.id} for company ${companyId}`);\n\n    return session;\n  }\n\n  /**\n   * Create customer portal session for managing subscription\n   */\n  async createPortalSession(params: {\n    companyId: string;\n    returnUrl: string;\n  }): Promise<Stripe.BillingPortal.Session> {\n    const { companyId, returnUrl } = params;\n\n    const customerId = await this.createOrGetCustomer(companyId);\n\n    const session = await this.stripe.billingPortal.sessions.create({\n      customer: customerId,\n      return_url: returnUrl,\n    });\n\n    this.logger.log(`Created portal session for company ${companyId}`);\n\n    return session;\n  }\n\n  /**\n   * Handle Stripe webhook events\n   */\n  async handleWebhook(payload: string | Buffer, signature: string): Promise<void> {\n    let event: Stripe.Event;\n\n    try {\n      event = this.stripe.webhooks.constructEvent(\n        payload,\n        signature,\n        this.webhookSecret,\n      );\n    } catch (err) {\n      this.logger.error(`Webhook signature verification failed: ${err.message}`);\n      throw new BadRequestException('Invalid webhook signature');\n    }\n\n    this.logger.log(`Processing webhook event: ${event.type}`);\n\n    try {\n      switch (event.type) {\n        case 'checkout.session.completed':\n          await this.handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);\n          break;\n\n        case 'customer.subscription.created':\n        case 'customer.subscription.updated':\n          await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);\n          break;\n\n        case 'customer.subscription.deleted':\n          await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);\n          break;\n\n        case 'invoice.payment_succeeded':\n          await this.handlePaymentSucceeded(event.data.object as Stripe.Invoice);\n          break;\n\n        case 'invoice.payment_failed':\n          await this.handlePaymentFailed(event.data.object as Stripe.Invoice);\n          break;\n\n        default:\n          this.logger.log(`Unhandled event type: ${event.type}`);\n      }\n    } catch (error) {\n      this.logger.error(`Error processing webhook ${event.type}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Handle checkout session completed\n   */\n  private async handleCheckoutCompleted(session: Stripe.Checkout.Session): Promise<void> {\n    const companyId = session.metadata?.companyId;\n    const planId = session.metadata?.planId;\n\n    if (!companyId || !planId) {\n      this.logger.warn('Checkout session missing metadata');\n      return;\n    }\n\n    const stripeSubscriptionId = session.subscription as string;\n\n    // Update or create subscription\n    await this.prisma.subscription.upsert({\n      where: { companyId },\n      create: {\n        companyId,\n        planId,\n        stripeCustomerId: session.customer as string,\n        stripeSubscriptionId,\n        status: 'TRIALING',\n        trialEndsAt: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14 days\n      },\n      update: {\n        planId,\n        stripeSubscriptionId,\n        status: 'TRIALING',\n      },\n    });\n\n    this.logger.log(`Checkout completed for company ${companyId}`);\n  }\n\n  /**\n   * Handle subscription created/updated\n   */\n  private async handleSubscriptionUpdated(subscription: Stripe.Subscription): Promise<void> {\n    const companyId = subscription.metadata?.companyId;\n\n    if (!companyId) {\n      this.logger.warn('Subscription missing companyId metadata');\n      return;\n    }\n\n    const status = this.mapStripeStatus(subscription.status);\n\n    await this.prisma.subscription.update({\n      where: { companyId },\n      data: {\n        status,\n        currentPeriodStart: new Date(subscription.current_period_start * 1000),\n        currentPeriodEnd: new Date(subscription.current_period_end * 1000),\n        cancelAtPeriodEnd: subscription.cancel_at_period_end,\n        canceledAt: subscription.canceled_at\n          ? new Date(subscription.canceled_at * 1000)\n          : null,\n      },\n    });\n\n    this.logger.log(`Subscription updated for company ${companyId}: ${status}`);\n  }\n\n  /**\n   * Handle subscription deleted\n   */\n  private async handleSubscriptionDeleted(subscription: Stripe.Subscription): Promise<void> {\n    const companyId = subscription.metadata?.companyId;\n\n    if (!companyId) {\n      this.logger.warn('Subscription missing companyId metadata');\n      return;\n    }\n\n    await this.prisma.subscription.update({\n      where: { companyId },\n      data: {\n        status: 'CANCELED',\n        canceledAt: new Date(),\n      },\n    });\n\n    this.logger.log(`Subscription canceled for company ${companyId}`);\n  }\n\n  /**\n   * Handle successful payment\n   */\n  private async handlePaymentSucceeded(invoice: Stripe.Invoice): Promise<void> {\n    const subscriptionId = invoice.subscription as string;\n\n    if (!subscriptionId) {\n      this.logger.warn('Invoice missing subscription ID');\n      return;\n    }\n\n    // Find subscription by Stripe subscription ID\n    const subscription = await this.prisma.subscription.findFirst({\n      where: { stripeSubscriptionId: subscriptionId },\n    });\n\n    if (!subscription) {\n      this.logger.warn(`Subscription not found for Stripe ID: ${subscriptionId}`);\n      return;\n    }\n\n    // Create payment record\n    await this.prisma.payment.create({\n      data: {\n        subscriptionId: subscription.id,\n        stripePaymentIntentId: invoice.payment_intent as string,\n        stripeInvoiceId: invoice.id,\n        amount: invoice.amount_paid / 100, // Convert cents to euros\n        currency: invoice.currency.toUpperCase(),\n        status: 'SUCCEEDED',\n        description: invoice.description || `Payment for ${invoice.period_start}`,\n        paidAt: new Date(invoice.status_transitions.paid_at! * 1000),\n      },\n    });\n\n    this.logger.log(`Payment succeeded for subscription ${subscription.id}`);\n  }\n\n  /**\n   * Handle failed payment\n   */\n  private async handlePaymentFailed(invoice: Stripe.Invoice): Promise<void> {\n    const subscriptionId = invoice.subscription as string;\n\n    if (!subscriptionId) {\n      this.logger.warn('Invoice missing subscription ID');\n      return;\n    }\n\n    const subscription = await this.prisma.subscription.findFirst({\n      where: { stripeSubscriptionId: subscriptionId },\n    });\n\n    if (!subscription) {\n      this.logger.warn(`Subscription not found for Stripe ID: ${subscriptionId}`);\n      return;\n    }\n\n    // Create failed payment record\n    await this.prisma.payment.create({\n      data: {\n        subscriptionId: subscription.id,\n        stripePaymentIntentId: invoice.payment_intent as string,\n        stripeInvoiceId: invoice.id,\n        amount: invoice.amount_due / 100,\n        currency: invoice.currency.toUpperCase(),\n        status: 'FAILED',\n        description: invoice.description || `Failed payment for ${invoice.period_start}`,\n        failureReason: invoice.last_finalization_error?.message || 'Payment failed',\n      },\n    });\n\n    this.logger.log(`Payment failed for subscription ${subscription.id}`);\n  }\n\n  /**\n   * Map Stripe subscription status to internal status\n   */\n  private mapStripeStatus(stripeStatus: Stripe.Subscription.Status): string {\n    const statusMap: Record<Stripe.Subscription.Status, string> = {\n      trialing: 'TRIALING',\n      active: 'ACTIVE',\n      past_due: 'PAST_DUE',\n      canceled: 'CANCELED',\n      incomplete: 'INCOMPLETE',\n      incomplete_expired: 'INCOMPLETE_EXPIRED',\n      unpaid: 'UNPAID',\n      paused: 'CANCELED',\n    };\n\n    return statusMap[stripeStatus] || 'CANCELED';\n  }\n\n  /**\n   * Cancel subscription at period end\n   */\n  async cancelSubscription(companyId: string): Promise<void> {\n    const subscription = await this.prisma.subscription.findUnique({\n      where: { companyId },\n    });\n\n    if (!subscription?.stripeSubscriptionId) {\n      throw new BadRequestException('No active subscription found');\n    }\n\n    await this.stripe.subscriptions.update(subscription.stripeSubscriptionId, {\n      cancel_at_period_end: true,\n    });\n\n    await this.prisma.subscription.update({\n      where: { companyId },\n      data: { cancelAtPeriodEnd: true },\n    });\n\n    this.logger.log(`Subscription canceled at period end for company ${companyId}`);\n  }\n\n  /**\n   * Reactivate canceled subscription\n   */\n  async reactivateSubscription(companyId: string): Promise<void> {\n    const subscription = await this.prisma.subscription.findUnique({\n      where: { companyId },\n    });\n\n    if (!subscription?.stripeSubscriptionId) {\n      throw new BadRequestException('No subscription found');\n    }\n\n    await this.stripe.subscriptions.update(subscription.stripeSubscriptionId, {\n      cancel_at_period_end: false,\n    });\n\n    await this.prisma.subscription.update({\n      where: { companyId },\n      data: { cancelAtPeriodEnd: false },\n    });\n\n    this.logger.log(`Subscription reactivated for company ${companyId}`);\n  }\n}\n"],"names":["StripeService","createOrGetCustomer","companyId","company","prisma","findUniqueOrThrow","where","id","subscription","findUnique","stripeCustomerId","logger","log","customer","stripe","customers","create","name","email","undefined","metadata","taxId","update","data","createCheckoutSession","params","planId","successUrl","cancelUrl","plan","subscriptionPlan","stripePriceId","BadRequestException","customerId","session","checkout","sessions","mode","line_items","price","quantity","success_url","cancel_url","subscription_data","trial_period_days","createPortalSession","returnUrl","billingPortal","return_url","handleWebhook","payload","signature","event","webhooks","constructEvent","webhookSecret","err","error","message","type","handleCheckoutCompleted","object","handleSubscriptionUpdated","handleSubscriptionDeleted","handlePaymentSucceeded","handlePaymentFailed","warn","stripeSubscriptionId","upsert","status","trialEndsAt","Date","now","mapStripeStatus","currentPeriodStart","current_period_start","currentPeriodEnd","current_period_end","cancelAtPeriodEnd","cancel_at_period_end","canceledAt","canceled_at","invoice","subscriptionId","findFirst","payment","stripePaymentIntentId","payment_intent","stripeInvoiceId","amount","amount_paid","currency","toUpperCase","description","period_start","paidAt","status_transitions","paid_at","amount_due","failureReason","last_finalization_error","stripeStatus","statusMap","trialing","active","past_due","canceled","incomplete","incomplete_expired","unpaid","paused","cancelSubscription","subscriptions","reactivateSubscription","config","Logger","apiKey","get","Stripe","apiVersion","typescript"],"mappings":"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"}