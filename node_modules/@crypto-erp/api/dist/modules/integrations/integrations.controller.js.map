{"version":3,"sources":["../../../src/modules/integrations/integrations.controller.ts"],"sourcesContent":["import {\n  Controller,\n  Get,\n  Post,\n  Delete,\n  Param,\n  Query,\n  Headers,\n  BadRequestException,\n  UseGuards,\n} from '@nestjs/common';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard.js';\nimport { BaseIntegrationService } from './base/base-integration.service.js';\nimport { QuickBooksService } from './quickbooks/quickbooks.service.js';\nimport { XeroService } from './xero/xero.service.js';\n\n/**\n * Integrations Controller\n * Manages third-party integrations (QuickBooks, Xero, HubSpot, Salesforce, etc.)\n *\n * Flow:\n * 1. GET /integrations/:provider/connect - Get OAuth URL\n * 2. User authorizes on provider's site\n * 3. Provider redirects to callback with code\n * 4. POST /integrations/:provider/callback - Exchange code for token\n * 5. GET /integrations - List all connected integrations\n * 6. POST /integrations/:id/sync - Trigger manual sync\n * 7. DELETE /integrations/:id - Disconnect integration\n */\n@Controller('integrations')\n@UseGuards(JwtAuthGuard)\nexport class IntegrationsController {\n  constructor(\n    private readonly baseService: BaseIntegrationService,\n    private readonly quickbooksService: QuickBooksService,\n    private readonly xeroService: XeroService,\n  ) {}\n\n  private getCompanyId(headers: Record<string, string>): string {\n    const companyId = headers['x-company-id'];\n    if (!companyId) {\n      throw new BadRequestException('X-Company-Id header is required');\n    }\n    return companyId;\n  }\n\n  /**\n   * List all integrations for company\n   * GET /integrations\n   */\n  @Get()\n  async listIntegrations(@Headers() headers: Record<string, string>) {\n    const companyId = this.getCompanyId(headers);\n    return this.baseService.listIntegrations(companyId);\n  }\n\n  /**\n   * Get OAuth authorization URL for a provider\n   * GET /integrations/:provider/connect?redirectUri=...\n   *\n   * Example:\n   * GET /integrations/quickbooks/connect?redirectUri=https://app.crypto-erp.com/integrations/callback\n   *\n   * Response:\n   * {\n   *   \"authorizationUrl\": \"https://appcenter.intuit.com/connect/oauth2?...\",\n   *   \"state\": \"random_state_token\"\n   * }\n   */\n  @Get(':provider/connect')\n  async getAuthorizationUrl(\n    @Headers() headers: Record<string, string>,\n    @Param('provider') provider: string,\n    @Query('redirectUri') redirectUri?: string,\n  ) {\n    const companyId = this.getCompanyId(headers);\n\n    if (!redirectUri) {\n      throw new BadRequestException('redirectUri query parameter is required');\n    }\n\n    // Generate random state for CSRF protection\n    const state = `${companyId}:${Math.random().toString(36).substring(7)}`;\n\n    let authorizationUrl: string;\n\n    switch (provider) {\n      case 'quickbooks':\n        authorizationUrl = this.quickbooksService.getAuthorizationUrl(\n          companyId,\n          redirectUri,\n          state,\n        );\n        break;\n      case 'xero':\n        authorizationUrl = this.xeroService.getAuthorizationUrl(\n          companyId,\n          redirectUri,\n          state,\n        );\n        break;\n      default:\n        throw new BadRequestException(`Provider ${provider} is not supported`);\n    }\n\n    return {\n      authorizationUrl,\n      state,\n    };\n  }\n\n  /**\n   * Handle OAuth callback and exchange code for token\n   * POST /integrations/:provider/callback\n   *\n   * Body:\n   * {\n   *   \"code\": \"AUTH_CODE\",\n   *   \"redirectUri\": \"https://app.crypto-erp.com/integrations/callback\",\n   *   \"state\": \"company_id:random\"\n   * }\n   *\n   * Response:\n   * {\n   *   \"success\": true,\n   *   \"integration\": { ... }\n   * }\n   */\n  @Post(':provider/callback')\n  async handleCallback(\n    @Headers() headers: Record<string, string>,\n    @Param('provider') provider: string,\n    @Query('code') code: string,\n    @Query('redirectUri') redirectUri: string,\n    @Query('state') state?: string,\n  ) {\n    const companyId = this.getCompanyId(headers);\n\n    if (!code || !redirectUri) {\n      throw new BadRequestException('code and redirectUri are required');\n    }\n\n    // Verify state contains companyId (CSRF protection)\n    if (state && !state.startsWith(companyId)) {\n      throw new BadRequestException('Invalid state parameter');\n    }\n\n    let providerService;\n    let name: string;\n\n    switch (provider) {\n      case 'quickbooks':\n        providerService = this.quickbooksService;\n        name = 'QuickBooks Online';\n        break;\n      case 'xero':\n        providerService = this.xeroService;\n        name = 'Xero Accounting';\n        break;\n      default:\n        throw new BadRequestException(`Provider ${provider} is not supported`);\n    }\n\n    // Exchange code for access token\n    const tokenResponse = await providerService.exchangeCodeForToken(code, redirectUri);\n\n    // Save integration to database\n    const integration = await this.baseService.saveIntegration({\n      companyId,\n      provider,\n      name,\n      accessToken: tokenResponse.accessToken,\n      refreshToken: tokenResponse.refreshToken,\n      expiresIn: tokenResponse.expiresIn,\n      metadata: tokenResponse.metadata,\n    });\n\n    return {\n      success: true,\n      integration: {\n        id: integration.id,\n        provider: integration.provider,\n        name: integration.name,\n        createdAt: integration.createdAt,\n      },\n    };\n  }\n\n  /**\n   * Trigger manual sync for an integration\n   * POST /integrations/:id/sync\n   */\n  @Post(':id/sync')\n  async syncIntegration(\n    @Headers() headers: Record<string, string>,\n    @Param('id') integrationId: string,\n  ) {\n    const companyId = this.getCompanyId(headers);\n\n    // Get integration\n    const integration = await this.baseService.prisma.integration.findFirst({\n      where: {\n        id: integrationId,\n        companyId,\n      },\n    });\n\n    if (!integration) {\n      throw new BadRequestException('Integration not found');\n    }\n\n    // Get decrypted access token\n    const accessToken = this.baseService.getDecryptedAccessToken(integration);\n    if (!accessToken) {\n      throw new BadRequestException('Integration has no valid access token');\n    }\n\n    // Get provider service\n    let providerService;\n\n    switch (integration.provider) {\n      case 'quickbooks':\n        providerService = this.quickbooksService;\n        break;\n      case 'xero':\n        providerService = this.xeroService;\n        break;\n      default:\n        throw new BadRequestException(`Provider ${integration.provider} is not supported`);\n    }\n\n    // Trigger sync\n    const result = await providerService.syncData(integrationId, accessToken);\n\n    return {\n      success: result.success,\n      itemsSynced: result.itemsSynced,\n      errors: result.errors,\n    };\n  }\n\n  /**\n   * Disconnect an integration\n   * DELETE /integrations/:id\n   */\n  @Delete(':id')\n  async disconnectIntegration(\n    @Headers() headers: Record<string, string>,\n    @Param('id') integrationId: string,\n  ) {\n    const companyId = this.getCompanyId(headers);\n\n    await this.baseService.disconnectIntegration(integrationId, companyId);\n\n    return {\n      success: true,\n      message: 'Integration disconnected successfully',\n    };\n  }\n}\n"],"names":["IntegrationsController","getCompanyId","headers","companyId","BadRequestException","listIntegrations","baseService","getAuthorizationUrl","provider","redirectUri","state","Math","random","toString","substring","authorizationUrl","quickbooksService","xeroService","handleCallback","code","startsWith","providerService","name","tokenResponse","exchangeCodeForToken","integration","saveIntegration","accessToken","refreshToken","expiresIn","metadata","success","id","createdAt","syncIntegration","integrationId","prisma","findFirst","where","getDecryptedAccessToken","result","syncData","itemsSynced","errors","disconnectIntegration","message"],"mappings":"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"}