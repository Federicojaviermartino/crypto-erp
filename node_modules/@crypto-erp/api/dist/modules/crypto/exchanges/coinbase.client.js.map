{"version":3,"sources":["../../../../src/modules/crypto/exchanges/coinbase.client.ts"],"sourcesContent":["import { Logger } from '@nestjs/common';\nimport * as crypto from 'crypto';\nimport {\n  ExchangeClient,\n  ExchangeCredentials,\n  ExchangeBalance,\n  ExchangeTrade,\n  ExchangeDeposit,\n  ExchangeWithdrawal,\n} from './exchange.interface.js';\n\nexport class CoinbaseClient implements ExchangeClient {\n  readonly name = 'Coinbase';\n  readonly country = 'US';\n  private readonly logger = new Logger(CoinbaseClient.name);\n  private readonly baseUrl = 'https://api.coinbase.com';\n\n  constructor(private readonly credentials: ExchangeCredentials) {}\n\n  private getSignature(\n    timestamp: string,\n    method: string,\n    path: string,\n    body: string = '',\n  ): string {\n    const message = timestamp + method + path + body;\n    return crypto\n      .createHmac('sha256', this.credentials.apiSecret)\n      .update(message)\n      .digest('hex');\n  }\n\n  private async request<T>(\n    method: 'GET' | 'POST',\n    endpoint: string,\n    body?: Record<string, unknown>,\n  ): Promise<T> {\n    const timestamp = Math.floor(Date.now() / 1000).toString();\n    const bodyString = body ? JSON.stringify(body) : '';\n    const signature = this.getSignature(timestamp, method, endpoint, bodyString);\n\n    const headers: Record<string, string> = {\n      'CB-ACCESS-KEY': this.credentials.apiKey,\n      'CB-ACCESS-SIGN': signature,\n      'CB-ACCESS-TIMESTAMP': timestamp,\n      'CB-VERSION': '2024-01-01',\n      'Content-Type': 'application/json',\n    };\n\n    const url = `${this.baseUrl}${endpoint}`;\n\n    const response = await fetch(url, {\n      method,\n      headers,\n      body: bodyString || undefined,\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      this.logger.error(`Coinbase API error: ${response.status} - ${error}`);\n      throw new Error(`Coinbase API error: ${response.status}`);\n    }\n\n    const data = await response.json() as { data: T; pagination?: { next_uri: string } };\n    return data.data;\n  }\n\n  async testConnection(): Promise<boolean> {\n    try {\n      await this.request<{ id: string }>('GET', '/v2/user');\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getBalances(): Promise<ExchangeBalance[]> {\n    interface CoinbaseAccount {\n      id: string;\n      currency: { code: string };\n      balance: { amount: string };\n    }\n\n    const accounts = await this.request<CoinbaseAccount[]>('GET', '/v2/accounts?limit=100');\n\n    return accounts\n      .filter(a => parseFloat(a.balance.amount) > 0)\n      .map(a => ({\n        asset: a.currency.code,\n        free: a.balance.amount,\n        locked: '0',\n        total: a.balance.amount,\n      }));\n  }\n\n  async getTrades(options: {\n    symbol?: string;\n    startTime?: Date;\n    endTime?: Date;\n    limit?: number;\n  } = {}): Promise<ExchangeTrade[]> {\n    // Coinbase requires iterating through accounts to get transactions\n    interface CoinbaseAccount {\n      id: string;\n      currency: { code: string };\n    }\n\n    interface CoinbaseTrade {\n      id: string;\n      type: string;\n      status: string;\n      amount: { amount: string; currency: string };\n      native_amount: { amount: string; currency: string };\n      created_at: string;\n      details: {\n        title: string;\n        subtitle: string;\n        payment_method_name?: string;\n      };\n    }\n\n    const accounts = await this.request<CoinbaseAccount[]>('GET', '/v2/accounts?limit=100');\n    const allTrades: ExchangeTrade[] = [];\n\n    for (const account of accounts) {\n      if (options.symbol && account.currency.code !== options.symbol) {\n        continue;\n      }\n\n      try {\n        const transactions = await this.request<CoinbaseTrade[]>(\n          'GET',\n          `/v2/accounts/${account.id}/transactions?limit=100`,\n        );\n\n        const trades = transactions\n          .filter(t => t.type === 'buy' || t.type === 'sell')\n          .filter(t => {\n            const timestamp = new Date(t.created_at);\n            if (options.startTime && timestamp < options.startTime) return false;\n            if (options.endTime && timestamp > options.endTime) return false;\n            return true;\n          })\n          .map(t => ({\n            id: t.id,\n            symbol: `${account.currency.code}EUR`,\n            orderId: t.id,\n            side: t.type.toUpperCase() as 'BUY' | 'SELL',\n            price: (\n              Math.abs(parseFloat(t.native_amount.amount)) /\n              Math.abs(parseFloat(t.amount.amount))\n            ).toString(),\n            quantity: Math.abs(parseFloat(t.amount.amount)).toString(),\n            quoteQuantity: Math.abs(parseFloat(t.native_amount.amount)).toString(),\n            commission: '0',\n            commissionAsset: t.native_amount.currency,\n            timestamp: new Date(t.created_at),\n            isMaker: false,\n          }));\n\n        allTrades.push(...trades);\n      } catch {\n        // Account might not have transactions, skip\n      }\n    }\n\n    return allTrades.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n  }\n\n  async getDeposits(options: {\n    asset?: string;\n    startTime?: Date;\n    endTime?: Date;\n  } = {}): Promise<ExchangeDeposit[]> {\n    interface CoinbaseAccount {\n      id: string;\n      currency: { code: string };\n    }\n\n    interface CoinbaseTransaction {\n      id: string;\n      type: string;\n      status: string;\n      amount: { amount: string; currency: string };\n      created_at: string;\n      network?: { hash: string };\n    }\n\n    const accounts = await this.request<CoinbaseAccount[]>('GET', '/v2/accounts?limit=100');\n    const allDeposits: ExchangeDeposit[] = [];\n\n    for (const account of accounts) {\n      if (options.asset && account.currency.code !== options.asset) {\n        continue;\n      }\n\n      try {\n        const transactions = await this.request<CoinbaseTransaction[]>(\n          'GET',\n          `/v2/accounts/${account.id}/transactions?limit=100`,\n        );\n\n        const deposits = transactions\n          .filter(t => t.type === 'send' && parseFloat(t.amount.amount) > 0)\n          .filter(t => {\n            const timestamp = new Date(t.created_at);\n            if (options.startTime && timestamp < options.startTime) return false;\n            if (options.endTime && timestamp > options.endTime) return false;\n            return true;\n          })\n          .map(t => ({\n            id: t.id,\n            asset: account.currency.code,\n            amount: t.amount.amount,\n            status: this.mapStatus(t.status),\n            txHash: t.network?.hash,\n            timestamp: new Date(t.created_at),\n          }));\n\n        allDeposits.push(...deposits);\n      } catch {\n        // Account might not have transactions, skip\n      }\n    }\n\n    return allDeposits;\n  }\n\n  async getWithdrawals(options: {\n    asset?: string;\n    startTime?: Date;\n    endTime?: Date;\n  } = {}): Promise<ExchangeWithdrawal[]> {\n    interface CoinbaseAccount {\n      id: string;\n      currency: { code: string };\n    }\n\n    interface CoinbaseTransaction {\n      id: string;\n      type: string;\n      status: string;\n      amount: { amount: string; currency: string };\n      created_at: string;\n      network?: { hash: string; transaction_fee?: { amount: string } };\n      to?: string;\n    }\n\n    const accounts = await this.request<CoinbaseAccount[]>('GET', '/v2/accounts?limit=100');\n    const allWithdrawals: ExchangeWithdrawal[] = [];\n\n    for (const account of accounts) {\n      if (options.asset && account.currency.code !== options.asset) {\n        continue;\n      }\n\n      try {\n        const transactions = await this.request<CoinbaseTransaction[]>(\n          'GET',\n          `/v2/accounts/${account.id}/transactions?limit=100`,\n        );\n\n        const withdrawals = transactions\n          .filter(t => t.type === 'send' && parseFloat(t.amount.amount) < 0)\n          .filter(t => {\n            const timestamp = new Date(t.created_at);\n            if (options.startTime && timestamp < options.startTime) return false;\n            if (options.endTime && timestamp > options.endTime) return false;\n            return true;\n          })\n          .map(t => ({\n            id: t.id,\n            asset: account.currency.code,\n            amount: Math.abs(parseFloat(t.amount.amount)).toString(),\n            fee: t.network?.transaction_fee?.amount || '0',\n            status: this.mapWithdrawalStatus(t.status),\n            txHash: t.network?.hash,\n            address: t.to || '',\n            timestamp: new Date(t.created_at),\n          }));\n\n        allWithdrawals.push(...withdrawals);\n      } catch {\n        // Account might not have transactions, skip\n      }\n    }\n\n    return allWithdrawals;\n  }\n\n  private mapStatus(status: string): ExchangeDeposit['status'] {\n    const statusMap: Record<string, ExchangeDeposit['status']> = {\n      completed: 'COMPLETED',\n      pending: 'PENDING',\n      failed: 'FAILED',\n    };\n    return statusMap[status] || 'PENDING';\n  }\n\n  private mapWithdrawalStatus(status: string): ExchangeWithdrawal['status'] {\n    const statusMap: Record<string, ExchangeWithdrawal['status']> = {\n      completed: 'COMPLETED',\n      pending: 'PENDING',\n      failed: 'FAILED',\n      canceled: 'CANCELLED',\n    };\n    return statusMap[status] || 'PENDING';\n  }\n}\n"],"names":["CoinbaseClient","getSignature","timestamp","method","path","body","message","crypto","createHmac","credentials","apiSecret","update","digest","request","endpoint","Math","floor","Date","now","toString","bodyString","JSON","stringify","signature","headers","apiKey","url","baseUrl","response","fetch","undefined","ok","error","text","logger","status","Error","data","json","testConnection","getBalances","accounts","filter","a","parseFloat","balance","amount","map","asset","currency","code","free","locked","total","getTrades","options","allTrades","account","symbol","transactions","id","trades","t","type","created_at","startTime","endTime","orderId","side","toUpperCase","price","abs","native_amount","quantity","quoteQuantity","commission","commissionAsset","isMaker","push","sort","b","getTime","getDeposits","allDeposits","deposits","mapStatus","txHash","network","hash","getWithdrawals","allWithdrawals","withdrawals","fee","transaction_fee","mapWithdrawalStatus","address","to","statusMap","completed","pending","failed","canceled","name","country","Logger"],"mappings":";;;;+BAWaA;;;eAAAA;;;wBAXU;gEACC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUjB,IAAA,AAAMA,iBAAN,MAAMA;IAQHC,aACNC,SAAiB,EACjBC,MAAc,EACdC,IAAY,EACZC,OAAe,EAAE,EACT;QACR,MAAMC,UAAUJ,YAAYC,SAASC,OAAOC;QAC5C,OAAOE,QACJC,UAAU,CAAC,UAAU,IAAI,CAACC,WAAW,CAACC,SAAS,EAC/CC,MAAM,CAACL,SACPM,MAAM,CAAC;IACZ;IAEA,MAAcC,QACZV,MAAsB,EACtBW,QAAgB,EAChBT,IAA8B,EAClB;QACZ,MAAMH,YAAYa,KAAKC,KAAK,CAACC,KAAKC,GAAG,KAAK,MAAMC,QAAQ;QACxD,MAAMC,aAAaf,OAAOgB,KAAKC,SAAS,CAACjB,QAAQ;QACjD,MAAMkB,YAAY,IAAI,CAACtB,YAAY,CAACC,WAAWC,QAAQW,UAAUM;QAEjE,MAAMI,UAAkC;YACtC,iBAAiB,IAAI,CAACf,WAAW,CAACgB,MAAM;YACxC,kBAAkBF;YAClB,uBAAuBrB;YACvB,cAAc;YACd,gBAAgB;QAClB;QAEA,MAAMwB,MAAM,GAAG,IAAI,CAACC,OAAO,GAAGb,UAAU;QAExC,MAAMc,WAAW,MAAMC,MAAMH,KAAK;YAChCvB;YACAqB;YACAnB,MAAMe,cAAcU;QACtB;QAEA,IAAI,CAACF,SAASG,EAAE,EAAE;YAChB,MAAMC,QAAQ,MAAMJ,SAASK,IAAI;YACjC,IAAI,CAACC,MAAM,CAACF,KAAK,CAAC,CAAC,oBAAoB,EAAEJ,SAASO,MAAM,CAAC,GAAG,EAAEH,OAAO;YACrE,MAAM,IAAII,MAAM,CAAC,oBAAoB,EAAER,SAASO,MAAM,EAAE;QAC1D;QAEA,MAAME,OAAO,MAAMT,SAASU,IAAI;QAChC,OAAOD,KAAKA,IAAI;IAClB;IAEA,MAAME,iBAAmC;QACvC,IAAI;YACF,MAAM,IAAI,CAAC1B,OAAO,CAAiB,OAAO;YAC1C,OAAO;QACT,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,MAAM2B,cAA0C;QAO9C,MAAMC,WAAW,MAAM,IAAI,CAAC5B,OAAO,CAAoB,OAAO;QAE9D,OAAO4B,SACJC,MAAM,CAACC,CAAAA,IAAKC,WAAWD,EAAEE,OAAO,CAACC,MAAM,IAAI,GAC3CC,GAAG,CAACJ,CAAAA,IAAM,CAAA;gBACTK,OAAOL,EAAEM,QAAQ,CAACC,IAAI;gBACtBC,MAAMR,EAAEE,OAAO,CAACC,MAAM;gBACtBM,QAAQ;gBACRC,OAAOV,EAAEE,OAAO,CAACC,MAAM;YACzB,CAAA;IACJ;IAEA,MAAMQ,UAAUC,UAKZ,CAAC,CAAC,EAA4B;QAqBhC,MAAMd,WAAW,MAAM,IAAI,CAAC5B,OAAO,CAAoB,OAAO;QAC9D,MAAM2C,YAA6B,EAAE;QAErC,KAAK,MAAMC,WAAWhB,SAAU;YAC9B,IAAIc,QAAQG,MAAM,IAAID,QAAQR,QAAQ,CAACC,IAAI,KAAKK,QAAQG,MAAM,EAAE;gBAC9D;YACF;YAEA,IAAI;gBACF,MAAMC,eAAe,MAAM,IAAI,CAAC9C,OAAO,CACrC,OACA,CAAC,aAAa,EAAE4C,QAAQG,EAAE,CAAC,uBAAuB,CAAC;gBAGrD,MAAMC,SAASF,aACZjB,MAAM,CAACoB,CAAAA,IAAKA,EAAEC,IAAI,KAAK,SAASD,EAAEC,IAAI,KAAK,QAC3CrB,MAAM,CAACoB,CAAAA;oBACN,MAAM5D,YAAY,IAAIe,KAAK6C,EAAEE,UAAU;oBACvC,IAAIT,QAAQU,SAAS,IAAI/D,YAAYqD,QAAQU,SAAS,EAAE,OAAO;oBAC/D,IAAIV,QAAQW,OAAO,IAAIhE,YAAYqD,QAAQW,OAAO,EAAE,OAAO;oBAC3D,OAAO;gBACT,GACCnB,GAAG,CAACe,CAAAA,IAAM,CAAA;wBACTF,IAAIE,EAAEF,EAAE;wBACRF,QAAQ,GAAGD,QAAQR,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAC;wBACrCiB,SAASL,EAAEF,EAAE;wBACbQ,MAAMN,EAAEC,IAAI,CAACM,WAAW;wBACxBC,OAAO,AACLvD,CAAAA,KAAKwD,GAAG,CAAC3B,WAAWkB,EAAEU,aAAa,CAAC1B,MAAM,KAC1C/B,KAAKwD,GAAG,CAAC3B,WAAWkB,EAAEhB,MAAM,CAACA,MAAM,EAAC,EACpC3B,QAAQ;wBACVsD,UAAU1D,KAAKwD,GAAG,CAAC3B,WAAWkB,EAAEhB,MAAM,CAACA,MAAM,GAAG3B,QAAQ;wBACxDuD,eAAe3D,KAAKwD,GAAG,CAAC3B,WAAWkB,EAAEU,aAAa,CAAC1B,MAAM,GAAG3B,QAAQ;wBACpEwD,YAAY;wBACZC,iBAAiBd,EAAEU,aAAa,CAACvB,QAAQ;wBACzC/C,WAAW,IAAIe,KAAK6C,EAAEE,UAAU;wBAChCa,SAAS;oBACX,CAAA;gBAEFrB,UAAUsB,IAAI,IAAIjB;YACpB,EAAE,OAAM;YACN,4CAA4C;YAC9C;QACF;QAEA,OAAOL,UAAUuB,IAAI,CAAC,CAACpC,GAAGqC,IAAMA,EAAE9E,SAAS,CAAC+E,OAAO,KAAKtC,EAAEzC,SAAS,CAAC+E,OAAO;IAC7E;IAEA,MAAMC,YAAY3B,UAId,CAAC,CAAC,EAA8B;QAelC,MAAMd,WAAW,MAAM,IAAI,CAAC5B,OAAO,CAAoB,OAAO;QAC9D,MAAMsE,cAAiC,EAAE;QAEzC,KAAK,MAAM1B,WAAWhB,SAAU;YAC9B,IAAIc,QAAQP,KAAK,IAAIS,QAAQR,QAAQ,CAACC,IAAI,KAAKK,QAAQP,KAAK,EAAE;gBAC5D;YACF;YAEA,IAAI;gBACF,MAAMW,eAAe,MAAM,IAAI,CAAC9C,OAAO,CACrC,OACA,CAAC,aAAa,EAAE4C,QAAQG,EAAE,CAAC,uBAAuB,CAAC;gBAGrD,MAAMwB,WAAWzB,aACdjB,MAAM,CAACoB,CAAAA,IAAKA,EAAEC,IAAI,KAAK,UAAUnB,WAAWkB,EAAEhB,MAAM,CAACA,MAAM,IAAI,GAC/DJ,MAAM,CAACoB,CAAAA;oBACN,MAAM5D,YAAY,IAAIe,KAAK6C,EAAEE,UAAU;oBACvC,IAAIT,QAAQU,SAAS,IAAI/D,YAAYqD,QAAQU,SAAS,EAAE,OAAO;oBAC/D,IAAIV,QAAQW,OAAO,IAAIhE,YAAYqD,QAAQW,OAAO,EAAE,OAAO;oBAC3D,OAAO;gBACT,GACCnB,GAAG,CAACe,CAAAA,IAAM,CAAA;wBACTF,IAAIE,EAAEF,EAAE;wBACRZ,OAAOS,QAAQR,QAAQ,CAACC,IAAI;wBAC5BJ,QAAQgB,EAAEhB,MAAM,CAACA,MAAM;wBACvBX,QAAQ,IAAI,CAACkD,SAAS,CAACvB,EAAE3B,MAAM;wBAC/BmD,QAAQxB,EAAEyB,OAAO,EAAEC;wBACnBtF,WAAW,IAAIe,KAAK6C,EAAEE,UAAU;oBAClC,CAAA;gBAEFmB,YAAYL,IAAI,IAAIM;YACtB,EAAE,OAAM;YACN,4CAA4C;YAC9C;QACF;QAEA,OAAOD;IACT;IAEA,MAAMM,eAAelC,UAIjB,CAAC,CAAC,EAAiC;QAgBrC,MAAMd,WAAW,MAAM,IAAI,CAAC5B,OAAO,CAAoB,OAAO;QAC9D,MAAM6E,iBAAuC,EAAE;QAE/C,KAAK,MAAMjC,WAAWhB,SAAU;YAC9B,IAAIc,QAAQP,KAAK,IAAIS,QAAQR,QAAQ,CAACC,IAAI,KAAKK,QAAQP,KAAK,EAAE;gBAC5D;YACF;YAEA,IAAI;gBACF,MAAMW,eAAe,MAAM,IAAI,CAAC9C,OAAO,CACrC,OACA,CAAC,aAAa,EAAE4C,QAAQG,EAAE,CAAC,uBAAuB,CAAC;gBAGrD,MAAM+B,cAAchC,aACjBjB,MAAM,CAACoB,CAAAA,IAAKA,EAAEC,IAAI,KAAK,UAAUnB,WAAWkB,EAAEhB,MAAM,CAACA,MAAM,IAAI,GAC/DJ,MAAM,CAACoB,CAAAA;oBACN,MAAM5D,YAAY,IAAIe,KAAK6C,EAAEE,UAAU;oBACvC,IAAIT,QAAQU,SAAS,IAAI/D,YAAYqD,QAAQU,SAAS,EAAE,OAAO;oBAC/D,IAAIV,QAAQW,OAAO,IAAIhE,YAAYqD,QAAQW,OAAO,EAAE,OAAO;oBAC3D,OAAO;gBACT,GACCnB,GAAG,CAACe,CAAAA,IAAM,CAAA;wBACTF,IAAIE,EAAEF,EAAE;wBACRZ,OAAOS,QAAQR,QAAQ,CAACC,IAAI;wBAC5BJ,QAAQ/B,KAAKwD,GAAG,CAAC3B,WAAWkB,EAAEhB,MAAM,CAACA,MAAM,GAAG3B,QAAQ;wBACtDyE,KAAK9B,EAAEyB,OAAO,EAAEM,iBAAiB/C,UAAU;wBAC3CX,QAAQ,IAAI,CAAC2D,mBAAmB,CAAChC,EAAE3B,MAAM;wBACzCmD,QAAQxB,EAAEyB,OAAO,EAAEC;wBACnBO,SAASjC,EAAEkC,EAAE,IAAI;wBACjB9F,WAAW,IAAIe,KAAK6C,EAAEE,UAAU;oBAClC,CAAA;gBAEF0B,eAAeZ,IAAI,IAAIa;YACzB,EAAE,OAAM;YACN,4CAA4C;YAC9C;QACF;QAEA,OAAOD;IACT;IAEQL,UAAUlD,MAAc,EAA6B;QAC3D,MAAM8D,YAAuD;YAC3DC,WAAW;YACXC,SAAS;YACTC,QAAQ;QACV;QACA,OAAOH,SAAS,CAAC9D,OAAO,IAAI;IAC9B;IAEQ2D,oBAAoB3D,MAAc,EAAgC;QACxE,MAAM8D,YAA0D;YAC9DC,WAAW;YACXC,SAAS;YACTC,QAAQ;YACRC,UAAU;QACZ;QACA,OAAOJ,SAAS,CAAC9D,OAAO,IAAI;IAC9B;IAlSA,YAAY,AAAiB1B,WAAgC,CAAE;aAAlCA,cAAAA;aALpB6F,OAAO;aACPC,UAAU;aACFrE,SAAS,IAAIsE,cAAM,CAACxG,eAAesG,IAAI;aACvC3E,UAAU;IAEqC;AAmSlE"}