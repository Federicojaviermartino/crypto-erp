{"version":3,"sources":["../../../../src/modules/crypto/services/blockchain-sync.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { PrismaService } from '@crypto-erp/database';\nimport { Wallet, CryptoTxType, TxStatus, Prisma } from '@prisma/client';\nimport { CovalentClient, CovalentTransaction, ChainName } from '../blockchain/covalent.client.js';\nimport { TransactionParser, ParsedTransaction } from '../blockchain/transaction-parser.js';\nimport { WalletsService } from './wallets.service.js';\n\nexport interface SyncResult {\n  walletId: string;\n  success: boolean;\n  transactionsProcessed: number;\n  newTransactions: number;\n  lastBlock?: bigint;\n  error?: string;\n}\n\nexport interface SyncProgress {\n  walletId: string;\n  status: 'pending' | 'syncing' | 'completed' | 'error';\n  progress: number;\n  message: string;\n}\n\n@Injectable()\nexport class BlockchainSyncService {\n  private readonly logger = new Logger(BlockchainSyncService.name);\n  private syncInProgress = new Map<string, boolean>();\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly covalent: CovalentClient,\n    private readonly parser: TransactionParser,\n    private readonly walletsService: WalletsService,\n  ) {}\n\n  async syncWallet(walletId: string): Promise<SyncResult> {\n    // Prevent concurrent syncs for the same wallet\n    if (this.syncInProgress.get(walletId)) {\n      return {\n        walletId,\n        success: false,\n        transactionsProcessed: 0,\n        newTransactions: 0,\n        error: 'Sync already in progress',\n      };\n    }\n\n    this.syncInProgress.set(walletId, true);\n\n    try {\n      const wallet = await this.prisma.wallet.findUnique({\n        where: { id: walletId },\n      });\n\n      if (!wallet) {\n        throw new Error('Wallet not found');\n      }\n\n      if (!this.covalent.isConfigured()) {\n        throw new Error('Covalent API not configured');\n      }\n\n      // Mark as syncing\n      await this.walletsService.setSyncStatus(walletId, 'SYNCING');\n\n      const chainName = this.covalent.getChainName(wallet.chain);\n      const startBlock = wallet.lastSyncBlock ? Number(wallet.lastSyncBlock) + 1 : undefined;\n\n      let totalProcessed = 0;\n      let newTransactions = 0;\n      let lastBlock = wallet.lastSyncBlock;\n      let hasMore = true;\n      let pageNumber = 0;\n\n      while (hasMore) {\n        const result = await this.covalent.getTransactions(wallet.chain, wallet.address, {\n          pageSize: 100,\n          pageNumber,\n          startBlock,\n        });\n\n        for (const tx of result.transactions) {\n          const created = await this.processTransaction(wallet, tx, chainName);\n          totalProcessed++;\n          if (created) newTransactions++;\n\n          // Track highest block\n          const blockNum = BigInt(tx.block_height);\n          if (!lastBlock || blockNum > lastBlock) {\n            lastBlock = blockNum;\n          }\n        }\n\n        hasMore = result.hasMore;\n        pageNumber++;\n\n        // Safety limit to prevent infinite loops\n        if (pageNumber > 100) {\n          this.logger.warn(`Sync limit reached for wallet ${walletId}`);\n          break;\n        }\n      }\n\n      // Also sync ERC20 transfers to capture token movements\n      await this.syncERC20Transfers(wallet, chainName, startBlock);\n\n      // Mark as synced\n      await this.walletsService.setSyncStatus(walletId, 'SYNCED', null, lastBlock || undefined);\n\n      return {\n        walletId,\n        success: true,\n        transactionsProcessed: totalProcessed,\n        newTransactions,\n        lastBlock: lastBlock || undefined,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      this.logger.error(`Sync failed for wallet ${walletId}:`, error);\n\n      await this.walletsService.setSyncStatus(walletId, 'ERROR', errorMessage);\n\n      return {\n        walletId,\n        success: false,\n        transactionsProcessed: 0,\n        newTransactions: 0,\n        error: errorMessage,\n      };\n    } finally {\n      this.syncInProgress.delete(walletId);\n    }\n  }\n\n  private async processTransaction(\n    wallet: Wallet,\n    tx: CovalentTransaction,\n    chainName: ChainName,\n  ): Promise<boolean> {\n    // Check if transaction already exists\n    const existing = await this.prisma.cryptoTransaction.findFirst({\n      where: {\n        walletId: wallet.id,\n        txHash: tx.tx_hash,\n      },\n    });\n\n    if (existing) {\n      return false;\n    }\n\n    // Parse the transaction\n    const parsed = this.parser.parseTransaction(tx, wallet.address, chainName);\n\n    // Create the transaction record\n    await this.prisma.cryptoTransaction.create({\n      data: {\n        walletId: wallet.id,\n        txHash: tx.tx_hash,\n        blockNumber: BigInt(tx.block_height),\n        blockTimestamp: new Date(tx.block_signed_at),\n        chain: wallet.chain,\n        type: parsed.type,\n        subtype: parsed.subtype,\n        assetIn: parsed.assetIn,\n        amountIn: parsed.amountIn ? new Prisma.Decimal(parsed.amountIn) : null,\n        assetOut: parsed.assetOut,\n        amountOut: parsed.amountOut ? new Prisma.Decimal(parsed.amountOut) : null,\n        feeAsset: parsed.feeAsset,\n        feeAmount: parsed.feeAmount ? new Prisma.Decimal(parsed.feeAmount) : null,\n        feeEur: tx.gas_quote ? new Prisma.Decimal(tx.gas_quote.toString()) : null,\n        aiCategorized: true,\n        aiConfidence: new Prisma.Decimal(parsed.confidence.toString()),\n        aiReasoning: parsed.reasoning,\n        status: parsed.confidence >= 0.8 ? 'COMPLETED' : 'NEEDS_REVIEW',\n        rawData: tx as unknown as Prisma.InputJsonValue,\n      },\n    });\n\n    return true;\n  }\n\n  private async syncERC20Transfers(\n    wallet: Wallet,\n    chainName: ChainName,\n    startBlock?: number,\n  ): Promise<void> {\n    try {\n      const result = await this.covalent.getERC20Transfers(wallet.chain, wallet.address, {\n        pageSize: 100,\n        startBlock,\n      });\n\n      for (const item of result.transfers) {\n        // Each item may have multiple transfers in a single transaction\n        for (const transfer of item.transfers || []) {\n          // Check if we already have this transaction\n          const existing = await this.prisma.cryptoTransaction.findFirst({\n            where: {\n              walletId: wallet.id,\n              txHash: item.tx_hash,\n            },\n          });\n\n          // If transaction exists, skip (we already processed it from the main sync)\n          if (existing) continue;\n\n          // Create transfer transaction\n          const isIncoming = transfer.transfer_type === 'IN';\n          const amount = this.formatTokenAmount(\n            transfer.delta,\n            transfer.contract_decimals,\n          );\n\n          await this.prisma.cryptoTransaction.create({\n            data: {\n              walletId: wallet.id,\n              txHash: item.tx_hash,\n              blockNumber: BigInt(item.block_height),\n              blockTimestamp: new Date(item.block_signed_at),\n              chain: wallet.chain,\n              type: isIncoming ? 'TRANSFER_IN' : 'TRANSFER_OUT',\n              assetIn: isIncoming ? transfer.contract_ticker_symbol : null,\n              amountIn: isIncoming ? new Prisma.Decimal(amount) : null,\n              assetOut: !isIncoming ? transfer.contract_ticker_symbol : null,\n              amountOut: !isIncoming ? new Prisma.Decimal(amount) : null,\n              priceInEur: isIncoming && transfer.delta_quote\n                ? new Prisma.Decimal(transfer.delta_quote.toString())\n                : null,\n              priceOutEur: !isIncoming && transfer.delta_quote\n                ? new Prisma.Decimal(transfer.delta_quote.toString())\n                : null,\n              aiCategorized: true,\n              aiConfidence: new Prisma.Decimal('0.9'),\n              aiReasoning: `ERC20 transfer ${transfer.transfer_type} from Covalent`,\n              status: 'COMPLETED',\n            },\n          });\n        }\n      }\n    } catch (error) {\n      this.logger.warn(`Failed to sync ERC20 transfers for wallet ${wallet.id}:`, error);\n      // Don't fail the main sync for ERC20 transfer errors\n    }\n  }\n\n  private formatTokenAmount(amount: string, decimals: number): string {\n    const value = BigInt(amount);\n    const divisor = BigInt(10 ** decimals);\n    const intPart = value / divisor;\n    const fracPart = value % divisor;\n    const fracStr = fracPart.toString().padStart(decimals, '0');\n    return `${intPart}.${fracStr}`;\n  }\n\n  async syncAllWallets(companyId?: string): Promise<SyncResult[]> {\n    const wallets = await this.walletsService.getWalletsForSync(companyId);\n    const results: SyncResult[] = [];\n\n    for (const wallet of wallets) {\n      const result = await this.syncWallet(wallet.id);\n      results.push(result);\n    }\n\n    return results;\n  }\n\n  async getTransactionsNeedingReview(companyId: string): Promise<any[]> {\n    return this.prisma.cryptoTransaction.findMany({\n      where: {\n        wallet: { companyId },\n        status: 'NEEDS_REVIEW',\n      },\n      include: {\n        wallet: {\n          select: {\n            label: true,\n            address: true,\n            chain: true,\n          },\n        },\n      },\n      orderBy: { blockTimestamp: 'desc' },\n      take: 100,\n    });\n  }\n\n  async updateTransactionType(\n    companyId: string,\n    transactionId: string,\n    newType: CryptoTxType,\n    notes?: string,\n  ): Promise<void> {\n    // Verify transaction belongs to company\n    const tx = await this.prisma.cryptoTransaction.findFirst({\n      where: {\n        id: transactionId,\n        wallet: { companyId },\n      },\n    });\n\n    if (!tx) {\n      throw new Error('Transaction not found');\n    }\n\n    await this.prisma.cryptoTransaction.update({\n      where: { id: transactionId },\n      data: {\n        manualType: newType,\n        manualNotes: notes,\n        status: 'COMPLETED',\n      },\n    });\n  }\n\n  isSyncing(walletId: string): boolean {\n    return this.syncInProgress.get(walletId) || false;\n  }\n}\n"],"names":["BlockchainSyncService","syncWallet","walletId","syncInProgress","get","success","transactionsProcessed","newTransactions","error","set","wallet","prisma","findUnique","where","id","Error","covalent","isConfigured","walletsService","setSyncStatus","chainName","getChainName","chain","startBlock","lastSyncBlock","Number","undefined","totalProcessed","lastBlock","hasMore","pageNumber","result","getTransactions","address","pageSize","tx","transactions","created","processTransaction","blockNum","BigInt","block_height","logger","warn","syncERC20Transfers","errorMessage","message","delete","existing","cryptoTransaction","findFirst","txHash","tx_hash","parsed","parser","parseTransaction","create","data","blockNumber","blockTimestamp","Date","block_signed_at","type","subtype","assetIn","amountIn","Prisma","Decimal","assetOut","amountOut","feeAsset","feeAmount","feeEur","gas_quote","toString","aiCategorized","aiConfidence","confidence","aiReasoning","reasoning","status","rawData","getERC20Transfers","item","transfers","transfer","isIncoming","transfer_type","amount","formatTokenAmount","delta","contract_decimals","contract_ticker_symbol","priceInEur","delta_quote","priceOutEur","decimals","value","divisor","intPart","fracPart","fracStr","padStart","syncAllWallets","companyId","wallets","getWalletsForSync","results","push","getTransactionsNeedingReview","findMany","include","select","label","orderBy","take","updateTransactionType","transactionId","newType","notes","update","manualType","manualNotes","isSyncing","Logger","name","Map"],"mappings":"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"}